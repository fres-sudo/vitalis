import {
  ZodFirstPartyTypeKind
} from "./chunk-UCLI4ZLA.js";
import {
  createAdapter,
  createJsonSchema,
  splitPath,
  traversePath,
  traversePaths
} from "./chunk-LGYYCH7N.js";
import {
  __commonJS,
  __toESM
} from "./chunk-DWA4UIM3.js";

// node_modules/.pnpm/memoize-weak@1.0.2/node_modules/memoize-weak/lib/memoize.js
var require_memoize = __commonJS({
  "node_modules/.pnpm/memoize-weak@1.0.2/node_modules/memoize-weak/lib/memoize.js"(exports, module) {
    function isPrimitive(value) {
      return typeof value !== "object" && typeof value !== "function" || value === null;
    }
    function MapTree() {
      this.childBranches = /* @__PURE__ */ new WeakMap();
      this.primitiveKeys = /* @__PURE__ */ new Map();
      this.hasValue = false;
      this.value = void 0;
    }
    MapTree.prototype.has = function has(key) {
      var keyObject = isPrimitive(key) ? this.primitiveKeys.get(key) : key;
      return keyObject ? this.childBranches.has(keyObject) : false;
    };
    MapTree.prototype.get = function get(key) {
      var keyObject = isPrimitive(key) ? this.primitiveKeys.get(key) : key;
      return keyObject ? this.childBranches.get(keyObject) : void 0;
    };
    MapTree.prototype.resolveBranch = function resolveBranch(key) {
      if (this.has(key)) {
        return this.get(key);
      }
      var newBranch = new MapTree();
      var keyObject = this.createKey(key);
      this.childBranches.set(keyObject, newBranch);
      return newBranch;
    };
    MapTree.prototype.setValue = function setValue(value) {
      this.hasValue = true;
      return this.value = value;
    };
    MapTree.prototype.createKey = function createKey(key) {
      if (isPrimitive(key)) {
        var keyObject = {};
        this.primitiveKeys.set(key, keyObject);
        return keyObject;
      }
      return key;
    };
    MapTree.prototype.clear = function clear() {
      if (arguments.length === 0) {
        this.childBranches = /* @__PURE__ */ new WeakMap();
        this.primitiveKeys.clear();
        this.hasValue = false;
        this.value = void 0;
      } else if (arguments.length === 1) {
        var key = arguments[0];
        if (isPrimitive(key)) {
          var keyObject = this.primitiveKeys.get(key);
          if (keyObject) {
            this.childBranches.delete(keyObject);
            this.primitiveKeys.delete(key);
          }
        } else {
          this.childBranches.delete(key);
        }
      } else {
        var childKey = arguments[0];
        if (this.has(childKey)) {
          var childBranch = this.get(childKey);
          childBranch.clear.apply(childBranch, Array.prototype.slice.call(arguments, 1));
        }
      }
    };
    module.exports = function memoize2(fn) {
      var argsTree = new MapTree();
      function memoized() {
        var args = Array.prototype.slice.call(arguments);
        var argNode = args.reduce(function getBranch(parentBranch, arg) {
          return parentBranch.resolveBranch(arg);
        }, argsTree);
        if (argNode.hasValue) {
          return argNode.value;
        }
        var value = fn.apply(null, args);
        return argNode.setValue(value);
      }
      memoized.clear = argsTree.clear.bind(argsTree);
      return memoized;
    };
  }
});

// node_modules/.pnpm/memoize-weak@1.0.2/node_modules/memoize-weak/index.js
var require_memoize_weak = __commonJS({
  "node_modules/.pnpm/memoize-weak@1.0.2/node_modules/memoize-weak/index.js"(exports, module) {
    module.exports = require_memoize();
  }
});

// node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/safe-format.js
var require_safe_format = __commonJS({
  "node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/safe-format.js"(exports, module) {
    "use strict";
    var SafeString = class extends String {
    };
    var compares = /* @__PURE__ */ new Set(["<", ">", "<=", ">="]);
    var escapeCode = (code) => `\\u${code.toString(16).padStart(4, "0")}`;
    var jsval = (val) => {
      if ([Infinity, -Infinity, NaN, void 0, null].includes(val)) return `${val}`;
      const primitive = ["string", "boolean", "number"].includes(typeof val);
      if (!primitive) {
        if (typeof val !== "object") throw new Error("Unexpected value type");
        const proto = Object.getPrototypeOf(val);
        const ok = proto === Array.prototype && Array.isArray(val) || proto === Object.prototype;
        if (!ok) throw new Error("Unexpected object given as value");
      }
      return JSON.stringify(val).replace(/([{,])"__proto__":/g, '$1["__proto__"]:').replace(/[^\\]"__proto__":/g, () => {
        throw new Error("Unreachable");
      }).replace(/[\u2028\u2029]/g, (char) => escapeCode(char.charCodeAt(0)));
    };
    var format = (fmt, ...args) => {
      const res = fmt.replace(/%[%drscjw]/g, (match) => {
        if (match === "%%") return "%";
        if (args.length === 0) throw new Error("Unexpected arguments count");
        const val = args.shift();
        switch (match) {
          case "%d":
            if (typeof val === "number") return val;
            throw new Error("Expected a number");
          case "%r":
            if (val instanceof RegExp) return format("new RegExp(%j, %j)", val.source, val.flags);
            throw new Error("Expected a RegExp instance");
          case "%s":
            if (val instanceof SafeString) return val;
            throw new Error("Expected a safe string");
          case "%c":
            if (compares.has(val)) return val;
            throw new Error("Expected a compare op");
          case "%j":
            return jsval(val);
          case "%w":
            if (Number.isInteger(val) && val >= 0) return " ".repeat(val);
            throw new Error("Expected a non-negative integer for indentation");
        }
        throw new Error("Unreachable");
      });
      if (args.length !== 0) throw new Error("Unexpected arguments count");
      return new SafeString(res);
    };
    var safe = (string) => {
      if (!/^[a-z][a-z0-9_]*$/i.test(string)) throw new Error("Does not look like a safe id");
      return new SafeString(string);
    };
    var safewrap = (fun) => (...args) => {
      if (!args.every((arg) => arg instanceof SafeString)) throw new Error("Unsafe arguments");
      return new SafeString(fun(...args));
    };
    var safepriority = (arg) => (
      // simple expression and single brackets can not break priority
      /^[a-z][a-z0-9_().]*$/i.test(arg) || /^\([^()]+\)$/i.test(arg) ? arg : format("(%s)", arg)
    );
    var safeor = safewrap(
      (...args) => args.some((arg) => `${arg}` === "true") ? "true" : args.join(" || ") || "false"
    );
    var safeand = safewrap(
      (...args) => args.some((arg) => `${arg}` === "false") ? "false" : args.join(" && ") || "true"
    );
    var safenot = (arg) => {
      if (`${arg}` === "true") return safe("false");
      if (`${arg}` === "false") return safe("true");
      return format("!%s", safepriority(arg));
    };
    var safenotor = (...args) => safenot(safeor(...args));
    module.exports = { format, safe, safeand, safenot, safenotor };
  }
});

// node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/scope-utils.js
var require_scope_utils = __commonJS({
  "node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/scope-utils.js"(exports, module) {
    "use strict";
    var { safe } = require_safe_format();
    var caches = /* @__PURE__ */ new WeakMap();
    var scopeMethods = (scope) => {
      if (!caches.has(scope))
        caches.set(scope, { sym: /* @__PURE__ */ new Map(), ref: /* @__PURE__ */ new Map(), format: /* @__PURE__ */ new Map(), pattern: /* @__PURE__ */ new Map() });
      const cache2 = caches.get(scope);
      const gensym = (name) => {
        if (!cache2.sym.get(name)) cache2.sym.set(name, 0);
        const index = cache2.sym.get(name);
        cache2.sym.set(name, index + 1);
        return safe(`${name}${index}`);
      };
      const genpattern = (p) => {
        if (cache2.pattern.has(p)) return cache2.pattern.get(p);
        const n = gensym("pattern");
        scope[n] = new RegExp(p, "u");
        cache2.pattern.set(p, n);
        return n;
      };
      if (!cache2.loop) cache2.loop = "ijklmnopqrstuvxyz".split("");
      const genloop = () => {
        const v = cache2.loop.shift();
        cache2.loop.push(`${v}${v[0]}`);
        return safe(v);
      };
      const getref = (sub) => cache2.ref.get(sub);
      const genref = (sub) => {
        const n = gensym("ref");
        cache2.ref.set(sub, n);
        return n;
      };
      const genformat = (impl) => {
        let n = cache2.format.get(impl);
        if (!n) {
          n = gensym("format");
          scope[n] = impl;
          cache2.format.set(impl, n);
        }
        return n;
      };
      return { gensym, genpattern, genloop, getref, genref, genformat };
    };
    module.exports = { scopeMethods };
  }
});

// node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/scope-functions.js
var require_scope_functions = __commonJS({
  "node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/scope-functions.js"(exports, module) {
    "use strict";
    var stringLength = (string) => /[\uD800-\uDFFF]/.test(string) ? [...string].length : string.length;
    var isMultipleOf = (value, divisor, factor, factorMultiple) => {
      if (value % divisor === 0) return true;
      let multiple = value * factor;
      if (multiple === Infinity || multiple === -Infinity) multiple = value;
      if (multiple % factorMultiple === 0) return true;
      const normal = Math.floor(multiple + 0.5);
      return normal / factor === value && normal % factorMultiple === 0;
    };
    var deepEqual = (obj, obj2) => {
      if (obj === obj2) return true;
      if (!obj || !obj2 || typeof obj !== typeof obj2) return false;
      if (obj !== obj2 && typeof obj !== "object") return false;
      const proto = Object.getPrototypeOf(obj);
      if (proto !== Object.getPrototypeOf(obj2)) return false;
      if (proto === Array.prototype) {
        if (!Array.isArray(obj) || !Array.isArray(obj2)) return false;
        if (obj.length !== obj2.length) return false;
        return obj.every((x, i) => deepEqual(x, obj2[i]));
      } else if (proto === Object.prototype) {
        const [keys, keys2] = [Object.keys(obj), Object.keys(obj2)];
        if (keys.length !== keys2.length) return false;
        const keyset2 = /* @__PURE__ */ new Set([...keys, ...keys2]);
        return keyset2.size === keys.length && keys.every((key) => deepEqual(obj[key], obj2[key]));
      }
      return false;
    };
    var unique = (array) => {
      if (array.length < 2) return true;
      if (array.length === 2) return !deepEqual(array[0], array[1]);
      const objects = [];
      const primitives = array.length > 20 ? /* @__PURE__ */ new Set() : null;
      let primitivesCount = 0;
      let pos = 0;
      for (const item of array) {
        if (typeof item === "object") {
          objects.push(item);
        } else if (primitives) {
          primitives.add(item);
          if (primitives.size !== ++primitivesCount) return false;
        } else {
          if (array.indexOf(item, pos + 1) !== -1) return false;
        }
        pos++;
      }
      for (let i = 1; i < objects.length; i++)
        for (let j = 0; j < i; j++) if (deepEqual(objects[i], objects[j])) return false;
      return true;
    };
    var deBase64 = (string) => {
      if (typeof Buffer !== "undefined") return Buffer.from(string, "base64").toString("utf-8");
      const b = atob(string);
      return new TextDecoder("utf-8").decode(new Uint8Array(b.length).map((_, i) => b.charCodeAt(i)));
    };
    var hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
    hasOwn[Symbol.for("toJayString")] = "Function.prototype.call.bind(Object.prototype.hasOwnProperty)";
    var pointerPart = (s) => /~\//.test(s) ? `${s}`.replace(/~/g, "~0").replace(/\//g, "~1") : s;
    var toPointer = (path) => path.length === 0 ? "#" : `#/${path.map(pointerPart).join("/")}`;
    var errorMerge = ({ keywordLocation, instanceLocation }, schemaBase, dataBase) => ({
      keywordLocation: `${schemaBase}${keywordLocation.slice(1)}`,
      instanceLocation: `${dataBase}${instanceLocation.slice(1)}`
    });
    var propertyIn = (key, [properties, patterns]) => properties.includes(true) || properties.some((prop) => prop === key) || patterns.some((pattern) => new RegExp(pattern, "u").test(key));
    var dynamicResolve = (anchors, id) => (anchors.filter((x) => x[id])[0] || {})[id];
    var extraUtils = { toPointer, pointerPart, errorMerge, propertyIn, dynamicResolve };
    module.exports = { stringLength, isMultipleOf, deepEqual, unique, deBase64, hasOwn, ...extraUtils };
  }
});

// node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/javascript.js
var require_javascript = __commonJS({
  "node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/javascript.js"(exports, module) {
    "use strict";
    var { format, safe } = require_safe_format();
    var { scopeMethods } = require_scope_utils();
    var functions = require_scope_functions();
    var types = new Map(
      Object.entries({
        null: (name) => format("%s === null", name),
        boolean: (name) => format('typeof %s === "boolean"', name),
        array: (name) => format("Array.isArray(%s)", name),
        object: (n) => format('typeof %s === "object" && %s && !Array.isArray(%s)', n, n, n),
        number: (name) => format('typeof %s === "number"', name),
        integer: (name) => format("Number.isInteger(%s)", name),
        string: (name) => format('typeof %s === "string"', name)
      })
    );
    var buildName = ({ name, parent, keyval, keyname }) => {
      if (name) {
        if (parent || keyval || keyname) throw new Error("name can be used only stand-alone");
        return name;
      }
      if (!parent) throw new Error("Can not use property of undefined parent!");
      const parentName = buildName(parent);
      if (keyval !== void 0) {
        if (keyname) throw new Error("Can not use key value and name together");
        if (!["string", "number"].includes(typeof keyval)) throw new Error("Invalid property path");
        if (/^[a-z][a-z0-9_]*$/i.test(keyval)) return format("%s.%s", parentName, safe(keyval));
        return format("%s[%j]", parentName, keyval);
      } else if (keyname) {
        return format("%s[%s]", parentName, keyname);
      }
      throw new Error("Unreachable");
    };
    var jsonProtoKeys = new Set(
      [].concat(
        ...[Object, Array, String, Number, Boolean].map((c) => Object.getOwnPropertyNames(c.prototype))
      )
    );
    var jsHelpers = (fun, scope, propvar, { unmodifiedPrototypes, isJSON }, noopRegExps) => {
      const { gensym, genpattern, genloop } = scopeMethods(scope, propvar);
      const present = (obj) => {
        const name = buildName(obj);
        const { parent, keyval, keyname, inKeys, checked } = obj;
        if (checked || inKeys && isJSON) throw new Error("Unreachable: useless check for undefined");
        if (inKeys) return format("%s !== undefined", name);
        if (parent && keyname) {
          scope.hasOwn = functions.hasOwn;
          const pname = buildName(parent);
          if (isJSON) return format("%s !== undefined && hasOwn(%s, %s)", name, pname, keyname);
          return format("%s in %s && hasOwn(%s, %s)", keyname, pname, pname, keyname);
        } else if (parent && keyval !== void 0) {
          if (unmodifiedPrototypes && isJSON && !jsonProtoKeys.has(`${keyval}`))
            return format("%s !== undefined", name);
          scope.hasOwn = functions.hasOwn;
          const pname = buildName(parent);
          if (isJSON) return format("%s !== undefined && hasOwn(%s, %j)", name, pname, keyval);
          return format("%j in %s && hasOwn(%s, %j)", keyval, pname, pname, keyval);
        }
        throw new Error("Unreachable: present() check without parent");
      };
      const forObjectKeys = (obj, writeBody) => {
        const key = gensym("key");
        fun.block(format("for (const %s of Object.keys(%s))", key, buildName(obj)), () => {
          writeBody(propvar(obj, key, true), key);
        });
      };
      const forArray = (obj, start, writeBody) => {
        const i = genloop();
        const name = buildName(obj);
        fun.block(format("for (let %s = %s; %s < %s.length; %s++)", i, start, i, name, i), () => {
          writeBody(propvar(obj, i, unmodifiedPrototypes, true), i);
        });
      };
      const patternTest = (pat, key) => {
        const r = pat.replace(/[.^$|*+?(){}[\]\\]/gu, "");
        if (pat === `^${r}$`) return format("(%s === %j)", key, pat.slice(1, -1));
        if (noopRegExps.has(pat)) return format("true");
        if ([r, `${r}+`, `${r}.*`, `.*${r}.*`].includes(pat)) return format("%s.includes(%j)", key, r);
        if ([`^${r}`, `^${r}+`, `^${r}.*`].includes(pat)) return format("%s.startsWith(%j)", key, r);
        if ([`${r}$`, `.*${r}$`].includes(pat)) return format("%s.endsWith(%j)", key, r);
        const subr = [...r].slice(0, -1).join("");
        if ([`${r}*`, `${r}?`].includes(pat))
          return subr.length === 0 ? format("true") : format("%s.includes(%j)", key, subr);
        if ([`^${r}*`, `^${r}?`].includes(pat))
          return subr.length === 0 ? format("true") : format("%s.startsWith(%j)", key, subr);
        return format("%s.test(%s)", genpattern(pat), key);
      };
      const compare = (name, val) => {
        if (!val || typeof val !== "object") return format("%s === %j", name, val);
        let type;
        const shouldInline = (arr) => arr.length <= 3 && arr.every((x) => !x || typeof x !== "object");
        if (Array.isArray(val)) {
          type = types.get("array")(name);
          if (shouldInline(val)) {
            let k = format("%s.length === %d", name, val.length);
            for (let i = 0; i < val.length; i++) k = format("%s && %s[%d] === %j", k, name, i, val[i]);
            return format("%s && %s", type, k);
          }
        } else {
          type = types.get("object")(name);
          const [keys, values] = [Object.keys(val), Object.values(val)];
          if (shouldInline(values)) {
            let k = format("Object.keys(%s).length === %d", name, keys.length);
            if (keys.length > 0) scope.hasOwn = functions.hasOwn;
            for (const key of keys) k = format("%s && hasOwn(%s, %j)", k, name, key);
            for (const key of keys) k = format("%s && %s[%j] === %j", k, name, key, val[key]);
            return format("%s && %s", type, k);
          }
        }
        scope.deepEqual = functions.deepEqual;
        return format("%s && deepEqual(%s, %j)", type, name, val);
      };
      return { present, forObjectKeys, forArray, patternTest, compare, propvar };
    };
    var isArrowFnWithParensRegex = /^\([^)]*\) *=>/;
    var isArrowFnWithoutParensRegex = /^[^=]*=>/;
    var toJayString = Symbol.for("toJayString");
    function jaystring(item) {
      if (typeof item === "function") {
        if (item[toJayString]) return item[toJayString];
        if (Object.getPrototypeOf(item) !== Function.prototype)
          throw new Error("Can not stringify: a function with unexpected prototype");
        const stringified = `${item}`;
        if (item.prototype) {
          if (!/^function[ (]/.test(stringified)) throw new Error("Unexpected function");
          return stringified;
        }
        if (isArrowFnWithParensRegex.test(stringified) || isArrowFnWithoutParensRegex.test(stringified))
          return stringified;
        throw new Error("Can not stringify: only either normal or arrow functions are supported");
      } else if (typeof item === "object") {
        const proto = Object.getPrototypeOf(item);
        if (item instanceof RegExp && proto === RegExp.prototype) return format("%r", item);
        throw new Error("Can not stringify: an object with unexpected prototype");
      }
      throw new Error(`Can not stringify: unknown type ${typeof item}`);
    }
    module.exports = { types, buildName, jsHelpers, jaystring };
  }
});

// node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/generate-function.js
var require_generate_function = __commonJS({
  "node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/generate-function.js"(exports, module) {
    "use strict";
    var { format, safe, safenot } = require_safe_format();
    var { jaystring } = require_javascript();
    var INDENT_START = /[{[]/;
    var INDENT_END = /[}\]]/;
    module.exports = () => {
      const lines = [];
      let indent = 0;
      const pushLine = (line) => {
        if (INDENT_END.test(line.trim()[0])) indent--;
        lines.push({ indent, code: line });
        if (INDENT_START.test(line[line.length - 1])) indent++;
      };
      const build = () => {
        if (indent !== 0) throw new Error("Unexpected indent at build()");
        const joined = lines.map((line) => format("%w%s", line.indent * 2, line.code)).join("\n");
        return /^[a-z][a-z0-9]*$/i.test(joined) ? `return ${joined}` : `return (${joined})`;
      };
      const processScope = (scope) => {
        const entries = Object.entries(scope);
        for (const [key, value] of entries) {
          if (!/^[a-z][a-z0-9]*$/i.test(key)) throw new Error("Unexpected scope key!");
          if (!(typeof value === "function" || value instanceof RegExp))
            throw new Error("Unexpected scope value!");
        }
        return entries;
      };
      return {
        optimizedOut: false,
        // some branch of code has been optimized out
        size: () => lines.length,
        write(fmt, ...args) {
          if (typeof fmt !== "string") throw new Error("Format must be a string!");
          if (fmt.includes("\n")) throw new Error("Only single lines are supported");
          pushLine(format(fmt, ...args));
          return true;
        },
        block(prefix, writeBody, noInline = false) {
          const oldIndent = indent;
          this.write("%s {", prefix);
          const length = lines.length;
          writeBody();
          if (length === lines.length) {
            lines.pop();
            indent = oldIndent;
            return false;
          } else if (length === lines.length - 1 && !noInline) {
            const { code } = lines[lines.length - 1];
            if (!/^(if|for) /.test(code)) {
              lines.length -= 2;
              indent = oldIndent;
              return this.write("%s %s", prefix, code);
            }
          }
          return this.write("}");
        },
        if(condition, writeBody, writeElse) {
          if (`${condition}` === "false") {
            if (writeElse) writeElse();
            if (writeBody) this.optimizedOut = true;
          } else if (`${condition}` === "true") {
            if (writeBody) writeBody();
            if (writeElse) this.optimizedOut = true;
          } else if (writeBody && this.block(format("if (%s)", condition), writeBody, !!writeElse)) {
            if (writeElse) this.block(format("else"), writeElse);
          } else if (writeElse) {
            this.if(safenot(condition), writeElse);
          }
        },
        makeModule(scope = {}) {
          const scopeDefs = processScope(scope).map(
            ([key, val]) => `const ${safe(key)} = ${jaystring(val)};`
          );
          return `(function() {
'use strict'
${scopeDefs.join("\n")}
${build()}})()`;
        },
        makeFunction(scope = {}) {
          const scopeEntries = processScope(scope);
          const keys = scopeEntries.map((entry) => entry[0]);
          const vals = scopeEntries.map((entry) => entry[1]);
          return Function(...keys, `'use strict'
${build()}`)(...vals);
        }
      };
    };
  }
});

// node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/known-keywords.js
var require_known_keywords = __commonJS({
  "node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/known-keywords.js"(exports, module) {
    "use strict";
    var knownKeywords = [
      ...["$schema", "$vocabulary"],
      // version
      ...["id", "$id", "$anchor", "$ref", "definitions", "$defs"],
      // pointers
      ...["$recursiveRef", "$recursiveAnchor", "$dynamicAnchor", "$dynamicRef"],
      ...["type", "required", "default"],
      // generic
      ...["enum", "const"],
      // constant values
      ...["not", "allOf", "anyOf", "oneOf", "if", "then", "else"],
      // logical checks
      ...["maximum", "minimum", "exclusiveMaximum", "exclusiveMinimum", "multipleOf", "divisibleBy"],
      // numbers
      ...["items", "maxItems", "minItems", "additionalItems", "prefixItems"],
      // arrays, basic
      ...["contains", "minContains", "maxContains", "uniqueItems"],
      // arrays, complex
      ...["maxLength", "minLength", "format", "pattern"],
      // strings
      ...["contentEncoding", "contentMediaType", "contentSchema"],
      // strings content
      ...["properties", "maxProperties", "minProperties", "additionalProperties", "patternProperties"],
      // objects
      ...["propertyNames"],
      // objects
      ...["dependencies", "dependentRequired", "dependentSchemas", "propertyDependencies"],
      // objects (dependencies)
      ...["unevaluatedProperties", "unevaluatedItems"],
      // see-through
      // Unused meta keywords not affecting validation (annotations and comments)
      // https://json-schema.org/understanding-json-schema/reference/generic.html
      // https://json-schema.org/draft/2019-09/json-schema-validation.html#rfc.section.9
      ...["title", "description", "deprecated", "readOnly", "writeOnly", "examples", "$comment"],
      // unused meta
      ...["example"],
      // unused meta, OpenAPI
      "discriminator",
      // optimization hint and error filtering only, does not affect validation result
      "removeAdditional"
      // optional keyword for { removeAdditional: 'keyword' } config, to target specific objects
    ];
    var schemaDrafts = [
      ...["draft/next"],
      // not recommended to use, might change / break in an unexpected way
      ...["draft/2020-12", "draft/2019-09"],
      // new
      ...["draft-07", "draft-06", "draft-04", "draft-03"]
      // historic
    ];
    var schemaVersions = schemaDrafts.map((draft) => `https://json-schema.org/${draft}/schema`);
    var vocab2019 = ["core", "applicator", "validation", "meta-data", "format", "content"];
    var vocab2020 = [
      ...["core", "applicator", "unevaluated", "validation"],
      ...["meta-data", "format-annotation", "format-assertion", "content"]
    ];
    var knownVocabularies = [
      ...vocab2019.map((v) => `https://json-schema.org/draft/2019-09/vocab/${v}`),
      ...vocab2020.map((v) => `https://json-schema.org/draft/2020-12/vocab/${v}`)
    ];
    module.exports = { knownKeywords, schemaVersions, knownVocabularies };
  }
});

// node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/pointer.js
var require_pointer = __commonJS({
  "node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/pointer.js"(exports, module) {
    "use strict";
    var { knownKeywords } = require_known_keywords();
    function safeSet(map, key, value, comment = "keys") {
      if (!map.has(key)) return map.set(key, value);
      if (map.get(key) !== value) throw new Error(`Conflicting duplicate ${comment}: ${key}`);
    }
    function untilde(string) {
      if (!string.includes("~")) return string;
      return string.replace(/~[01]/g, (match) => {
        switch (match) {
          case "~1":
            return "/";
          case "~0":
            return "~";
        }
        throw new Error("Unreachable");
      });
    }
    function get(obj, pointer, objpath) {
      if (typeof obj !== "object") throw new Error("Invalid input object");
      if (typeof pointer !== "string") throw new Error("Invalid JSON pointer");
      const parts = pointer.split("/");
      if (!["", "#"].includes(parts.shift())) throw new Error("Invalid JSON pointer");
      if (parts.length === 0) return obj;
      let curr = obj;
      for (const part of parts) {
        if (typeof part !== "string") throw new Error("Invalid JSON pointer");
        if (objpath) objpath.push(curr);
        const prop = untilde(part);
        if (typeof curr !== "object") return void 0;
        if (!Object.prototype.hasOwnProperty.call(curr, prop)) return void 0;
        curr = curr[prop];
      }
      return curr;
    }
    var protocolRegex = /^https?:\/\//;
    function joinPath(baseFull, sub) {
      if (typeof baseFull !== "string" || typeof sub !== "string") throw new Error("Unexpected path!");
      if (sub.length === 0) return baseFull;
      const base = baseFull.replace(/#.*/, "");
      if (sub.startsWith("#")) return `${base}${sub}`;
      if (!base.includes("/") || protocolRegex.test(sub)) return sub;
      if (protocolRegex.test(base)) return `${new URL(sub, base)}`;
      if (sub.startsWith("/")) return sub;
      return [...base.split("/").slice(0, -1), sub].join("/");
    }
    function objpath2path(objpath) {
      const ids = objpath.map((obj) => obj && (obj.$id || obj.id) || "");
      return ids.filter((id) => id && typeof id === "string").reduce(joinPath, "");
    }
    var withSpecialChilds = ["properties", "patternProperties", "$defs", "definitions"];
    var skipChilds = ["const", "enum", "examples", "example", "comment"];
    var sSkip = Symbol("skip");
    function traverse(schema, work) {
      const visit = (sub, specialChilds = false) => {
        if (!sub || typeof sub !== "object") return;
        const res = work(sub);
        if (res !== void 0) return res === sSkip ? void 0 : res;
        for (const k of Object.keys(sub)) {
          if (!specialChilds && !Array.isArray(sub) && !knownKeywords.includes(k)) continue;
          if (!specialChilds && skipChilds.includes(k)) continue;
          const kres = visit(sub[k], !specialChilds && withSpecialChilds.includes(k));
          if (kres !== void 0) return kres;
        }
      };
      return visit(schema);
    }
    function resolveReference(root, schemas, ref, base = "") {
      const ptr = joinPath(base, ref);
      const results = [];
      const [main, hash = ""] = ptr.split("#");
      const local = decodeURI(hash);
      const visit = (sub, oldPath, specialChilds = false, dynamic = false) => {
        if (!sub || typeof sub !== "object") return;
        const id = sub.$id || sub.id;
        let path = oldPath;
        if (id && typeof id === "string") {
          path = joinPath(path, id);
          if (path === ptr || path === main && local === "") {
            results.push([sub, root, oldPath]);
          } else if (path === main && local[0] === "/") {
            const objpath = [];
            const res = get(sub, local, objpath);
            if (res !== void 0) results.push([res, root, joinPath(oldPath, objpath2path(objpath))]);
          }
        }
        const anchor = dynamic ? sub.$dynamicAnchor : sub.$anchor;
        if (anchor && typeof anchor === "string") {
          if (anchor.includes("#")) throw new Error("$anchor can't include '#'");
          if (anchor.startsWith("/")) throw new Error("$anchor can't start with '/'");
          path = joinPath(path, `#${anchor}`);
          if (path === ptr) results.push([sub, root, oldPath]);
        }
        for (const k of Object.keys(sub)) {
          if (!specialChilds && !Array.isArray(sub) && !knownKeywords.includes(k)) continue;
          if (!specialChilds && skipChilds.includes(k)) continue;
          visit(sub[k], path, !specialChilds && withSpecialChilds.includes(k));
        }
        if (!dynamic && sub.$dynamicAnchor) visit(sub, oldPath, specialChilds, true);
      };
      visit(root, main);
      if (main === base.replace(/#$/, "") && (local[0] === "/" || local === "")) {
        const objpath = [];
        const res = get(root, local, objpath);
        if (res !== void 0) results.push([res, root, objpath2path(objpath)]);
      }
      if (schemas.has(main) && schemas.get(main) !== root) {
        const additional = resolveReference(schemas.get(main), schemas, `#${hash}`, main);
        results.push(...additional.map(([res, rRoot, rPath]) => [res, rRoot, joinPath(main, rPath)]));
      }
      if (schemas.has(ptr)) results.push([schemas.get(ptr), schemas.get(ptr), ptr]);
      return results;
    }
    function getDynamicAnchors(schema) {
      const results = /* @__PURE__ */ new Map();
      traverse(schema, (sub) => {
        if (sub !== schema && (sub.$id || sub.id)) return sSkip;
        const anchor = sub.$dynamicAnchor;
        if (anchor && typeof anchor === "string") {
          if (anchor.includes("#")) throw new Error("$dynamicAnchor can't include '#'");
          if (!/^[a-zA-Z0-9_-]+$/.test(anchor)) throw new Error(`Unsupported $dynamicAnchor: ${anchor}`);
          safeSet(results, anchor, sub, "$dynamicAnchor");
        }
      });
      return results;
    }
    var hasKeywords = (schema, keywords) => traverse(schema, (s) => Object.keys(s).some((k) => keywords.includes(k)) || void 0) || false;
    var addSchemasArrayToMap = (schemas, input, optional = false) => {
      if (!Array.isArray(input)) throw new Error("Expected an array of schemas");
      for (const schema of input) {
        traverse(schema, (sub) => {
          const idRaw = sub.$id || sub.id;
          const id = idRaw && typeof idRaw === "string" ? idRaw.replace(/#$/, "") : null;
          if (id && id.includes("://") && !id.includes("#")) {
            safeSet(schemas, id, sub, "schema $id in 'schemas'");
          } else if (sub === schema && !optional) {
            throw new Error("Schema with missing or invalid $id in 'schemas'");
          }
        });
      }
      return schemas;
    };
    var buildSchemas = (input, extra) => {
      if (extra) return addSchemasArrayToMap(buildSchemas(input), extra, true);
      if (input) {
        switch (Object.getPrototypeOf(input)) {
          case Object.prototype:
            return new Map(Object.entries(input));
          case Map.prototype:
            return new Map(input);
          case Array.prototype:
            return addSchemasArrayToMap(/* @__PURE__ */ new Map(), input);
        }
      }
      throw new Error("Unexpected value for 'schemas' option");
    };
    module.exports = { get, joinPath, resolveReference, getDynamicAnchors, hasKeywords, buildSchemas };
  }
});

// node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/formats.js
var require_formats = __commonJS({
  "node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/formats.js"(exports, module) {
    "use strict";
    var core = {
      // matches ajv + length checks + does not start with a dot
      // note that quoted emails are deliberately unsupported (as in ajv), who would want \x01 in email
      // first check is an additional fast path with lengths: 20+(1+21)*2 = 64, (1+61+1)+((1+60+1)+1)*3 = 252 < 253, that should cover most valid emails
      // max length is 64 (name) + 1 (@) + 253 (host), we want to ensure that prior to feeding to the fast regex
      // the second regex checks for quoted, starting-leading dot in name, and two dots anywhere
      email: (input) => {
        if (input.length > 318) return false;
        const fast = /^[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,20}(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,21}){0,2}@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,60}[a-z0-9])?){0,3}$/i;
        if (fast.test(input)) return true;
        if (!input.includes("@") || /(^\.|^"|\.@|\.\.)/.test(input)) return false;
        const [name, host, ...rest] = input.split("@");
        if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) return false;
        if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name)) return false;
        return host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));
      },
      // matches ajv + length checks
      hostname: (input) => {
        if (input.length > (input.endsWith(".") ? 254 : 253)) return false;
        const hostname = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*\.?$/i;
        return hostname.test(input);
      },
      // 'time' matches ajv + length checks, 'date' matches ajv full
      // date: https://tools.ietf.org/html/rfc3339#section-5.6
      // date-time: https://tools.ietf.org/html/rfc3339#section-5.6
      // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
      // 11: 1990-01-01, 1: T, 9: 00:00:00., 12: maxiumum fraction length (non-standard), 6: +00:00
      date: (input) => {
        if (input.length !== 10) return false;
        if (input[5] === "0" && input[6] === "2") {
          if (/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)$/.test(input)) return true;
          const matches = input.match(/^(\d\d\d\d)-02-29$/);
          if (!matches) return false;
          const year = matches[1] | 0;
          return year % 16 === 0 || year % 4 === 0 && year % 25 !== 0;
        }
        if (input.endsWith("31")) return /^\d\d\d\d-(?:0[13578]|1[02])-31$/.test(input);
        return /^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)$/.test(input);
      },
      // leap second handling is special, we check it's 23:59:60.*
      time: (input) => {
        if (input.length > 9 + 12 + 6) return false;
        const time = /^(?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)?$/i;
        if (!time.test(input)) return false;
        if (!/:60/.test(input)) return true;
        const p = input.match(/([0-9.]+|[^0-9.])/g);
        let hm = Number(p[0]) * 60 + Number(p[2]);
        if (p[5] === "+") hm += 24 * 60 - Number(p[6] || 0) * 60 - Number(p[8] || 0);
        else if (p[5] === "-") hm += Number(p[6] || 0) * 60 + Number(p[8] || 0);
        return hm % (24 * 60) === 23 * 60 + 59;
      },
      // first two lines specific to date-time, then tests for unanchored (at end) date, code identical to 'date' above
      // input[17] === '6' is a check for :60
      "date-time": (input) => {
        if (input.length > 10 + 1 + 9 + 12 + 6) return false;
        const full = /^\d\d\d\d-(?:0[1-9]|1[0-2])-(?:[0-2]\d|3[01])[t\s](?:2[0-3]|[0-1]\d):[0-5]\d:(?:[0-5]\d|60)(?:\.\d+)?(?:z|[+-](?:2[0-3]|[0-1]\d)(?::?[0-5]\d)?)$/i;
        const feb = input[5] === "0" && input[6] === "2";
        if (feb && input[8] === "3" || !full.test(input)) return false;
        if (input[17] === "6") {
          const p = input.slice(11).match(/([0-9.]+|[^0-9.])/g);
          let hm = Number(p[0]) * 60 + Number(p[2]);
          if (p[5] === "+") hm += 24 * 60 - Number(p[6] || 0) * 60 - Number(p[8] || 0);
          else if (p[5] === "-") hm += Number(p[6] || 0) * 60 + Number(p[8] || 0);
          if (hm % (24 * 60) !== 23 * 60 + 59) return false;
        }
        if (feb) {
          if (/^\d\d\d\d-02-(?:[012][1-8]|[12]0|[01]9)/.test(input)) return true;
          const matches = input.match(/^(\d\d\d\d)-02-29/);
          if (!matches) return false;
          const year = matches[1] | 0;
          return year % 16 === 0 || year % 4 === 0 && year % 25 !== 0;
        }
        if (input[8] === "3" && input[9] === "1") return /^\d\d\d\d-(?:0[13578]|1[02])-31/.test(input);
        return /^\d\d\d\d-(?:0[13-9]|1[012])-(?:[012][1-9]|[123]0)/.test(input);
      },
      /* ipv4 and ipv6 are from ajv with length restriction */
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: (ip) => ip.length <= 15 && /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)$/.test(ip),
      // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
      // max length: 1000:1000:1000:1000:1000:1000:255.255.255.255
      // we parse ip6 format with a simple scan, leaving embedded ipv4 validation to a regex
      // s0=count(:), s1=count(.), hex=count(a-zA-Z0-9), short=count(::)>0
      // 48-57: '0'-'9', 97-102, 65-70: 'a'-'f', 'A'-'F', 58: ':', 46: '.'
      /* eslint-disable one-var */
      // prettier-ignore
      ipv6: (input) => {
        if (input.length > 45 || input.length < 2) return false;
        let s0 = 0, s1 = 0, hex = 0, short = false, letters = false, last = 0, start = true;
        for (let i = 0; i < input.length; i++) {
          const c = input.charCodeAt(i);
          if (i === 1 && last === 58 && c !== 58) return false;
          if (c >= 48 && c <= 57) {
            if (++hex > 4) return false;
          } else if (c === 46) {
            if (s0 > 6 || s1 >= 3 || hex === 0 || letters) return false;
            s1++;
            hex = 0;
          } else if (c === 58) {
            if (s1 > 0 || s0 >= 7) return false;
            if (last === 58) {
              if (short) return false;
              short = true;
            } else if (i === 0) start = false;
            s0++;
            hex = 0;
            letters = false;
          } else if (c >= 97 && c <= 102 || c >= 65 && c <= 70) {
            if (s1 > 0) return false;
            if (++hex > 4) return false;
            letters = true;
          } else return false;
          last = c;
        }
        if (s0 < 2 || s1 > 0 && (s1 !== 3 || hex === 0)) return false;
        if (short && input.length === 2) return true;
        if (s1 > 0 && !/(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}$/.test(input)) return false;
        const spaces = s1 > 0 ? 6 : 7;
        if (!short) return s0 === spaces && start && hex > 0;
        return (start || hex > 0) && s0 < spaces;
      },
      /* eslint-enable one-var */
      // matches ajv with optimization
      uri: /^[a-z][a-z0-9+\-.]*:(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // matches ajv with optimization
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/?(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?)?(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // ajv has /^(([^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?([a-z0-9_]|%[0-9a-f]{2})+(:[1-9][0-9]{0,3}|\*)?(,([a-z0-9_]|%[0-9a-f]{2})+(:[1-9][0-9]{0,3}|\*)?)*\})*$/i
      // this is equivalent
      // uri-template: https://tools.ietf.org/html/rfc6570
      // eslint-disable-next-line no-control-regex
      "uri-template": /^(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2}|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // ajv has /^(\/([^~/]|~0|~1)*)*$/, this is equivalent
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      "json-pointer": /^(?:|\/(?:[^~]|~0|~1)*)$/,
      // ajv has /^(0|[1-9][0-9]*)(#|(\/([^~/]|~0|~1)*)*)$/, this is equivalent
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:|#|\/(?:[^~]|~0|~1)*)$/,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,
      // length restriction is an arbitrary safeguard
      // first regex checks if this a week duration (can't be combined with others)
      // second regex verifies symbols, no more than one fraction, at least 1 block is present, and T is not last
      // third regex verifies structure
      duration: (input) => input.length > 1 && input.length < 80 && (/^P\d+([.,]\d+)?W$/.test(input) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(input) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(input))
      // TODO: iri, iri-reference, idn-email, idn-hostname
    };
    var extra = {
      // basic
      alpha: /^[a-zA-Z]+$/,
      alphanumeric: /^[a-zA-Z0-9]+$/,
      // hex
      "hex-digits": /^[0-9a-f]+$/i,
      "hex-digits-prefixed": /^0x[0-9a-f]+$/i,
      "hex-bytes": /^([0-9a-f][0-9a-f])+$/i,
      "hex-bytes-prefixed": /^0x([0-9a-f][0-9a-f])+$/i,
      base64: (input) => input.length % 4 === 0 && /^[a-z0-9+/]*={0,3}$/i.test(input),
      // ajv has /^#(\/([a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, this is equivalent
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer-uri-fragment": /^#(|\/(\/|[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)$/i,
      // draft3 backwards compat
      "host-name": core.hostname,
      "ip-address": core.ipv4,
      // manually cleaned up from is-my-json-valid, CSS 2.1 colors only per draft03 spec
      color: /^(#[0-9A-Fa-f]{3,6}|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|rgb\(\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*,\s*([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\s*\)|rgb\(\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*,\s*(\d?\d%|100%)\s*\))$/
      // style is deliberately unsupported, don't accept untrusted styles
    };
    var weak = {
      // In weak because don't accept regexes from untrusted sources, using them can cause DoS
      // matches ajv + length checks
      // eslint comment outside because we don't want comments in functions, those affect output
      /* eslint-disable no-new */
      regex: (str) => {
        if (str.length > 1e5) return false;
        const Z_ANCHOR = /[^\\]\\Z/;
        if (Z_ANCHOR.test(str)) return false;
        try {
          new RegExp(str, "u");
          return true;
        } catch (e) {
          return false;
        }
      }
      /* eslint-enable no-new */
    };
    module.exports = { core, extra, weak };
  }
});

// node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/tracing.js
var require_tracing = __commonJS({
  "node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/tracing.js"(exports, module) {
    "use strict";
    var merge = (a, b) => [.../* @__PURE__ */ new Set([...a, ...b])].sort();
    var intersect = (a, b) => a.filter((x) => b.includes(x));
    var wrapArgs = (f) => (...args) => f(...args.map(normalize));
    var wrapFull = (f) => (...args) => normalize(f(...args.map(normalize)));
    var typeIsNot = (type, t) => type && !type.includes(t);
    var normalize = ({ type = null, dyn: d = {}, ...A }) => ({
      type: type ? [...type].sort() : type,
      items: typeIsNot(type, "array") ? Infinity : A.items || 0,
      properties: typeIsNot(type, "object") ? [true] : [...A.properties || []].sort(),
      patterns: typeIsNot(type, "object") ? [] : [...A.patterns || []].sort(),
      required: typeIsNot(type, "object") ? [] : [...A.required || []].sort(),
      fullstring: typeIsNot(type, "string") || A.fullstring || false,
      dyn: {
        item: typeIsNot(type, "array") ? false : d.item || false,
        items: typeIsNot(type, "array") ? 0 : Math.max(A.items || 0, d.items || 0),
        properties: typeIsNot(type, "object") ? [] : merge(A.properties || [], d.properties || []),
        patterns: typeIsNot(type, "object") ? [] : merge(A.patterns || [], d.patterns || [])
      },
      unknown: A.unknown && !(typeIsNot(type, "object") && typeIsNot(type, "array")) || false
    });
    var initTracing = () => normalize({});
    var andDelta = wrapFull((A, B) => ({
      type: A.type && B.type ? intersect(A.type, B.type) : A.type || B.type || null,
      items: Math.max(A.items, B.items),
      properties: merge(A.properties, B.properties),
      patterns: merge(A.patterns, B.patterns),
      required: merge(A.required, B.required),
      fullstring: A.fullstring || B.fullstring,
      dyn: {
        item: A.dyn.item || B.dyn.item,
        items: Math.max(A.dyn.items, B.dyn.items),
        properties: merge(A.dyn.properties, B.dyn.properties),
        patterns: merge(A.dyn.patterns, B.dyn.patterns)
      },
      unknown: A.unknown || B.unknown
    }));
    var regtest = (pattern, value) => value !== true && new RegExp(pattern, "u").test(value);
    var intersectProps = ({ properties: a, patterns: rega }, { properties: b, patterns: regb }) => {
      const af = a.filter((x) => b.includes(x) || b.includes(true) || regb.some((p) => regtest(p, x)));
      const bf = b.filter((x) => a.includes(x) || a.includes(true) || rega.some((p) => regtest(p, x)));
      const ar = rega.filter((x) => regb.includes(x) || b.includes(true));
      const br = regb.filter((x) => rega.includes(x) || a.includes(true));
      return { properties: merge(af, bf), patterns: merge(ar, br) };
    };
    var inProperties = ({ properties: a, patterns: rega }, { properties: b, patterns: regb }) => b.every((x) => a.includes(x) || a.includes(true) || rega.some((p) => regtest(p, x))) && regb.every((x) => rega.includes(x) || a.includes(true));
    var orDelta = wrapFull((A, B) => ({
      type: A.type && B.type ? merge(A.type, B.type) : null,
      items: Math.min(A.items, B.items),
      ...intersectProps(A, B),
      required: typeIsNot(A.type, "object") && B.required || typeIsNot(B.type, "object") && A.required || intersect(A.required, B.required),
      fullstring: A.fullstring && B.fullstring,
      dyn: {
        item: A.dyn.item || B.dyn.item,
        items: Math.max(A.dyn.items, B.dyn.items),
        properties: merge(A.dyn.properties, B.dyn.properties),
        patterns: merge(A.dyn.patterns, B.dyn.patterns)
      },
      unknown: A.unknown || B.unknown
    }));
    var applyDelta = (stat, delta) => Object.assign(stat, andDelta(stat, delta));
    var isDynamic = wrapArgs(({ unknown, items, dyn, ...stat }) => ({
      items: items !== Infinity && (unknown || dyn.items > items || dyn.item),
      properties: !stat.properties.includes(true) && (unknown || !inProperties(stat, dyn))
    }));
    module.exports = { initTracing, andDelta, orDelta, applyDelta, isDynamic, inProperties };
  }
});

// node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/compile.js
var require_compile = __commonJS({
  "node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/compile.js"(exports, module) {
    "use strict";
    var { format, safe, safeand, safenot, safenotor } = require_safe_format();
    var genfun = require_generate_function();
    var { resolveReference, joinPath, getDynamicAnchors, hasKeywords } = require_pointer();
    var formats = require_formats();
    var { toPointer, ...functions } = require_scope_functions();
    var { scopeMethods } = require_scope_utils();
    var { buildName, types, jsHelpers } = require_javascript();
    var { knownKeywords, schemaVersions, knownVocabularies } = require_known_keywords();
    var { initTracing, andDelta, orDelta, applyDelta, isDynamic, inProperties } = require_tracing();
    var noopRegExps = /* @__PURE__ */ new Set(["^[\\s\\S]*$", "^[\\S\\s]*$", "^[^]*$", "", ".*", "^", "$"]);
    var primitiveTypes = ["null", "boolean", "number", "integer", "string"];
    var schemaTypes = new Map(
      Object.entries({
        boolean: (arg) => typeof arg === "boolean",
        array: (arg) => Array.isArray(arg) && Object.getPrototypeOf(arg) === Array.prototype,
        object: (arg) => arg && Object.getPrototypeOf(arg) === Object.prototype,
        finite: (arg) => Number.isFinite(arg),
        natural: (arg) => Number.isInteger(arg) && arg >= 0,
        string: (arg) => typeof arg === "string",
        jsonval: (arg) => functions.deepEqual(arg, JSON.parse(JSON.stringify(arg)))
      })
    );
    var isPlainObject = schemaTypes.get("object");
    var isSchemaish = (arg) => isPlainObject(arg) || typeof arg === "boolean";
    var deltaEmpty = (delta) => functions.deepEqual(delta, { type: [] });
    var schemaIsOlderThan = ($schema2, ver) => schemaVersions.indexOf($schema2) > schemaVersions.indexOf(`https://json-schema.org/${ver}/schema`);
    var schemaIsUnkownOrOlder = ($schema2, ver) => {
      const normalized = `${$schema2}`.replace(/^http:\/\//, "https://").replace(/#$/, "");
      if (!schemaVersions.includes(normalized)) return true;
      return schemaIsOlderThan(normalized, ver);
    };
    var propvar = (parent, keyname, inKeys = false, number = false) => Object.freeze({ parent, keyname, inKeys, number });
    var propimm = (parent, keyval, checked = false) => Object.freeze({ parent, keyval, checked });
    var evaluatedStatic = Symbol("evaluatedStatic");
    var optDynamic = Symbol("optDynamic");
    var optDynAnchors = Symbol("optDynAnchors");
    var optRecAnchors = Symbol("optRecAnchors");
    var constantValue = (schema) => {
      if (typeof schema === "boolean") return schema;
      if (isPlainObject(schema) && Object.keys(schema).length === 0) return true;
      return void 0;
    };
    var refsNeedFullValidation = /* @__PURE__ */ new Set();
    var rootMeta = /* @__PURE__ */ new Map();
    var generateMeta = (root, $schema2, enforce, requireSchema) => {
      if ($schema2) {
        const version = $schema2.replace(/^http:\/\//, "https://").replace(/#$/, "");
        enforce(schemaVersions.includes(version), "Unexpected schema version:", version);
        rootMeta.set(root, {
          exclusiveRefs: schemaIsOlderThan(version, "draft/2019-09"),
          contentValidation: schemaIsOlderThan(version, "draft/2019-09"),
          dependentUnsupported: schemaIsOlderThan(version, "draft/2019-09"),
          newItemsSyntax: !schemaIsOlderThan(version, "draft/2020-12"),
          containsEvaluates: !schemaIsOlderThan(version, "draft/2020-12"),
          objectContains: !schemaIsOlderThan(version, "draft/next"),
          bookending: schemaIsOlderThan(version, "draft/next")
        });
      } else {
        enforce(!requireSchema, "[requireSchema] $schema is required");
        rootMeta.set(root, {});
      }
    };
    var compileSchema = (schema, root, opts, scope, basePathRoot = "") => {
      const {
        mode = "default",
        useDefaults = false,
        removeAdditional = false,
        // supports additionalProperties: false and additionalItems: false
        includeErrors = false,
        allErrors = false,
        contentValidation,
        dryRun,
        // unused, just for rest siblings
        lint: lintOnly = false,
        allowUnusedKeywords = opts.mode === "lax" || opts.mode === "spec",
        allowUnreachable = opts.mode === "lax" || opts.mode === "spec",
        requireSchema = opts.mode === "strong",
        requireValidation = opts.mode === "strong",
        requireStringValidation = opts.mode === "strong",
        forbidNoopValues = opts.mode === "strong",
        // e.g. $recursiveAnchor: false (it's false by default)
        complexityChecks = opts.mode === "strong",
        unmodifiedPrototypes = false,
        // assumes no mangled Object/Array prototypes
        isJSON = false,
        // assume input to be JSON, which e.g. makes undefined impossible
        $schemaDefault = null,
        formatAssertion = opts.mode !== "spec" || schemaIsUnkownOrOlder(root.$schema, "draft/2019-09"),
        formats: optFormats = {},
        weakFormats = opts.mode !== "strong",
        extraFormats = false,
        schemas,
        // always a Map, produced at wrapper
        ...unknown
      } = opts;
      const fmts = {
        ...formats.core,
        ...weakFormats ? formats.weak : {},
        ...extraFormats ? formats.extra : {},
        ...optFormats
      };
      if (Object.keys(unknown).length !== 0)
        throw new Error(`Unknown options: ${Object.keys(unknown).join(", ")}`);
      if (!["strong", "lax", "default", "spec"].includes(mode)) throw new Error(`Invalid mode: ${mode}`);
      if (!includeErrors && allErrors) throw new Error("allErrors requires includeErrors to be enabled");
      if (requireSchema && $schemaDefault) throw new Error("requireSchema forbids $schemaDefault");
      if (mode === "strong") {
        const validation = { requireValidation, requireStringValidation };
        const strong = { ...validation, formatAssertion, complexityChecks, requireSchema };
        const weak = { weakFormats, allowUnusedKeywords };
        for (const [k, v] of Object.entries(strong)) if (!v) throw new Error(`Strong mode demands ${k}`);
        for (const [k, v] of Object.entries(weak)) if (v) throw new Error(`Strong mode forbids ${k}`);
      }
      const { gensym, getref, genref, genformat } = scopeMethods(scope);
      const buildPath = (prop) => {
        const path = [];
        let curr = prop;
        while (curr) {
          if (!curr.name) path.unshift(curr);
          curr = curr.parent || curr.errorParent;
        }
        if (path.every((part) => part.keyval !== void 0))
          return format("%j", toPointer(path.map((part) => part.keyval)));
        const stringParts = ["#"];
        const stringJoined = () => {
          const value = stringParts.map(functions.pointerPart).join("/");
          stringParts.length = 0;
          return value;
        };
        let res = null;
        for (const { keyname, keyval, number } of path) {
          if (keyname) {
            if (!number) scope.pointerPart = functions.pointerPart;
            const value = number ? keyname : format("pointerPart(%s)", keyname);
            const str = `${stringJoined()}/`;
            res = res ? format("%s+%j+%s", res, str, value) : format("%j+%s", str, value);
          } else if (keyval) stringParts.push(keyval);
        }
        return stringParts.length > 0 ? format("%s+%j", res, `/${stringJoined()}`) : res;
      };
      const funname = genref(schema);
      let validate7 = null;
      const wrap = (...args) => {
        const res = validate7(...args);
        wrap.errors = validate7.errors;
        return res;
      };
      scope[funname] = wrap;
      const hasRefs = hasKeywords(schema, ["$ref", "$recursiveRef", "$dynamicRef"]);
      const hasDynAnchors = opts[optDynAnchors] && hasRefs && hasKeywords(schema, ["$dynamicAnchor"]);
      const dynAnchorsHead = () => {
        if (!opts[optDynAnchors]) return format("");
        return hasDynAnchors ? format(", dynAnchors = []") : format(", dynAnchors");
      };
      const recAnchorsHead = opts[optRecAnchors] ? format(", recursive") : format("");
      const fun = genfun();
      fun.write("function validate(data%s%s) {", recAnchorsHead, dynAnchorsHead());
      if (includeErrors) fun.write("validate.errors = null");
      if (allErrors) fun.write("let errorCount = 0");
      if (opts[optDynamic]) fun.write("validate.evaluatedDynamic = null");
      let dynamicAnchorsNext = opts[optDynAnchors] ? format(", dynAnchors") : format("");
      if (hasDynAnchors) {
        fun.write("const dynLocal = [{}]");
        dynamicAnchorsNext = format(", [...dynAnchors, dynLocal[0] || []]");
      }
      const helpers = jsHelpers(fun, scope, propvar, { unmodifiedPrototypes, isJSON }, noopRegExps);
      const { present, forObjectKeys, forArray, patternTest, compare } = helpers;
      const recursiveLog = [];
      const getMeta = () => rootMeta.get(root);
      const basePathStack = basePathRoot ? [basePathRoot] : [];
      const visit = (errors, history, current, node, schemaPath, trace = {}, { constProp } = {}) => {
        const isSub = history.length > 0 && history[history.length - 1].prop === current;
        const queryCurrent = () => history.filter((h) => h.prop === current);
        const definitelyPresent = !current.parent || current.checked || current.inKeys && isJSON || queryCurrent().length > 0;
        const name = buildName(current);
        const currPropImm = (...args) => propimm(current, ...args);
        const error = ({ path = [], prop = current, source, suberr }) => {
          const schemaP = toPointer([...schemaPath, ...path]);
          const dataP = includeErrors ? buildPath(prop) : null;
          if (includeErrors === true && errors && source) {
            scope.errorMerge = functions.errorMerge;
            const args = [source, schemaP, dataP];
            if (allErrors) {
              fun.write("if (validate.errors === null) validate.errors = []");
              fun.write("validate.errors.push(...%s.map(e => errorMerge(e, %j, %s)))", ...args);
            } else fun.write("validate.errors = [errorMerge(%s[0], %j, %s)]", ...args);
          } else if (includeErrors === true && errors) {
            const errorJS = format("{ keywordLocation: %j, instanceLocation: %s }", schemaP, dataP);
            if (allErrors) {
              fun.write("if (%s === null) %s = []", errors, errors);
              fun.write("%s.push(%s)", errors, errorJS);
            } else fun.write("%s = [%s]", errors, errorJS);
          }
          if (suberr) mergeerror(suberr);
          if (allErrors) fun.write("errorCount++");
          else fun.write("return false");
        };
        const errorIf = (condition, errorArgs) => fun.if(condition, () => error(errorArgs));
        if (lintOnly && !scope.lintErrors) scope.lintErrors = [];
        const fail = (msg, value) => {
          const comment = value !== void 0 ? ` ${JSON.stringify(value)}` : "";
          const keywordLocation = joinPath(basePathRoot, toPointer(schemaPath));
          const message = `${msg}${comment} at ${keywordLocation}`;
          if (lintOnly) return scope.lintErrors.push({ message, keywordLocation, schema });
          throw new Error(message);
        };
        const patternTestSafe = (pat, key) => {
          try {
            return patternTest(pat, key);
          } catch (e) {
            fail(e.message);
            return format("false");
          }
        };
        const enforce = (ok, ...args) => ok || fail(...args);
        const laxMode = (ok, ...args) => enforce(mode === "lax" || mode === "spec" || ok, ...args);
        const enforceMinMax = (a, b) => laxMode(!(node[b] < node[a]), `Invalid ${a} / ${b} combination`);
        const enforceValidation = (msg, suffix = "should be specified") => enforce(!requireValidation, `[requireValidation] ${msg} ${suffix}`);
        const subPath = (...args) => [...schemaPath, ...args];
        const uncertain = (msg) => enforce(!removeAdditional && !useDefaults, `[removeAdditional/useDefaults] uncertain: ${msg}`);
        const complex = (msg, arg) => enforce(!complexityChecks, `[complexityChecks] ${msg}`, arg);
        const saveMeta = ($sch) => generateMeta(root, $sch || $schemaDefault, enforce, requireSchema);
        const stat2 = initTracing();
        const evaluateDelta = (delta) => applyDelta(stat2, delta);
        if (typeof node === "boolean") {
          if (node === true) {
            enforceValidation("schema = true", "is not allowed");
            return { stat: stat2 };
          }
          errorIf(definitelyPresent || current.inKeys ? true : present(current), {});
          evaluateDelta({ type: [] });
          return { stat: stat2 };
        }
        enforce(isPlainObject(node), "Schema is not an object");
        for (const key of Object.keys(node))
          enforce(knownKeywords.includes(key) || allowUnusedKeywords, "Keyword not supported:", key);
        if (Object.keys(node).length === 0) {
          enforceValidation("empty rules node", "is not allowed");
          return { stat: stat2 };
        }
        const unused = new Set(Object.keys(node));
        const multiConsumable = /* @__PURE__ */ new Set();
        const consume = (prop, ...ruleTypes) => {
          enforce(multiConsumable.has(prop) || unused.has(prop), "Unexpected double consumption:", prop);
          enforce(functions.hasOwn(node, prop), "Is not an own property:", prop);
          enforce(ruleTypes.every((t) => schemaTypes.has(t)), "Invalid type used in consume");
          enforce(ruleTypes.some((t) => schemaTypes.get(t)(node[prop])), "Unexpected type for", prop);
          unused.delete(prop);
        };
        const get = (prop, ...ruleTypes) => {
          if (node[prop] !== void 0) consume(prop, ...ruleTypes);
          return node[prop];
        };
        const handle = (prop, ruleTypes, handler, errorArgs = {}) => {
          if (node[prop] === void 0) return false;
          consume(prop, ...ruleTypes);
          if (handler !== null) {
            try {
              const condition = handler(node[prop]);
              if (condition !== null) errorIf(condition, { path: [prop], ...errorArgs });
            } catch (e) {
              if (lintOnly && !e.message.startsWith("[opt] ")) {
                fail(e.message);
              } else {
                throw e;
              }
            }
          }
          return true;
        };
        if (node === root) {
          saveMeta(get("$schema", "string"));
          handle("$vocabulary", ["object"], ($vocabulary) => {
            for (const [vocab, flag] of Object.entries($vocabulary)) {
              if (flag === false) continue;
              enforce(flag === true && knownVocabularies.includes(vocab), "Unknown vocabulary:", vocab);
            }
            return null;
          });
        } else if (!getMeta()) saveMeta(root.$schema);
        if (getMeta().objectContains) {
          for (const prop of ["contains", "minContains", "maxContains"]) multiConsumable.add(prop);
        }
        handle("examples", ["array"], null);
        handle("example", ["jsonval"], null);
        for (const ignore of ["title", "description", "$comment"]) handle(ignore, ["string"], null);
        for (const ignore of ["deprecated", "readOnly", "writeOnly"]) handle(ignore, ["boolean"], null);
        handle("$defs", ["object"], null) || handle("definitions", ["object"], null);
        const compileSub = (sub, subR, path) => sub === schema ? safe("validate") : getref(sub) || compileSchema(sub, subR, opts, scope, path);
        const basePath = () => basePathStack.length > 0 ? basePathStack[basePathStack.length - 1] : "";
        const basePathStackLength = basePathStack.length;
        const setId = ($id) => {
          basePathStack.push(joinPath(basePath(), $id));
          return null;
        };
        if (!getMeta().exclusiveRefs || !node.$ref) {
          handle("$id", ["string"], setId) || handle("id", ["string"], setId);
          handle("$anchor", ["string"], null);
          handle("$dynamicAnchor", ["string"], null);
          if (node.$recursiveAnchor || !forbidNoopValues) {
            handle("$recursiveAnchor", ["boolean"], (isRecursive) => {
              if (isRecursive) recursiveLog.push([node, root, basePath()]);
              return null;
            });
          }
        }
        const isDynScope = hasDynAnchors && (node === schema || node.id || node.$id);
        if (isDynScope) {
          const allDynamic = getDynamicAnchors(node);
          if (node !== schema) fun.write("dynLocal.unshift({})");
          for (const [key, subcheck] of allDynamic) {
            const resolved = resolveReference(root, schemas, `#${key}`, basePath());
            const [sub, subRoot, path] = resolved[0] || [];
            enforce(sub === subcheck, `Unexpected $dynamicAnchor resolution: ${key}`);
            const n = compileSub(sub, subRoot, path);
            fun.write("dynLocal[0][%j] = %s", `#${key}`, n);
          }
        }
        const needUnevaluated = (rule2) => opts[optDynamic] && (node[rule2] || node[rule2] === false || node === schema);
        const local2 = Object.freeze({
          item: needUnevaluated("unevaluatedItems") ? gensym("evaluatedItem") : null,
          items: needUnevaluated("unevaluatedItems") ? gensym("evaluatedItems") : null,
          props: needUnevaluated("unevaluatedProperties") ? gensym("evaluatedProps") : null
        });
        const dyn = Object.freeze({
          item: local2.item || trace.item,
          items: local2.items || trace.items,
          props: local2.props || trace.props
        });
        const canSkipDynamic = () => (!dyn.items || stat2.items === Infinity) && (!dyn.props || stat2.properties.includes(true));
        const evaluateDeltaDynamic = (delta) => {
          if (dyn.item && delta.item && stat2.items !== Infinity)
            fun.write("%s.push(%s)", dyn.item, delta.item);
          if (dyn.items && delta.items > stat2.items) fun.write("%s.push(%d)", dyn.items, delta.items);
          if (dyn.props && (delta.properties || []).includes(true) && !stat2.properties.includes(true)) {
            fun.write("%s[0].push(true)", dyn.props);
          } else if (dyn.props) {
            const inStat = (properties2, patterns2) => inProperties(stat2, { properties: properties2, patterns: patterns2 });
            const properties = (delta.properties || []).filter((x) => !inStat([x], []));
            const patterns = (delta.patterns || []).filter((x) => !inStat([], [x]));
            if (properties.length > 0) fun.write("%s[0].push(...%j)", dyn.props, properties);
            if (patterns.length > 0) fun.write("%s[1].push(...%j)", dyn.props, patterns);
            for (const sym of delta.propertiesVars || []) fun.write("%s[0].push(%s)", dyn.props, sym);
          }
        };
        const applyDynamicToDynamic = (target, item, items, props) => {
          if (isDynamic(stat2).items && target.item && item)
            fun.write("%s.push(...%s)", target.item, item);
          if (isDynamic(stat2).items && target.items && items)
            fun.write("%s.push(...%s)", target.items, items);
          if (isDynamic(stat2).properties && target.props && props) {
            fun.write("%s[0].push(...%s[0])", target.props, props);
            fun.write("%s[1].push(...%s[1])", target.props, props);
          }
        };
        const makeRecursive = () => {
          if (!opts[optRecAnchors]) return format("");
          if (recursiveLog.length === 0) return format(", recursive");
          return format(", recursive || %s", compileSub(...recursiveLog[0]));
        };
        const applyRef = (n, errorArgs) => {
          const delta = scope[n] && scope[n][evaluatedStatic] || { unknown: true };
          evaluateDelta(delta);
          const call = format("%s(%s%s%s)", n, name, makeRecursive(), dynamicAnchorsNext);
          if (!includeErrors && canSkipDynamic()) return format("!%s", call);
          const res = gensym("res");
          const err = gensym("err");
          const suberr = gensym("suberr");
          if (includeErrors) fun.write("const %s = validate.errors", err);
          fun.write("const %s = %s", res, call);
          if (includeErrors) fun.write("const %s = %s.errors", suberr, n);
          if (includeErrors) fun.write("validate.errors = %s", err);
          errorIf(safenot(res), { ...errorArgs, source: suberr });
          fun.if(res, () => {
            const item = isDynamic(delta).items ? format("%s.evaluatedDynamic[0]", n) : null;
            const items = isDynamic(delta).items ? format("%s.evaluatedDynamic[1]", n) : null;
            const props = isDynamic(delta).properties ? format("%s.evaluatedDynamic[2]", n) : null;
            applyDynamicToDynamic(dyn, item, items, props);
          });
          return null;
        };
        const allIn = (arr, valid) => arr && arr.every((s) => valid.includes(s));
        const someIn = (arr, possible) => possible.some((x) => arr === null || arr.includes(x));
        const parentCheckedType = (...valid) => queryCurrent().some((h) => allIn(h.stat.type, valid));
        const definitelyType = (...valid) => allIn(stat2.type, valid) || parentCheckedType(...valid);
        const typeApplicable = (...possible) => someIn(stat2.type, possible) && queryCurrent().every((h) => someIn(h.stat.type, possible));
        const enforceRegex = (source, target = node) => {
          enforce(typeof source === "string", "Invalid pattern:", source);
          if (requireValidation || requireStringValidation)
            enforce(/^\^.*\$$/.test(source), "Should start with ^ and end with $:", source);
          if (/([{+*].*[{+*]|\)[{+*]|^[^^].*[{+*].)/.test(source) && target.maxLength === void 0)
            complex("maxLength should be specified for pattern:", source);
        };
        const havePattern = node.pattern && !noopRegExps.has(node.pattern);
        const haveComplex = node.uniqueItems || havePattern || node.patternProperties || node.format;
        const prev = allErrors && haveComplex ? gensym("prev") : null;
        const prevWrap = (shouldWrap, writeBody) => fun.if(shouldWrap && prev !== null ? format("errorCount === %s", prev) : true, writeBody);
        const nexthistory = () => [...history, { stat: stat2, prop: current }];
        const rule = (...args) => visit(errors, nexthistory(), ...args).stat;
        const subrule = (suberr, ...args) => {
          if (args[0] === current) {
            const constval = constantValue(args[1]);
            if (constval === true) return { sub: format("true"), delta: {} };
            if (constval === false) return { sub: format("false"), delta: { type: [] } };
          }
          const sub = gensym("sub");
          fun.write("const %s = (() => {", sub);
          if (allErrors) fun.write("let errorCount = 0");
          const { stat: delta } = visit(suberr, nexthistory(), ...args);
          if (allErrors) {
            fun.write("return errorCount === 0");
          } else fun.write("return true");
          fun.write("})()");
          return { sub, delta };
        };
        const suberror = () => {
          const suberr = includeErrors && allErrors ? gensym("suberr") : null;
          if (suberr) fun.write("let %s = null", suberr);
          return suberr;
        };
        const mergeerror = (suberr) => {
          if (errors === null || suberr === null) return;
          fun.if(suberr, () => fun.write("%s.push(...%s)", errors, suberr));
        };
        const willRemoveAdditional = () => {
          if (!removeAdditional) return false;
          if (removeAdditional === true) return true;
          if (removeAdditional === "keyword") {
            if (!node.removeAdditional) return false;
            consume("removeAdditional", "boolean");
            return true;
          }
          throw new Error(`Invalid removeAdditional: ${removeAdditional}`);
        };
        const additionalItems = (rulePath, limit, extra) => {
          const handled = handle(rulePath, ["object", "boolean"], (ruleValue) => {
            if (ruleValue === false && willRemoveAdditional()) {
              fun.write("if (%s.length > %s) %s.length = %s", name, limit, name, limit);
              return null;
            }
            if (ruleValue === false && !extra) return format("%s.length > %s", name, limit);
            forArray(current, limit, (prop, i) => {
              if (extra) fun.write("if (%s) continue", extra(i));
              return rule(prop, ruleValue, subPath(rulePath));
            });
            return null;
          });
          if (handled) evaluateDelta({ items: Infinity });
        };
        const additionalProperties = (rulePath, condition) => {
          const handled = handle(rulePath, ["object", "boolean"], (ruleValue) => {
            forObjectKeys(current, (sub, key) => {
              fun.if(condition(key), () => {
                if (ruleValue === false && willRemoveAdditional()) fun.write("delete %s[%s]", name, key);
                else rule(sub, ruleValue, subPath(rulePath));
              });
            });
            return null;
          });
          if (handled) evaluateDelta({ properties: [true] });
        };
        const additionalCondition = (key, properties, patternProperties) => safeand(
          ...properties.map((p) => format("%s !== %j", key, p)),
          ...patternProperties.map((p) => safenot(patternTestSafe(p, key)))
        );
        const lintRequired = (properties, patterns) => {
          const regexps = patterns.map((p) => new RegExp(p, "u"));
          const known = (key) => properties.includes(key) || regexps.some((r) => r.test(key));
          for (const key of stat2.required) enforce(known(key), `Unknown required property:`, key);
        };
        const finalLint = [];
        const checkNumbers = () => {
          const minMax = (value, operator) => format("!(%d %c %s)", value, operator, name);
          if (Number.isFinite(node.exclusiveMinimum)) {
            handle("exclusiveMinimum", ["finite"], (min) => minMax(min, "<"));
          } else {
            handle("minimum", ["finite"], (min) => minMax(min, node.exclusiveMinimum ? "<" : "<="));
            handle("exclusiveMinimum", ["boolean"], null);
          }
          if (Number.isFinite(node.exclusiveMaximum)) {
            handle("exclusiveMaximum", ["finite"], (max) => minMax(max, ">"));
            enforceMinMax("minimum", "exclusiveMaximum");
            enforceMinMax("exclusiveMinimum", "exclusiveMaximum");
          } else if (node.maximum !== void 0) {
            handle("maximum", ["finite"], (max) => minMax(max, node.exclusiveMaximum ? ">" : ">="));
            handle("exclusiveMaximum", ["boolean"], null);
            enforceMinMax("minimum", "maximum");
            enforceMinMax("exclusiveMinimum", "maximum");
          }
          const multipleOf = node.multipleOf === void 0 ? "divisibleBy" : "multipleOf";
          handle(multipleOf, ["finite"], (value) => {
            enforce(value > 0, `Invalid ${multipleOf}:`, value);
            const [part, exp] = `${value}`.split("e-");
            const frac = `${part}.`.split(".")[1];
            const e = frac.length + (exp ? Number(exp) : 0);
            if (Number.isInteger(value * 2 ** e)) return format("%s %% %d !== 0", name, value);
            scope.isMultipleOf = functions.isMultipleOf;
            const args = [name, value, e, Math.round(value * Math.pow(10, e))];
            return format("!isMultipleOf(%s, %d, 1e%d, %d)", ...args);
          });
        };
        const checkStrings = () => {
          handle("maxLength", ["natural"], (max) => {
            scope.stringLength = functions.stringLength;
            return format("%s.length > %d && stringLength(%s) > %d", name, max, name, max);
          });
          handle("minLength", ["natural"], (min) => {
            scope.stringLength = functions.stringLength;
            return format("%s.length < %d || stringLength(%s) < %d", name, min, name, min);
          });
          enforceMinMax("minLength", "maxLength");
          prevWrap(true, () => {
            const checkFormat = (fmtname, target, formatsObj = fmts) => {
              const known = typeof fmtname === "string" && functions.hasOwn(formatsObj, fmtname);
              enforce(known, "Unrecognized format used:", fmtname);
              const formatImpl = formatsObj[fmtname];
              const valid = formatImpl instanceof RegExp || typeof formatImpl === "function";
              enforce(valid, "Invalid format used:", fmtname);
              if (!formatAssertion) return null;
              if (formatImpl instanceof RegExp) {
                if (functions.hasOwn(optFormats, fmtname)) enforceRegex(formatImpl.source);
                return format("!%s.test(%s)", genformat(formatImpl), target);
              }
              return format("!%s(%s)", genformat(formatImpl), target);
            };
            handle("format", ["string"], (value) => {
              evaluateDelta({ fullstring: true });
              return checkFormat(value, name);
            });
            handle("pattern", ["string"], (pattern) => {
              enforceRegex(pattern);
              evaluateDelta({ fullstring: true });
              return noopRegExps.has(pattern) ? null : safenot(patternTestSafe(pattern, name));
            });
            enforce(node.contentSchema !== false, "contentSchema cannot be set to false");
            const cV = contentValidation === void 0 ? getMeta().contentValidation : contentValidation;
            const haveContent = node.contentEncoding || node.contentMediaType || node.contentSchema;
            const contentErr = '"content*" keywords are disabled by default per spec, enable with { contentValidation = true } option (see doc/Options.md for more info)';
            enforce(!haveContent || cV || allowUnusedKeywords, contentErr);
            if (haveContent && cV) {
              const dec = gensym("dec");
              if (node.contentMediaType) fun.write("let %s = %s", dec, name);
              if (node.contentEncoding === "base64") {
                errorIf(checkFormat("base64", name, formats.extra), { path: ["contentEncoding"] });
                if (node.contentMediaType) {
                  scope.deBase64 = functions.deBase64;
                  fun.write("try {");
                  fun.write("%s = deBase64(%s)", dec, dec);
                }
                consume("contentEncoding", "string");
              } else enforce(!node.contentEncoding, "Unknown contentEncoding:", node.contentEncoding);
              let json = false;
              if (node.contentMediaType === "application/json") {
                fun.write("try {");
                fun.write("%s = JSON.parse(%s)", dec, dec);
                json = true;
                consume("contentMediaType", "string");
              } else enforce(!node.contentMediaType, "Unknown contentMediaType:", node.contentMediaType);
              if (node.contentSchema) {
                enforce(json, "contentSchema requires contentMediaType application/json");
                const decprop = Object.freeze({ name: dec, errorParent: current });
                rule(decprop, node.contentSchema, subPath("contentSchema"));
                consume("contentSchema", "object", "array");
                evaluateDelta({ fullstring: true });
              }
              if (node.contentMediaType) {
                fun.write("} catch (e) {");
                error({ path: ["contentMediaType"] });
                fun.write("}");
                if (node.contentEncoding) {
                  fun.write("} catch (e) {");
                  error({ path: ["contentEncoding"] });
                  fun.write("}");
                }
              }
            }
          });
        };
        const checkArrays = () => {
          handle("maxItems", ["natural"], (max) => {
            const prefixItemsName = getMeta().newItemsSyntax ? "prefixItems" : "items";
            if (Array.isArray(node[prefixItemsName]) && node[prefixItemsName].length > max)
              fail(`Invalid maxItems: ${max} is less than ${prefixItemsName} array length`);
            return format("%s.length > %d", name, max);
          });
          handle("minItems", ["natural"], (min) => format("%s.length < %d", name, min));
          enforceMinMax("minItems", "maxItems");
          const checkItemsArray = (items) => {
            for (let p = 0; p < items.length; p++) rule(currPropImm(p), items[p], subPath(`${p}`));
            evaluateDelta({ items: items.length });
            return null;
          };
          if (getMeta().newItemsSyntax) {
            handle("prefixItems", ["array"], checkItemsArray);
            additionalItems("items", format("%d", (node.prefixItems || []).length));
          } else if (Array.isArray(node.items)) {
            handle("items", ["array"], checkItemsArray);
            additionalItems("additionalItems", format("%d", node.items.length));
          } else {
            handle("items", ["object", "boolean"], (items) => {
              forArray(current, format("0"), (prop) => rule(prop, items, subPath("items")));
              evaluateDelta({ items: Infinity });
              return null;
            });
          }
          checkContains((run) => {
            forArray(current, format("0"), (prop, i) => {
              run(prop, () => {
                evaluateDelta({ dyn: { item: true } });
                evaluateDeltaDynamic({ item: i });
              });
            });
          });
          const itemsSimple = (ischema) => {
            if (!isPlainObject(ischema)) return false;
            if (ischema.enum || functions.hasOwn(ischema, "const")) return true;
            if (ischema.type) {
              const itemTypes = Array.isArray(ischema.type) ? ischema.type : [ischema.type];
              if (itemTypes.every((itemType) => primitiveTypes.includes(itemType))) return true;
            }
            if (ischema.$ref) {
              const [sub] = resolveReference(root, schemas, ischema.$ref, basePath())[0] || [];
              if (itemsSimple(sub)) return true;
            }
            return false;
          };
          const itemsSimpleOrFalse = (ischema) => ischema === false || itemsSimple(ischema);
          const uniqueSimple = () => {
            if (node.maxItems !== void 0 || itemsSimpleOrFalse(node.items)) return true;
            if (Array.isArray(node.items) && itemsSimpleOrFalse(node.additionalItems)) return true;
            return false;
          };
          prevWrap(true, () => {
            handle("uniqueItems", ["boolean"], (uniqueItems) => {
              if (uniqueItems === false) return null;
              if (!uniqueSimple()) complex("maxItems should be specified for non-primitive uniqueItems");
              Object.assign(scope, { unique: functions.unique, deepEqual: functions.deepEqual });
              return format("!unique(%s)", name);
            });
          });
        };
        const checked = (p) => !allErrors && (stat2.required.includes(p) || queryCurrent().some((h) => h.stat.required.includes(p)));
        const checkObjects = () => {
          const propertiesCount = format("Object.keys(%s).length", name);
          handle("maxProperties", ["natural"], (max) => format("%s > %d", propertiesCount, max));
          handle("minProperties", ["natural"], (min) => format("%s < %d", propertiesCount, min));
          enforceMinMax("minProperties", "maxProperties");
          handle("propertyNames", ["object", "boolean"], (s) => {
            forObjectKeys(current, (sub, key) => {
              const nameSchema = typeof s === "object" && !s.$ref ? { type: "string", ...s } : s;
              const nameprop = Object.freeze({ name: key, errorParent: sub, type: "string" });
              rule(nameprop, nameSchema, subPath("propertyNames"));
            });
            return null;
          });
          handle("required", ["array"], (required) => {
            for (const req of required) {
              if (checked(req)) continue;
              const prop = currPropImm(req);
              errorIf(safenot(present(prop)), { path: ["required"], prop });
            }
            evaluateDelta({ required });
            return null;
          });
          for (const dependencies of ["dependencies", "dependentRequired", "dependentSchemas"]) {
            if (dependencies !== "dependencies" && getMeta().dependentUnsupported) continue;
            handle(dependencies, ["object"], (value) => {
              for (const key of Object.keys(value)) {
                const deps = typeof value[key] === "string" ? [value[key]] : value[key];
                const item = currPropImm(key, checked(key));
                if (Array.isArray(deps) && dependencies !== "dependentSchemas") {
                  const clauses = deps.filter((k) => !checked(k)).map((k) => present(currPropImm(k)));
                  const condition = safenot(safeand(...clauses));
                  const errorArgs = { path: [dependencies, key] };
                  if (clauses.length === 0) {
                  } else if (item.checked) {
                    errorIf(condition, errorArgs);
                    evaluateDelta({ required: deps });
                  } else {
                    errorIf(safeand(present(item), condition), errorArgs);
                  }
                } else if (isSchemaish(deps) && dependencies !== "dependentRequired") {
                  uncertain(dependencies);
                  fun.if(item.checked ? true : present(item), () => {
                    const delta = rule(current, deps, subPath(dependencies, key), dyn);
                    evaluateDelta(orDelta({}, delta));
                    evaluateDeltaDynamic(delta);
                  });
                } else fail(`Unexpected ${dependencies} entry`);
              }
              return null;
            });
          }
          handle("propertyDependencies", ["object"], (propertyDependencies) => {
            for (const [key, variants] of Object.entries(propertyDependencies)) {
              enforce(isPlainObject(variants), "propertyDependencies must be an object");
              uncertain("propertyDependencies");
              const item = currPropImm(key, checked(key));
              fun.if(item.checked ? true : present(item), () => {
                for (const [val, deps] of Object.entries(variants)) {
                  enforce(isSchemaish(deps), "propertyDependencies must contain schemas");
                  fun.if(compare(buildName(item), val), () => {
                    const delta = rule(current, deps, subPath("propertyDependencies", key, val), dyn);
                    evaluateDelta(orDelta({}, delta));
                    evaluateDeltaDynamic(delta);
                  });
                }
              });
            }
            return null;
          });
          handle("properties", ["object"], (properties) => {
            for (const p of Object.keys(properties)) {
              if (constProp === p) continue;
              rule(currPropImm(p, checked(p)), properties[p], subPath("properties", p));
            }
            evaluateDelta({ properties: Object.keys(properties) });
            return null;
          });
          prevWrap(node.patternProperties, () => {
            handle("patternProperties", ["object"], (patternProperties) => {
              forObjectKeys(current, (sub, key) => {
                for (const p of Object.keys(patternProperties)) {
                  enforceRegex(p, node.propertyNames || {});
                  fun.if(patternTestSafe(p, key), () => {
                    rule(sub, patternProperties[p], subPath("patternProperties", p));
                  });
                }
              });
              evaluateDelta({ patterns: Object.keys(patternProperties) });
              return null;
            });
            if (node.additionalProperties || node.additionalProperties === false) {
              const properties = Object.keys(node.properties || {});
              const patternProperties = Object.keys(node.patternProperties || {});
              if (node.additionalProperties === false) {
                finalLint.push(() => lintRequired(properties, patternProperties));
              }
              const condition = (key) => additionalCondition(key, properties, patternProperties);
              additionalProperties("additionalProperties", condition);
            }
          });
          if (getMeta().objectContains) {
            checkContains((run) => {
              forObjectKeys(current, (prop, i) => {
                run(prop, () => {
                  evaluateDelta({ dyn: { properties: [true] } });
                  evaluateDeltaDynamic({ propertiesVars: [i] });
                });
              });
            });
          }
        };
        const checkConst = () => {
          const handledConst = handle("const", ["jsonval"], (val) => safenot(compare(name, val)));
          if (handledConst && !allowUnusedKeywords) return true;
          const handledEnum = handle("enum", ["array"], (vals) => {
            const objects = vals.filter((value) => value && typeof value === "object");
            const primitive = vals.filter((value) => !(value && typeof value === "object"));
            return safenotor(...[...primitive, ...objects].map((value) => compare(name, value)));
          });
          return handledConst || handledEnum;
        };
        const checkContains = (iterate) => {
          handle("contains", ["object", "boolean"], () => {
            uncertain("contains");
            if (getMeta().objectContains && typeApplicable("array") && typeApplicable("object")) {
              enforceValidation("possible type confusion in 'contains',", "forbid 'object' or 'array'");
            }
            const passes = gensym("passes");
            fun.write("let %s = 0", passes);
            const suberr = suberror();
            iterate((prop, evaluate) => {
              const { sub } = subrule(suberr, prop, node.contains, subPath("contains"));
              fun.if(sub, () => {
                fun.write("%s++", passes);
                if (getMeta().containsEvaluates) {
                  enforce(!removeAdditional, `Can't use removeAdditional with draft2020+ "contains"`);
                  evaluate();
                }
              });
            });
            if (!handle("minContains", ["natural"], (mn) => format("%s < %d", passes, mn), { suberr }))
              errorIf(format("%s < 1", passes), { path: ["contains"], suberr });
            handle("maxContains", ["natural"], (max) => format("%s > %d", passes, max));
            enforceMinMax("minContains", "maxContains");
            return null;
          });
        };
        const checkGeneric = () => {
          handle("not", ["object", "boolean"], (not) => subrule(null, current, not, subPath("not")).sub);
          if (node.not) uncertain("not");
          const thenOrElse = node.then || node.then === false || node.else || node.else === false;
          if (thenOrElse || allowUnusedKeywords)
            handle("if", ["object", "boolean"], (ifS) => {
              uncertain("if/then/else");
              const { sub, delta: deltaIf } = subrule(null, current, ifS, subPath("if"), dyn);
              let handleElse, handleThen, deltaElse, deltaThen;
              handle("else", ["object", "boolean"], (elseS) => {
                handleElse = () => {
                  deltaElse = rule(current, elseS, subPath("else"), dyn);
                  evaluateDeltaDynamic(deltaElse);
                };
                return null;
              });
              handle("then", ["object", "boolean"], (thenS) => {
                handleThen = () => {
                  deltaThen = rule(current, thenS, subPath("then"), dyn);
                  evaluateDeltaDynamic(andDelta(deltaIf, deltaThen));
                };
                return null;
              });
              if (!handleThen && !deltaEmpty(deltaIf)) handleThen = () => evaluateDeltaDynamic(deltaIf);
              fun.if(sub, handleThen, handleElse);
              evaluateDelta(orDelta(deltaElse || {}, andDelta(deltaIf, deltaThen || {})));
              return null;
            });
          const performAllOf = (allOf, rulePath = "allOf") => {
            enforce(allOf.length > 0, `${rulePath} cannot be empty`);
            for (const [key, sch] of Object.entries(allOf))
              evaluateDelta(rule(current, sch, subPath(rulePath, key), dyn));
            return null;
          };
          handle("allOf", ["array"], (allOf) => performAllOf(allOf));
          let handleDiscriminator = null;
          handle("discriminator", ["object"], (discriminator) => {
            const seen = /* @__PURE__ */ new Set();
            const fix = (check, message, arg) => enforce(check, `[discriminator]: ${message}`, arg);
            const { propertyName: pname, mapping: map, ...e0 } = discriminator;
            const prop = currPropImm(pname);
            fix(pname && !node.oneOf !== !node.anyOf, "need propertyName, oneOf OR anyOf");
            fix(Object.keys(e0).length === 0, 'only "propertyName" and "mapping" are supported');
            const keylen = (obj) => isPlainObject(obj) ? Object.keys(obj).length : null;
            handleDiscriminator = (branches, ruleName) => {
              const runDiscriminator = () => {
                fun.write("switch (%s) {", buildName(prop));
                let delta;
                for (const [i, branch] of Object.entries(branches)) {
                  const { const: myval, enum: myenum, ...e1 } = (branch.properties || {})[pname] || {};
                  let vals = myval !== void 0 ? [myval] : myenum;
                  if (!vals && branch.$ref) {
                    const [sub] = resolveReference(root, schemas, branch.$ref, basePath())[0] || [];
                    enforce(isPlainObject(sub), "failed to resolve $ref:", branch.$ref);
                    const rprop = (sub.properties || {})[pname] || {};
                    vals = rprop.const !== void 0 ? [rprop.const] : rprop.enum;
                  }
                  const ok1 = Array.isArray(vals) && vals.length > 0;
                  fix(ok1, "branches should have unique string const or enum values for [propertyName]");
                  const ok2 = Object.keys(e1).length === 0 && (!myval || !myenum);
                  fix(ok2, "only const OR enum rules are allowed on [propertyName] in branches");
                  for (const val of vals) {
                    const okMapping = !map || functions.hasOwn(map, val) && map[val] === branch.$ref;
                    fix(okMapping, "mismatching mapping for", val);
                    const valok = typeof val === "string" && !seen.has(val);
                    fix(valok, "const/enum values for [propertyName] should be unique strings");
                    seen.add(val);
                    fun.write("case %j:", val);
                  }
                  const subd = rule(current, branch, subPath(ruleName, i), dyn, { constProp: pname });
                  evaluateDeltaDynamic(subd);
                  delta = delta ? orDelta(delta, subd) : subd;
                  fun.write("break");
                }
                fix(map === void 0 || keylen(map) === seen.size, "mismatching mapping size");
                evaluateDelta(delta);
                fun.write("default:");
                error({ path: [ruleName] });
                fun.write("}");
              };
              const propCheck = () => {
                if (!checked(pname)) {
                  const errorPath = ["discriminator", "propertyName"];
                  fun.if(present(prop), runDiscriminator, () => error({ path: errorPath, prop }));
                } else runDiscriminator();
              };
              if (allErrors || !functions.deepEqual(stat2.type, ["object"])) {
                fun.if(types.get("object")(name), propCheck, () => error({ path: ["discriminator"] }));
              } else propCheck();
              fix(functions.deepEqual(stat2.type, ["object"]), "has to be checked for type:", "object");
              fix(stat2.required.includes(pname), "propertyName should be placed in required:", pname);
              return null;
            };
            return null;
          });
          const uncertainBranchTypes = (key, arr) => {
            const btypes = arr.map((x) => x.type || (Array.isArray(x.const) ? "array" : typeof x.const));
            const maybeObj = btypes.filter((x) => !primitiveTypes.includes(x) && x !== "array").length;
            const maybeArr = btypes.filter((x) => !primitiveTypes.includes(x) && x !== "object").length;
            if (maybeObj > 1 || maybeArr > 1) uncertain(`${key}, use discriminator to make it certain`);
          };
          handle("anyOf", ["array"], (anyOf) => {
            enforce(anyOf.length > 0, "anyOf cannot be empty");
            if (anyOf.length === 1) return performAllOf(anyOf);
            if (handleDiscriminator) return handleDiscriminator(anyOf, "anyOf");
            const suberr = suberror();
            if (!canSkipDynamic()) {
              uncertainBranchTypes("anyOf", anyOf);
              const entries = Object.entries(anyOf).map(
                ([key, sch]) => subrule(suberr, current, sch, subPath("anyOf", key), dyn)
              );
              evaluateDelta(entries.map((x) => x.delta).reduce((acc, cur) => orDelta(acc, cur)));
              errorIf(safenotor(...entries.map(({ sub }) => sub)), { path: ["anyOf"], suberr });
              for (const { delta: delta2, sub } of entries) fun.if(sub, () => evaluateDeltaDynamic(delta2));
              return null;
            }
            const constBlocks = anyOf.filter((x) => functions.hasOwn(x, "const"));
            const otherBlocks = anyOf.filter((x) => !functions.hasOwn(x, "const"));
            uncertainBranchTypes("anyOf", otherBlocks);
            const blocks = [...constBlocks, ...otherBlocks];
            let delta;
            if (!getMeta().exclusiveRefs) {
              const entries = Object.entries(anyOf).map(
                ([key, sch]) => subrule(suberr, current, sch, subPath("anyOf", key), dyn)
              );
              delta = entries.map((x) => x.delta).reduce((acc, cur) => orDelta(acc, cur));
              errorIf(safenotor(...entries.map(({ sub }) => sub)), { path: ["anyOf"], suberr });
            } else {
              let body = () => error({ path: ["anyOf"], suberr });
              for (const [key, sch] of Object.entries(blocks).reverse()) {
                const oldBody = body;
                body = () => {
                  const { sub, delta: deltaVar } = subrule(suberr, current, sch, subPath("anyOf", key));
                  fun.if(safenot(sub), oldBody);
                  delta = delta ? orDelta(delta, deltaVar) : deltaVar;
                };
              }
              body();
            }
            evaluateDelta(delta);
            return null;
          });
          handle("oneOf", ["array"], (oneOf) => {
            enforce(oneOf.length > 0, "oneOf cannot be empty");
            if (oneOf.length === 1) return performAllOf(oneOf);
            if (handleDiscriminator) return handleDiscriminator(oneOf, "oneOf");
            uncertainBranchTypes("oneOf", oneOf);
            const passes = gensym("passes");
            fun.write("let %s = 0", passes);
            const suberr = suberror();
            let delta;
            let i = 0;
            const entries = Object.entries(oneOf).map(([key, sch]) => {
              if (!includeErrors && i++ > 1) errorIf(format("%s > 1", passes), { path: ["oneOf"] });
              const entry = subrule(suberr, current, sch, subPath("oneOf", key), dyn);
              fun.if(entry.sub, () => fun.write("%s++", passes));
              delta = delta ? orDelta(delta, entry.delta) : entry.delta;
              return entry;
            });
            evaluateDelta(delta);
            errorIf(format("%s !== 1", passes), { path: ["oneOf"] });
            fun.if(format("%s === 0", passes), () => mergeerror(suberr));
            for (const entry of entries) fun.if(entry.sub, () => evaluateDeltaDynamic(entry.delta));
            return null;
          });
        };
        const typeWrap = (checkBlock, validTypes, queryType) => {
          const [funSize, unusedSize] = [fun.size(), unused.size];
          fun.if(definitelyType(...validTypes) ? true : queryType, checkBlock);
          if (funSize !== fun.size() || unusedSize !== unused.size)
            enforce(typeApplicable(...validTypes), `Unexpected rules in type`, node.type);
        };
        const checkArraysFinal = () => {
          if (stat2.items === Infinity) {
            if (node.unevaluatedItems === false) consume("unevaluatedItems", "boolean");
          } else if (node.unevaluatedItems || node.unevaluatedItems === false) {
            if (isDynamic(stat2).items) {
              if (!opts[optDynamic]) throw new Error("[opt] Dynamic unevaluated tracing not enabled");
              const limit = format("Math.max(%d, ...%s)", stat2.items, dyn.items);
              const extra = (i) => format("%s.includes(%s)", dyn.item, i);
              additionalItems("unevaluatedItems", limit, getMeta().containsEvaluates ? extra : null);
            } else {
              additionalItems("unevaluatedItems", format("%d", stat2.items));
            }
          }
        };
        const checkObjectsFinal = () => {
          prevWrap(stat2.patterns.length > 0 || stat2.dyn.patterns.length > 0 || stat2.unknown, () => {
            if (stat2.properties.includes(true)) {
              if (node.unevaluatedProperties === false) consume("unevaluatedProperties", "boolean");
            } else if (node.unevaluatedProperties || node.unevaluatedProperties === false) {
              const notStatic = (key) => additionalCondition(key, stat2.properties, stat2.patterns);
              if (isDynamic(stat2).properties) {
                if (!opts[optDynamic]) throw new Error("[opt] Dynamic unevaluated tracing not enabled");
                scope.propertyIn = functions.propertyIn;
                const notDynamic = (key) => format("!propertyIn(%s, %s)", key, dyn.props);
                const condition = (key) => safeand(notStatic(key), notDynamic(key));
                additionalProperties("unevaluatedProperties", condition);
              } else {
                if (node.unevaluatedProperties === false) lintRequired(stat2.properties, stat2.patterns);
                additionalProperties("unevaluatedProperties", notStatic);
              }
            }
          });
        };
        const performValidation = () => {
          if (prev !== null) fun.write("const %s = errorCount", prev);
          if (checkConst()) {
            const typeKeys = [...types.keys()];
            evaluateDelta({ properties: [true], items: Infinity, type: typeKeys, fullstring: true });
            if (!allowUnusedKeywords) {
              enforce(unused.size === 0, "Unexpected keywords mixed with const or enum:", [...unused]);
              return;
            }
          }
          typeWrap(checkNumbers, ["number", "integer"], types.get("number")(name));
          typeWrap(checkStrings, ["string"], types.get("string")(name));
          typeWrap(checkArrays, ["array"], types.get("array")(name));
          typeWrap(checkObjects, ["object"], types.get("object")(name));
          checkGeneric();
          typeWrap(checkArraysFinal, ["array"], types.get("array")(name));
          typeWrap(checkObjectsFinal, ["object"], types.get("object")(name));
          for (const lint of finalLint) lint();
          applyDynamicToDynamic(trace, local2.item, local2.items, local2.props);
        };
        const writeMain = () => {
          if (local2.item) fun.write("const %s = []", local2.item);
          if (local2.items) fun.write("const %s = [0]", local2.items);
          if (local2.props) fun.write("const %s = [[], []]", local2.props);
          handle("$ref", ["string"], ($ref) => {
            const resolved = resolveReference(root, schemas, $ref, basePath());
            const [sub, subRoot, path] = resolved[0] || [];
            if (!sub && sub !== false) {
              fail("failed to resolve $ref:", $ref);
              if (lintOnly) return null;
            }
            const n = compileSub(sub, subRoot, path);
            const rn = sub === schema ? funname : n;
            if (!scope[rn]) throw new Error("Unexpected: coherence check failed");
            if (!scope[rn][evaluatedStatic] && sub.type) {
              const type = Array.isArray(sub.type) ? sub.type : [sub.type];
              evaluateDelta({ type });
              if (requireValidation) {
                refsNeedFullValidation.add(rn);
                if (type.includes("array")) evaluateDelta({ items: Infinity });
                if (type.includes("object")) evaluateDelta({ properties: [true] });
              }
              if (requireStringValidation && type.includes("string")) {
                refsNeedFullValidation.add(rn);
                evaluateDelta({ fullstring: true });
              }
            }
            return applyRef(n, { path: ["$ref"] });
          });
          if (getMeta().exclusiveRefs) {
            enforce(!opts[optDynamic], "unevaluated* is supported only on draft2019-09 and above");
            if (node.$ref) return;
          }
          handle("$recursiveRef", ["string"], ($recursiveRef) => {
            if (!opts[optRecAnchors]) throw new Error("[opt] Recursive anchors are not enabled");
            enforce($recursiveRef === "#", 'Behavior of $recursiveRef is defined only for "#"');
            const resolved = resolveReference(root, schemas, "#", basePath());
            const [sub, subRoot, path] = resolved[0];
            laxMode(sub.$recursiveAnchor, "$recursiveRef without $recursiveAnchor");
            const n = compileSub(sub, subRoot, path);
            const nrec = sub.$recursiveAnchor ? format("(recursive || %s)", n) : n;
            return applyRef(nrec, { path: ["$recursiveRef"] });
          });
          handle("$dynamicRef", ["string"], ($dynamicRef) => {
            if (!opts[optDynAnchors]) throw new Error("[opt] Dynamic anchors are not enabled");
            laxMode(/^[^#]*#[a-zA-Z0-9_-]+$/.test($dynamicRef), "Unsupported $dynamicRef format");
            const dynamicTail = $dynamicRef.replace(/^[^#]+/, "");
            const resolved = resolveReference(root, schemas, $dynamicRef, basePath());
            if (!resolved[0] && !getMeta().bookending) {
              laxMode(false, "$dynamicRef bookending resolution failed (even though not required)");
              scope.dynamicResolve = functions.dynamicResolve;
              const nrec2 = format("dynamicResolve(dynAnchors || [], %j)", dynamicTail);
              return applyRef(nrec2, { path: ["$dynamicRef"] });
            }
            enforce(resolved[0], "$dynamicRef bookending resolution failed", $dynamicRef);
            const [sub, subRoot, path] = resolved[0];
            const ok = sub.$dynamicAnchor && `#${sub.$dynamicAnchor}` === dynamicTail;
            laxMode(ok, "$dynamicRef without $dynamicAnchor in the same scope");
            const n = compileSub(sub, subRoot, path);
            scope.dynamicResolve = functions.dynamicResolve;
            const nrec = ok ? format("(dynamicResolve(dynAnchors || [], %j) || %s)", dynamicTail, n) : n;
            return applyRef(nrec, { path: ["$dynamicRef"] });
          });
          let typeCheck = null;
          handle("type", ["string", "array"], (type) => {
            const typearr = Array.isArray(type) ? type : [type];
            for (const t of typearr) enforce(typeof t === "string" && types.has(t), "Unknown type:", t);
            if (current.type) {
              enforce(functions.deepEqual(typearr, [current.type]), "One type allowed:", current.type);
              evaluateDelta({ type: [current.type] });
              return null;
            }
            if (parentCheckedType(...typearr)) return null;
            const filteredTypes = typearr.filter((t) => typeApplicable(t));
            if (filteredTypes.length === 0) fail("No valid types possible");
            evaluateDelta({ type: typearr });
            typeCheck = safenotor(...filteredTypes.map((t) => types.get(t)(name)));
            return null;
          });
          if (typeCheck && allErrors) {
            fun.if(typeCheck, () => error({ path: ["type"] }), performValidation);
          } else {
            if (typeCheck) errorIf(typeCheck, { path: ["type"] });
            performValidation();
          }
          if (stat2.items < Infinity && node.maxItems <= stat2.items) evaluateDelta({ items: Infinity });
        };
        if (node.default !== void 0 && useDefaults) {
          if (definitelyPresent) fail("Can not apply default value here (e.g. at root)");
          const defvalue = get("default", "jsonval");
          fun.if(present(current), writeMain, () => fun.write("%s = %j", name, defvalue));
        } else {
          handle("default", ["jsonval"], null);
          fun.if(definitelyPresent ? true : present(current), writeMain);
        }
        basePathStack.length = basePathStackLength;
        if (recursiveLog[0] && recursiveLog[recursiveLog.length - 1][0] === node) recursiveLog.pop();
        if (isDynScope && node !== schema) fun.write("dynLocal.shift()");
        if (!allowUnreachable) enforce(!fun.optimizedOut, "some checks are never reachable");
        if (isSub) {
          const logicalOp = ["not", "if", "then", "else"].includes(schemaPath[schemaPath.length - 1]);
          const branchOp = ["oneOf", "anyOf", "allOf"].includes(schemaPath[schemaPath.length - 2]);
          const depOp = ["dependencies", "dependentSchemas"].includes(schemaPath[schemaPath.length - 2]);
          const propDepOp = ["propertyDependencies"].includes(schemaPath[schemaPath.length - 3]);
          enforce(logicalOp || branchOp || depOp || propDepOp, "Unexpected logical path");
        } else if (!schemaPath.includes("not")) {
          const isRefTop = schema !== root && node === schema;
          if (!isRefTop || refsNeedFullValidation.has(funname)) {
            refsNeedFullValidation.delete(funname);
            if (!stat2.type) enforceValidation("type");
            if (typeApplicable("array") && stat2.items !== Infinity)
              enforceValidation(node.items ? "additionalItems or unevaluatedItems" : "items rule");
            if (typeApplicable("object") && !stat2.properties.includes(true))
              enforceValidation("additionalProperties or unevaluatedProperties");
            if (!stat2.fullstring && requireStringValidation) {
              const stringWarning = "pattern, format or contentSchema should be specified for strings";
              fail(`[requireStringValidation] ${stringWarning}, use pattern: ^[\\s\\S]*$ to opt-out`);
            }
          }
          if (typeof node.propertyNames !== "object") {
            for (const sub of ["additionalProperties", "unevaluatedProperties"])
              if (node[sub]) enforceValidation(`wild-card ${sub}`, "requires propertyNames");
          }
        }
        if (node.properties && !node.required) enforceValidation("if properties is used, required");
        enforce(unused.size === 0 || allowUnusedKeywords, "Unprocessed keywords:", [...unused]);
        return { stat: stat2, local: local2 };
      };
      const { stat, local } = visit(format("validate.errors"), [], { name: safe("data") }, schema, []);
      if (refsNeedFullValidation.has(funname)) throw new Error("Unexpected: unvalidated cyclic ref");
      if (opts[optDynamic] && (isDynamic(stat).items || isDynamic(stat).properties)) {
        if (!local) throw new Error("Failed to trace dynamic properties");
        fun.write("validate.evaluatedDynamic = [%s, %s, %s]", local.item, local.items, local.props);
      }
      if (allErrors) fun.write("return errorCount === 0");
      else fun.write("return true");
      fun.write("}");
      if (!lintOnly) {
        validate7 = fun.makeFunction(scope);
        delete scope[funname];
        scope[funname] = validate7;
      }
      scope[funname][evaluatedStatic] = stat;
      return funname;
    };
    var compile = (schemas, opts) => {
      if (!Array.isArray(schemas)) throw new Error("Expected an array of schemas");
      try {
        const scope = /* @__PURE__ */ Object.create(null);
        const { getref } = scopeMethods(scope);
        refsNeedFullValidation.clear();
        rootMeta.clear();
        const refs = schemas.map((s) => getref(s) || compileSchema(s, s, opts, scope));
        if (refsNeedFullValidation.size !== 0) throw new Error("Unexpected: not all refs are validated");
        return { scope, refs };
      } catch (e) {
        if (!opts[optDynamic] && e.message === "[opt] Dynamic unevaluated tracing not enabled")
          return compile(schemas, { ...opts, [optDynamic]: true });
        if (!opts[optDynAnchors] && e.message === "[opt] Dynamic anchors are not enabled")
          return compile(schemas, { ...opts, [optDynAnchors]: true });
        if (!opts[optRecAnchors] && e.message === "[opt] Recursive anchors are not enabled")
          return compile(schemas, { ...opts, [optRecAnchors]: true });
        throw e;
      } finally {
        refsNeedFullValidation.clear();
        rootMeta.clear();
      }
    };
    module.exports = { compile };
  }
});

// node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/@exodus+schemasafe@1.3.0/node_modules/@exodus/schemasafe/src/index.js"(exports, module) {
    "use strict";
    var genfun = require_generate_function();
    var { buildSchemas } = require_pointer();
    var { compile } = require_compile();
    var { deepEqual } = require_scope_functions();
    var jsonCheckWithErrors = (validate7) => function validateIsJSON(data) {
      if (!deepEqual(data, JSON.parse(JSON.stringify(data)))) {
        validateIsJSON.errors = [{ instanceLocation: "#", error: "not JSON compatible" }];
        return false;
      }
      const res = validate7(data);
      validateIsJSON.errors = validate7.errors;
      return res;
    };
    var jsonCheckWithoutErrors = (validate7) => (data) => deepEqual(data, JSON.parse(JSON.stringify(data))) && validate7(data);
    var validator2 = (schema, { parse = false, multi = false, jsonCheck = false, isJSON = false, schemas = [], ...opts } = {}) => {
      if (jsonCheck && isJSON) throw new Error("Can not specify both isJSON and jsonCheck options");
      if (parse && (jsonCheck || isJSON))
        throw new Error("jsonCheck and isJSON options are not applicable in parser mode");
      const mode = parse ? "strong" : "default";
      const willJSON = isJSON || jsonCheck || parse;
      const arg = multi ? schema : [schema];
      const options = { mode, ...opts, schemas: buildSchemas(schemas, arg), isJSON: willJSON };
      const { scope, refs } = compile(arg, options);
      if (opts.dryRun) return;
      if (opts.lint) return scope.lintErrors;
      const fun = genfun();
      if (parse) {
        scope.parseWrap = opts.includeErrors ? parseWithErrors : parseWithoutErrors;
      } else if (jsonCheck) {
        scope.deepEqual = deepEqual;
        scope.jsonCheckWrap = opts.includeErrors ? jsonCheckWithErrors : jsonCheckWithoutErrors;
      }
      if (multi) {
        fun.write("[");
        for (const ref of refs.slice(0, -1)) fun.write("%s,", ref);
        if (refs.length > 0) fun.write("%s", refs[refs.length - 1]);
        fun.write("]");
        if (parse) fun.write(".map(parseWrap)");
        else if (jsonCheck) fun.write(".map(jsonCheckWrap)");
      } else {
        if (parse) fun.write("parseWrap(%s)", refs[0]);
        else if (jsonCheck) fun.write("jsonCheckWrap(%s)", refs[0]);
        else fun.write("%s", refs[0]);
      }
      const validate7 = fun.makeFunction(scope);
      validate7.toModule = ({ semi = true } = {}) => fun.makeModule(scope) + (semi ? ";" : "");
      validate7.toJSON = () => schema;
      return validate7;
    };
    var parseWithErrors = (validate7) => (src) => {
      if (typeof src !== "string") return { valid: false, error: "Input is not a string" };
      try {
        const value = JSON.parse(src);
        if (!validate7(value)) {
          const { keywordLocation, instanceLocation } = validate7.errors[0];
          const keyword = keywordLocation.slice(keywordLocation.lastIndexOf("/") + 1);
          const error = `JSON validation failed for ${keyword} at ${instanceLocation}`;
          return { valid: false, error, errors: validate7.errors };
        }
        return { valid: true, value };
      } catch ({ message }) {
        return { valid: false, error: message };
      }
    };
    var parseWithoutErrors = (validate7) => (src) => {
      if (typeof src !== "string") return { valid: false };
      try {
        const value = JSON.parse(src);
        if (!validate7(value)) return { valid: false };
        return { valid: true, value };
      } catch (e) {
        return { valid: false };
      }
    };
    var parser = function(schema, { parse = true, ...opts } = {}) {
      if (!parse) throw new Error("can not disable parse in parser");
      return validator2(schema, { parse, ...opts });
    };
    var lint = function(schema, { lint: lintOption = true, ...opts } = {}) {
      if (!lintOption) throw new Error("can not disable lint option in lint()");
      return validator2(schema, { lint: lintOption, ...opts });
    };
    module.exports = { validator: validator2, parser, lint };
  }
});

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/memoize.js
var import_memoize_weak = __toESM(require_memoize_weak(), 1);
var memoize = import_memoize_weak.default;

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/arktype.js
async function modules() {
  const { type } = await import(
    /* webpackIgnore: true */
    "./api-Z6A3VNES.js"
  );
  return { type };
}
var fetchModule = memoize(modules);
async function _validate(schema, data) {
  const { type } = await fetchModule();
  const result = schema(data);
  if (!(result instanceof type.errors)) {
    return {
      data: result,
      success: true
    };
  }
  const issues = [];
  for (const error of result) {
    issues.push({ message: error.message, path: error.path });
  }
  return {
    issues,
    success: false
  };
}
function _arktype(schema, options) {
  return createAdapter({
    superFormValidationLibrary: "arktype",
    defaults: options.defaults,
    jsonSchema: createJsonSchema(options),
    validate: async (data) => _validate(schema, data)
  });
}
function _arktypeClient(schema) {
  return {
    superFormValidationLibrary: "arktype",
    validate: async (data) => _validate(schema, data)
  };
}
var arktype = memoize(_arktype);
var arktypeClient = memoize(_arktypeClient);

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/joi-to-json-schema/index.js
function assert(condition, errorMessage) {
  if (!condition)
    throw new Error(errorMessage);
}
var TYPES = {
  alternatives: (schema, joi2, transformer) => {
    const result = schema.oneOf = [];
    joi2.matches.forEach(function(match) {
      if (match.schema) {
        return result.push(convert(match.schema, transformer));
      }
      if (!match.is) {
        throw new Error('joi.when requires an "is"');
      }
      if (!(match.then || match.otherwise)) {
        throw new Error('joi.when requires one or both of "then" and "otherwise"');
      }
      if (match.then) {
        result.push(convert(match.then, transformer));
      }
      if (match.otherwise) {
        result.push(convert(match.otherwise, transformer));
      }
    });
    return schema;
  },
  date: (schema) => {
    schema.type = "Date";
    return schema;
  },
  any: (schema) => {
    delete schema.type;
    return schema;
  },
  array: (schema, joi2, transformer) => {
    var _a;
    schema.type = "array";
    (_a = joi2._rules) == null ? void 0 : _a.forEach((test) => {
      switch (test.name) {
        case "unique":
          schema.uniqueItems = true;
          break;
        case "length":
          schema.minItems = schema.maxItems = test.args.limit;
          break;
        case "min":
          schema.minItems = test.args.limit;
          break;
        case "max":
          schema.maxItems = test.args.limit;
          break;
      }
    });
    if (joi2.$_terms) {
      let list;
      if (joi2.$_terms._inclusions.length) {
        list = joi2.$_terms._inclusions;
      } else if (joi2.$_terms._requireds.length) {
        list = joi2.$_terms._requireds;
      }
      if (list) {
        schema.items = convert(list[0], transformer);
      }
    }
    return schema;
  },
  binary: (schema, joi2) => {
    schema.type = "string";
    schema.contentMediaType = joi2._meta.length > 0 && joi2._meta[0].contentMediaType ? joi2._meta[0].contentMediaType : "text/plain";
    schema.contentEncoding = joi2._flags.encoding ? joi2._flags.encoding : "binary";
    return schema;
  },
  boolean: (schema) => {
    schema.type = "boolean";
    return schema;
  },
  number: (schema, joi2) => {
    var _a;
    schema.type = "number";
    (_a = joi2._rules) == null ? void 0 : _a.forEach((test) => {
      switch (test.name) {
        case "integer":
          schema.type = "integer";
          break;
        case "less":
          schema.exclusiveMaximum = test.args.limit;
          break;
        case "greater":
          schema.exclusiveMinimum = test.args.limit;
          break;
        case "min":
          schema.minimum = test.args.limit;
          break;
        case "max":
          schema.maximum = test.args.limit;
          break;
        case "precision": {
          let multipleOf;
          if (test.args.limit && test.args.limit > 1) {
            multipleOf = JSON.parse("0." + "0".repeat(test.args.limit - 1) + "1");
          } else {
            multipleOf = 1;
          }
          schema.multipleOf = multipleOf;
          break;
        }
      }
    });
    return schema;
  },
  string: (schema, joi2) => {
    schema.type = "string";
    joi2._rules.forEach((test) => {
      switch (test.name) {
        case "email":
          schema.format = "email";
          break;
        case "pattern":
        case "regex": {
          const arg = test.args;
          const pattern = arg && arg.regex ? arg.regex : arg;
          schema.pattern = String(pattern).replace(/^\//, "").replace(/\/$/, "");
          break;
        }
        case "min":
          schema.minLength = test.args.limit;
          break;
        case "max":
          schema.maxLength = test.args.limit;
          break;
        case "length":
          schema.minLength = schema.maxLength = test.args.limit;
          break;
        case "uri":
          schema.format = "uri";
          break;
      }
    });
    return schema;
  },
  object: (schema, joi2, transformer) => {
    var _a, _b;
    schema.type = "object";
    schema.properties = {};
    schema.additionalProperties = Boolean(joi2._flags.allowUnknown || !joi2._inner.children);
    schema.pattern = // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ((_a = joi2.patterns) == null ? void 0 : _a.map((pattern) => {
      return { regex: pattern.regex, rule: convert(pattern.rule, transformer) };
    })) ?? [];
    if (!((_b = joi2.$_terms.keys) == null ? void 0 : _b.length)) {
      return schema;
    }
    joi2.$_terms.keys.forEach((property) => {
      if (property.schema._flags.presence !== "forbidden") {
        if (!schema.properties)
          schema.properties = {};
        schema.properties[property.key] = convert(property.schema, transformer);
        if (property.schema._flags.presence === "required" || property.schema._settings && property.schema._settings.presence === "required" && property.schema._flags.presence !== "optional") {
          schema.required = schema.required || [];
          schema.required.push(property.key);
        }
      }
    });
    return schema;
  }
};
function convert(joi2, transformer) {
  var _a;
  assert("object" === typeof joi2 && "type" in joi2, "requires a joi schema object");
  if (!TYPES[joi2.type]) {
    throw new Error(`sorry, do not know how to convert unknown joi type: "${joi2.type}"`);
  }
  if (transformer) {
    assert("function" === typeof transformer, "transformer must be a function");
  }
  const schema = {};
  if (joi2._description) {
    schema.description = joi2._description;
  }
  if (joi2._examples && joi2._examples.length > 0) {
    schema.examples = joi2._examples.map((e) => e.value);
  }
  if (joi2._examples && joi2._examples.length === 1) {
    schema.examples = joi2._examples[0].value;
  }
  if (joi2._settings && joi2._settings.language && joi2._settings.language.label) {
    schema.title = joi2._settings.language.label;
  } else if (joi2._flags && joi2._flags.label) {
    schema.title = joi2._flags.label;
  }
  if (joi2._flags && joi2._flags.default !== void 0 && joi2._flags.default !== null) {
    schema["default"] = joi2._flags.default;
  }
  if (joi2._valids && joi2._valids._set && (joi2._valids._set.size || joi2._valids._set.length)) {
    if (Array.isArray(joi2.children) || !joi2._flags.allowOnly) {
      return {
        anyOf: [
          {
            type: joi2.type,
            enum: [...joi2._valids._set]
          },
          TYPES[joi2.type](schema, joi2, transformer)
        ]
      };
    }
    schema["enum"] = [...joi2._valids._set];
  }
  let result = TYPES[joi2.type](schema, joi2, transformer);
  if (transformer) {
    result = transformer(result, joi2);
  }
  if (((_a = joi2._valids) == null ? void 0 : _a._values) && joi2._valids._values.size && !joi2._flags.allowOnly) {
    const constants = Array.from(joi2._valids._values).map((v) => ({
      const: v
    }));
    if (result.anyOf) {
      result.anyOf = [...constants, ...result.anyOf];
    } else {
      result = { anyOf: [...constants, result] };
    }
  }
  return result;
}
convert.TYPES = TYPES;

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/joi.js
async function validate(schema, data) {
  const result = schema.validate(data, { abortEarly: false });
  if (result.error == null) {
    return {
      data: result.value,
      success: true
    };
  }
  return {
    issues: result.error.details.map(({ message, path }) => ({
      message,
      path
    })),
    success: false
  };
}
function _joi(schema, options) {
  return createAdapter({
    superFormValidationLibrary: "joi",
    jsonSchema: (options == null ? void 0 : options.jsonSchema) ?? convert(schema),
    defaults: options == null ? void 0 : options.defaults,
    validate: async (data) => validate(schema, data)
  });
}
function _joiClient(schema) {
  return {
    superFormValidationLibrary: "joi",
    validate: async (data) => validate(schema, data)
  };
}
var joi = memoize(_joi);
var joiClient = memoize(_joiClient);

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/superform.js
function _superform(schema) {
  return {
    superFormValidationLibrary: "superform",
    async validate(data) {
      if (!data || typeof data !== "object")
        data = {};
      else
        data = { ...data };
      const newData = data;
      for (const [key, value] of Object.entries(schema)) {
        if (typeof value === "function" && !(key in newData)) {
          newData[key] = void 0;
        }
      }
      const output = [];
      function mapErrors(path, errors2) {
        if (!errors2)
          return;
        if (typeof errors2 === "string")
          errors2 = [errors2];
        errors2.forEach((message) => {
          output.push({
            path,
            message
          });
        });
      }
      const queue = [];
      traversePaths(newData, async ({ value, path }) => {
        const validationPath = path.filter((p) => /\D/.test(String(p)));
        const maybeValidator = traversePath(schema, validationPath);
        if (typeof (maybeValidator == null ? void 0 : maybeValidator.value) === "function") {
          const check = maybeValidator.value;
          queue.push({ path, errors: check(value) });
        }
      });
      const errors = await Promise.all(queue.map((check) => check.errors));
      for (let i = 0; i < errors.length; i++) {
        mapErrors(queue[i].path, errors[i]);
      }
      return output.length ? {
        success: false,
        issues: output
      } : {
        success: true,
        data
      };
    }
  };
}
var superformClient = memoize(_superform);

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/typebox.js
var Email = /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;
async function modules2() {
  const { TypeCompiler } = await import(
    /* webpackIgnore: true */
    "./compiler-542JHQG4.js"
  );
  const { FormatRegistry } = await import(
    /* webpackIgnore: true */
    "./esm-CF73LAJE.js"
  );
  return { TypeCompiler, FormatRegistry };
}
var fetchModule2 = memoize(modules2);
async function validate2(schema, data) {
  const { TypeCompiler, FormatRegistry } = await fetchModule2();
  if (!compiled.has(schema)) {
    compiled.set(schema, TypeCompiler.Compile(schema));
  }
  if (!FormatRegistry.Has("email")) {
    FormatRegistry.Set("email", (value) => Email.test(value));
  }
  const validator2 = compiled.get(schema);
  const errors = [...(validator2 == null ? void 0 : validator2.Errors(data)) ?? []];
  if (!errors.length) {
    return { success: true, data };
  }
  return {
    success: false,
    issues: errors.map((issue) => ({
      path: issue.path.substring(1).split("/"),
      message: issue.message
    }))
  };
}
function _typebox(schema) {
  return createAdapter({
    superFormValidationLibrary: "typebox",
    validate: async (data) => validate2(schema, data),
    jsonSchema: schema
  });
}
function _typeboxClient(schema) {
  return {
    superFormValidationLibrary: "typebox",
    validate: async (data) => validate2(schema, data)
  };
}
var typebox = memoize(_typebox);
var typeboxClient = memoize(_typeboxClient);
var compiled = /* @__PURE__ */ new WeakMap();

// node_modules/.pnpm/valibot@0.31.1/node_modules/valibot/dist/index.js
var store;
function getGlobalConfig(config2) {
  return {
    lang: (config2 == null ? void 0 : config2.lang) ?? (store == null ? void 0 : store.lang),
    message: config2 == null ? void 0 : config2.message,
    abortEarly: (config2 == null ? void 0 : config2.abortEarly) ?? (store == null ? void 0 : store.abortEarly),
    abortPipeEarly: (config2 == null ? void 0 : config2.abortPipeEarly) ?? (store == null ? void 0 : store.abortPipeEarly),
    skipPipe: config2 == null ? void 0 : config2.skipPipe
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2 == null ? void 0 : store2.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3 == null ? void 0 : store3.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  var _a;
  return (_a = store4 == null ? void 0 : store4.get(reference)) == null ? void 0 : _a.get(lang);
}
function _stringify(input) {
  var _a, _b;
  let type = typeof input;
  if (type === "object") {
    type = (input && ((_b = (_a = Object.getPrototypeOf(input)) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name)) ?? "null";
  }
  return type === "string" ? `"${input}"` : type === "number" || type === "bigint" || type === "boolean" ? `${input}` : type;
}
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = (other == null ? void 0 : other.expected) ?? context.expects;
  const received = (other == null ? void 0 : other.received) ?? _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    // @ts-expect-error
    requirement: context.requirement,
    path: other == null ? void 0 : other.path,
    issues: other == null ? void 0 : other.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly,
    skipPipe: config2.skipPipe
  };
  const isSchema = context.kind === "schema";
  const message = (
    // @ts-expect-error
    context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang)
  );
  if (message) {
    issue.message = typeof message === "function" ? message(issue) : message;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
function getDefault(schema, dataset, config2) {
  return typeof schema.default === "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
function never(message) {
  return {
    kind: "schema",
    type: "never",
    reference: never,
    expects: "never",
    async: false,
    message,
    _run(dataset, config2) {
      _addIssue(this, "type", dataset, config2);
      return dataset;
    }
  };
}
async function safeParseAsync(schema, input, config2) {
  const dataset = await schema._run(
    { typed: false, value: input },
    getGlobalConfig(config2)
  );
  return {
    typed: dataset.typed,
    success: !dataset.issues,
    output: dataset.value,
    issues: dataset.issues
  };
}

// node_modules/.pnpm/@gcornut+valibot-json-schema@0.31.0/node_modules/@gcornut/valibot-json-schema/dist/index.mjs
var JSON_SCHEMA_FEATURES_KEY = "__json_schema_features";
function getJSONSchemaFeatures(schema) {
  return schema[JSON_SCHEMA_FEATURES_KEY];
}
function assignExtraJSONSchemaFeatures(schema, converted) {
  const jsonSchemaFeatures = getJSONSchemaFeatures(schema);
  if (jsonSchemaFeatures) {
    Object.assign(converted, jsonSchemaFeatures);
  }
}
function assert2(value, predicate, message) {
  if (!predicate(value)) throw new Error(message.replace("%", String(value)));
  return value;
}
var $schema = "http://json-schema.org/draft-07/schema#";
function isJSONLiteral(value) {
  return typeof value === "number" && !Number.isNaN(value) || typeof value === "string" || typeof value === "boolean" || value === null;
}
var assertJSONLiteral = (v) => assert2(v, isJSONLiteral, "Unsupported literal value type: %");
function isEqual(obj1, obj2) {
  if (obj1 === obj2) return true;
  if (typeof obj1 === "object" && typeof obj2 === "object") {
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length) return false;
    return keys1.every((key1) => isEqual(obj1[key1], obj2[key1]));
  }
  return false;
}
function isSchemaType(type) {
  return (schema) => {
    return !!schema && schema.type === type;
  };
}
var isNullishSchema = isSchemaType("nullish");
var isOptionalSchema = isSchemaType("optional");
var isStringSchema = isSchemaType("string");
var isNeverSchema = isSchemaType("never");
var toDefinitionURI = (name) => `#/definitions/${name}`;
var SCHEMA_CONVERTERS = {
  any: () => ({}),
  // Core types
  null: () => ({ const: null }),
  literal: ({ literal }) => ({ const: assertJSONLiteral(literal) }),
  number: () => ({ type: "number" }),
  string: () => ({ type: "string" }),
  boolean: () => ({ type: "boolean" }),
  // Compositions
  optional: (schema, convert2) => {
    const output = convert2(schema.wrapped);
    const defaultValue = getDefault(schema);
    if (defaultValue !== void 0) output.default = defaultValue;
    return output;
  },
  nullish: (schema, convert2) => {
    const output = { anyOf: [{ const: null }, convert2(schema.wrapped)] };
    const defaultValue = getDefault(schema);
    if (defaultValue !== void 0) output.default = defaultValue;
    return output;
  },
  nullable: (schema, convert2) => {
    const output = { anyOf: [{ const: null }, convert2(schema.wrapped)] };
    const defaultValue = getDefault(schema);
    if (defaultValue !== void 0) output.default = defaultValue;
    return output;
  },
  picklist: ({ options }) => ({ enum: options.map(assertJSONLiteral) }),
  enum: (options) => ({ enum: Object.values(options.enum).map(assertJSONLiteral) }),
  union: ({ options }, convert2) => ({ anyOf: options.map(convert2) }),
  intersect: ({ options }, convert2) => ({ allOf: options.map(convert2) }),
  // Complex types
  array: ({ item }, convert2) => ({ type: "array", items: convert2(item) }),
  tuple_with_rest({ items: originalItems, rest }, convert2) {
    const minItems = originalItems.length;
    let maxItems;
    let items = originalItems.map(convert2);
    let additionalItems;
    if (isNeverSchema(rest)) {
      maxItems = minItems;
    } else if (rest) {
      const restItems = convert2(rest);
      if (items.length === 1 && isEqual(items[0], restItems)) {
        items = items[0];
      } else {
        additionalItems = restItems;
      }
    }
    return {
      type: "array",
      items,
      ...additionalItems && { additionalItems },
      ...minItems && { minItems },
      ...maxItems && { maxItems }
    };
  },
  strict_tuple({ items: originalItems }, convert2) {
    const items = originalItems.map(convert2);
    return { type: "array", items, minItems: items.length, maxItems: items.length };
  },
  tuple({ items: originalItems }, convert2, context) {
    const items = originalItems.map(convert2);
    return { type: "array", items, minItems: items.length };
  },
  object_with_rest({ entries, rest }, convert2, context) {
    const properties = {};
    const required = [];
    for (const [propKey, propValue] of Object.entries(entries)) {
      const propSchema = propValue;
      if (!isOptionalSchema(propSchema) && !isNullishSchema(propSchema)) {
        required.push(propKey);
      }
      properties[propKey] = convert2(propSchema);
      assignExtraJSONSchemaFeatures(propValue, properties[propKey]);
    }
    let additionalProperties;
    if (rest) {
      additionalProperties = isNeverSchema(rest) ? false : convert2(rest);
    } else if (context.strictObjectTypes) {
      additionalProperties = false;
    }
    const output = { type: "object", properties };
    if (additionalProperties !== void 0) output.additionalProperties = additionalProperties;
    if (required.length) output.required = required;
    return output;
  },
  object(schema, convert2, context) {
    return SCHEMA_CONVERTERS.object_with_rest(schema, convert2, context);
  },
  strict_object(schema, convert2, context) {
    return SCHEMA_CONVERTERS.object_with_rest({ ...schema, rest: never() }, convert2, context);
  },
  record({ key, value }, convert2) {
    assert2(key, isStringSchema, "Unsupported record key type: %");
    return { type: "object", additionalProperties: convert2(value) };
  },
  lazy(schema, _, context) {
    const nested = schema.getter({});
    const defName = context.defNameMap.get(nested);
    if (!defName) {
      throw new Error("Type inside lazy schema must be provided in the definitions");
    }
    return { $ref: toDefinitionURI(defName) };
  },
  date(_, __, context) {
    if (!context.dateStrategy) {
      throw new Error('The "dateStrategy" option must be set to handle date validators');
    }
    switch (context.dateStrategy) {
      case "integer":
        return { type: "integer", format: "unix-time" };
      case "string":
        return { type: "string", format: "date-time" };
    }
  },
  undefined(_, __, context) {
    if (!context.undefinedStrategy) {
      throw new Error('The "undefinedStrategy" option must be set to handle the `undefined` schema');
    }
    switch (context.undefinedStrategy) {
      case "any":
        return {};
      case "null":
        return { type: "null" };
    }
  },
  bigint(_, __, context) {
    if (!context.bigintStrategy) {
      throw new Error('The "bigintStrategy" option must be set to handle `bigint` validators');
    }
    switch (context.bigintStrategy) {
      case "integer":
        return { type: "integer", format: "int64" };
      case "string":
        return { type: "string" };
    }
  },
  variant({ options }, ...args) {
    return SCHEMA_CONVERTERS.union({ options }, ...args);
  }
};
var VALIDATION_BY_SCHEMA = {
  array: {
    length: ({ requirement }) => ({ minItems: requirement, maxItems: requirement }),
    min_length: ({ requirement }) => ({ minItems: requirement }),
    max_length: ({ requirement }) => ({ maxItems: requirement })
  },
  string: {
    value: ({ requirement }) => ({ const: requirement }),
    length: ({ requirement }) => ({ minLength: requirement, maxLength: requirement }),
    min_length: ({ requirement }) => ({ minLength: requirement }),
    max_length: ({ requirement }) => ({ maxLength: requirement }),
    // TODO: validate RegExp features are compatible with json schema ?
    regex: ({ requirement }) => ({ pattern: requirement.source }),
    email: () => ({ format: "email" }),
    iso_date: () => ({ format: "date" }),
    iso_timestamp: () => ({ format: "date-time" }),
    ipv4: () => ({ format: "ipv4" }),
    ipv6: () => ({ format: "ipv6" }),
    uuid: () => ({ format: "uuid" })
  },
  number: {
    value: ({ requirement }) => ({ const: requirement }),
    min_value: ({ requirement }) => ({ minimum: requirement }),
    max_value: ({ requirement }) => ({ maximum: requirement }),
    multiple_of: ({ requirement }) => ({ multipleOf: requirement }),
    integer: () => ({ type: "integer" })
  },
  boolean: {
    value: ({ requirement }) => ({ const: requirement })
  },
  date: {
    value: ({ requirement }, context) => ({ const: asDateRequirement("value", requirement, context) }),
    min_value: ({ requirement }, context) => ({ minimum: asDateRequirement("minValue", requirement, context) }),
    max_value: ({ requirement }, context) => ({ maximum: asDateRequirement("maxValue", requirement, context) })
  }
};
function asDateRequirement(type, requirement, context) {
  assert2(requirement, () => context.dateStrategy === "integer", `${type} validation is only available with 'integer' date strategy`);
  assert2(requirement, (r) => r instanceof Date, `Non-date value used for ${type} validation`);
  return requirement.getTime();
}
function convertPipe(schemaType, pipe, context) {
  const [schema, ...pipeItems] = pipe || [];
  if (!schema) return {};
  const childPipe = convertPipe(schemaType, schema == null ? void 0 : schema.pipe, context);
  function convertPipeItem(def, validation) {
    var _a, _b, _c;
    const validationType = validation.type;
    const validationConverter = ((_b = (_a = context.customValidationConversion) == null ? void 0 : _a[schemaType]) == null ? void 0 : _b[validationType]) || ((_c = VALIDATION_BY_SCHEMA[schemaType]) == null ? void 0 : _c[validationType]);
    if (!validationConverter && context.ignoreUnknownValidation) return {};
    assert2(validationConverter, Boolean, `Unsupported valibot validation \`${validationType}\` for schema \`${schemaType}\``);
    const converted = validationConverter(validation, context);
    return Object.assign(def, converted);
  }
  return pipeItems.reduce(convertPipeItem, childPipe);
}
function getDefNameMap(definitions = {}) {
  const map = /* @__PURE__ */ new Map();
  for (const [name, definition] of Object.entries(definitions)) {
    map.set(definition, name);
  }
  return map;
}
function createConverter(context) {
  const definitions = {};
  function converter(schema) {
    var _a;
    const defName = context.defNameMap.get(schema);
    const defURI = defName && toDefinitionURI(defName);
    if (defURI && defURI in definitions) {
      return { $ref: defURI };
    }
    const schemaConverter = ((_a = context.customSchemaConversion) == null ? void 0 : _a[schema.type]) || SCHEMA_CONVERTERS[schema.type];
    assert2(schemaConverter, Boolean, `Unsupported valibot schema: ${(schema == null ? void 0 : schema.type) || schema}`);
    let converted = schemaConverter(schema, converter, context) || {};
    const convertedValidation = convertPipe(schema.type, schema.pipe, context);
    converted = { ...converted, ...convertedValidation };
    assignExtraJSONSchemaFeatures(schema, converted);
    if (defURI) {
      definitions[defName] = converted;
      return { $ref: defURI };
    }
    return converted;
  }
  return { definitions, converter };
}
function toJSONSchema(options) {
  const { schema, definitions: inputDefinitions, ...more } = options;
  const defNameMap = getDefNameMap(inputDefinitions);
  const { definitions, converter } = createConverter({ defNameMap, ...more });
  if (!schema && !inputDefinitions) {
    throw new Error("No main schema or definitions provided.");
  }
  if (inputDefinitions) {
    Object.values(inputDefinitions).forEach(converter);
  }
  const mainConverted = schema && converter(schema);
  const mainDefName = schema && defNameMap.get(schema);
  const out = { $schema };
  if (mainDefName) {
    out.$ref = toDefinitionURI(mainDefName);
  } else {
    Object.assign(out, mainConverted);
  }
  if (Object.keys(definitions).length) {
    out.definitions = definitions;
  }
  return out;
}

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/valibot.js
var defaultOptions = {
  strictObjectTypes: true,
  dateStrategy: "integer",
  ignoreUnknownValidation: true,
  customSchemaConversion: { custom: () => ({}), instance: () => ({}) }
};
var valibotToJSONSchema = (options) => {
  return toJSONSchema({ ...defaultOptions, ...options });
};
async function validate3(schema, data, config) {
  const result = await safeParseAsync(schema, data, config);
  if (result.success) {
    return {
      data: result.output,
      success: true
    };
  }
  return {
    issues: result.issues.map(({ message, path }) => ({
      message,
      path: path == null ? void 0 : path.map(({ key }) => key)
    })),
    success: false
  };
}
function _valibot(schema, options = {}) {
  return createAdapter({
    superFormValidationLibrary: "valibot",
    validate: async (data) => validate3(schema, data, options == null ? void 0 : options.config),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    jsonSchema: (options == null ? void 0 : options.jsonSchema) ?? valibotToJSONSchema({ schema, ...options }),
    defaults: "defaults" in options ? options.defaults : void 0
  });
}
function _valibotClient(schema) {
  return {
    superFormValidationLibrary: "valibot",
    validate: async (data) => validate3(schema, data)
  };
}
var valibot = memoize(_valibot);
var valibotClient = memoize(_valibotClient);

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/common.js
var commonConverter = (description, converters) => {
  var _a, _b;
  const jsonSchema = {};
  jsonSchema.type = description.type;
  if (description.nullable) {
    jsonSchema.type = [jsonSchema.type, "null"];
  }
  if (((_a = description.oneOf) == null ? void 0 : _a.length) > 0) {
    jsonSchema.enum = description.oneOf;
  }
  if (((_b = description.notOneOf) == null ? void 0 : _b.length) > 0) {
    jsonSchema.not = {
      enum: description.notOneOf
    };
  }
  if (description.label) {
    jsonSchema.title = description.label;
  }
  if (description.default !== void 0) {
    jsonSchema.default = description.default;
  }
  return jsonSchema;
};
var common_default = commonConverter;

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/string.js
var uuidRegExPattern = "^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$";
var stringConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  description.tests.forEach((test) => {
    var _a, _b, _c, _d;
    switch (test.name) {
      case "length":
        if (((_a = test.params) == null ? void 0 : _a.length) !== void 0) {
          jsonSchema.minLength = Number(test.params.length);
          jsonSchema.maxLength = Number(test.params.length);
        }
        break;
      case "min":
        if (((_b = test.params) == null ? void 0 : _b.min) !== void 0) {
          jsonSchema.minLength = Number(test.params.min);
        }
        break;
      case "max":
        if (((_c = test.params) == null ? void 0 : _c.max) !== void 0) {
          jsonSchema.maxLength = Number(test.params.max);
        }
        break;
      case "matches":
        if ((_d = test.params) == null ? void 0 : _d.regex) {
          jsonSchema.pattern = test.params.regex.toString().replace(/^\/(.*)\/[gimusy]*$/, "$1");
        }
        break;
      case "email":
        jsonSchema.format = "email";
        break;
      case "url":
        jsonSchema.format = "uri";
        break;
      case "uuid":
        jsonSchema.format = "uuid";
        jsonSchema.pattern = uuidRegExPattern;
        break;
    }
  });
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var string_default = stringConverter;

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/number.js
var numberConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  description.tests.forEach((test) => {
    var _a, _b, _c, _d;
    switch (test.name) {
      case "min":
        if (((_a = test.params) == null ? void 0 : _a.min) !== void 0) {
          jsonSchema.minimum = Number(test.params.min);
        }
        if (((_b = test.params) == null ? void 0 : _b.more) !== void 0) {
          jsonSchema.exclusiveMinimum = Number(test.params.more);
        }
        break;
      case "max":
        if (((_c = test.params) == null ? void 0 : _c.max) !== void 0) {
          jsonSchema.maximum = Number(test.params.max);
        }
        if (((_d = test.params) == null ? void 0 : _d.less) !== void 0) {
          jsonSchema.exclusiveMaximum = Number(test.params.less);
        }
        break;
      case "integer":
        if (jsonSchema.type === "number") {
          jsonSchema.type = "integer";
        } else {
          jsonSchema.type = [...jsonSchema.type, "integer"].filter((type) => type !== "number");
        }
    }
  });
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var number_default = numberConverter;

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/boolean.js
var booleanConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var boolean_default = booleanConverter;

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/date.js
var dateConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  jsonSchema.type = "string";
  jsonSchema.format = "date-time";
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var date_default = dateConverter;

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/array.js
var arrayConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  const { innerType } = description;
  if (innerType) {
    const converter = converters[innerType.type];
    jsonSchema.items = converter(innerType, converters);
  }
  description.tests.forEach((test) => {
    var _a, _b, _c;
    switch (test.name) {
      case "length":
        if (((_a = test.params) == null ? void 0 : _a.length) !== void 0) {
          jsonSchema.minItems = jsonSchema.maxItems = Number(test.params.length);
        }
        break;
      case "min":
        if (((_b = test.params) == null ? void 0 : _b.min) !== void 0) {
          jsonSchema.minItems = Number(test.params.min);
        }
        break;
      case "max":
        if (((_c = test.params) == null ? void 0 : _c.max) !== void 0) {
          jsonSchema.maxItems = Number(test.params.max);
        }
        break;
    }
  });
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var array_default = arrayConverter;

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/object.js
var objectConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  const properties = {};
  const required = [];
  Object.keys(description.fields).forEach((fieldName) => {
    const fieldDescription = description.fields[fieldName];
    const converter = converters[fieldDescription.type];
    properties[fieldName] = converter(fieldDescription, converters);
    if (!fieldDescription.optional) {
      required.push(fieldName);
    }
  });
  if (Object.keys(properties).length > 0) {
    jsonSchema.properties = properties;
  }
  if (Object.keys(required).length > 0) {
    jsonSchema.required = required;
  }
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var object_default = objectConverter;

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/tuple.js
var tupleConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  jsonSchema.type = "array";
  jsonSchema.items = description.innerType.map((description2) => {
    const converter = converters[description2.type];
    return converter(description2, converters);
  });
  jsonSchema.minItems = jsonSchema.items.length;
  jsonSchema.maxItems = jsonSchema.items.length;
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var tuple_default = tupleConverter;

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/mixed.js
var getType = (item) => {
  switch (typeof item) {
    case "string":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "object":
      if (Array.isArray(item)) {
        return "array";
      } else if (item === null) {
        return "null";
      } else if (item instanceof Date) {
        return "string";
      } else {
        return "object";
      }
    default:
      return "null";
  }
};
var mixedConverter = (description, converters) => {
  var _a;
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  let types = Array.isArray(description.type) ? description.type : [description.type];
  types = types.filter((type) => type !== "mixed");
  if (((_a = description.oneOf) == null ? void 0 : _a.length) > 0) {
    description.oneOf.forEach((item) => {
      types.push(getType(item));
    });
  }
  if (description.default !== void 0) {
    types.push(getType(description.default));
  }
  types = types.filter((type, index, self) => self.indexOf(type) === index);
  jsonSchema.type = types;
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var mixed_default = mixedConverter;

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/lazy.js
var lazyConverter = (description, converters) => {
  const jsonSchema = common_default(description, converters);
  const meta = description.meta || {};
  return Object.assign(jsonSchema, meta.jsonSchema);
};
var lazy_default = lazyConverter;

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/yup-to-json-schema/converters/index.js
function convertSchema(yupSchema, options) {
  const { converters, ...resolveOptions } = options || {};
  const allConverters = {
    string: string_default,
    number: number_default,
    boolean: boolean_default,
    date: date_default,
    array: array_default,
    object: object_default,
    tuple: tuple_default,
    mixed: mixed_default,
    lazy: lazy_default,
    ...converters
  };
  const description = yupSchema.describe(resolveOptions);
  const converter = allConverters[description.type];
  return converter(description, allConverters);
}

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/yup.js
var modules3 = async () => {
  const { ValidationError } = await import(
    /* webpackIgnore: true */
    "./index.esm-FJFAXFLP.js"
  );
  return { ValidationError };
};
var fetchModule3 = memoize(modules3);
function yupToJSONSchema(schema) {
  return convertSchema(schema, {
    converters: {
      date: (desc, options) => {
        return options.string(desc, options);
      }
    }
  });
}
async function validate4(schema, data) {
  const { ValidationError } = await fetchModule3();
  try {
    return {
      success: true,
      data: await schema.validate(data, { strict: true, abortEarly: false })
    };
  } catch (error) {
    if (!(error instanceof ValidationError))
      throw error;
    return {
      success: false,
      issues: error.inner.map((error2) => ({
        message: error2.message,
        path: error2.path !== null && error2.path !== void 0 ? splitPath(error2.path) : void 0
      }))
    };
  }
}
function _yup(schema, options) {
  return createAdapter({
    superFormValidationLibrary: "yup",
    validate: async (data) => validate4(schema, data),
    jsonSchema: (options == null ? void 0 : options.jsonSchema) ?? yupToJSONSchema(schema),
    defaults: options == null ? void 0 : options.defaults
  });
}
function _yupClient(schema) {
  return {
    superFormValidationLibrary: "yup",
    validate: async (data) => validate4(schema, data)
  };
}
var yup = memoize(_yup);
var yupClient = memoize(_yupClient);

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions2 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions2,
  name: options
} : {
  ...defaultOptions2,
  ...options
};

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!(refs == null ? void 0 : refs.errorMessages))
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef() {
  return {};
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/array.js
function parseArrayDef(def, refs) {
  var _a, _b;
  const res = {
    type: "array"
  };
  if (((_b = (_a = def.type) == null ? void 0 : _a._def) == null ? void 0 : _b.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: def.values
  };
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   */
  emoji: RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u"),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
  }
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(processPattern(check.value)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji, check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
var escapeNonAlphaNumeric = (value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join("");
var addFormat = (schema, value, message, refs) => {
  var _a;
  if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
};
var addPattern = (schema, regex, message, refs) => {
  var _a;
  if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: processRegExp(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", processRegExp(regex, refs), message, refs);
  }
};
var processRegExp = (regex, refs) => {
  var _a;
  if (!refs.applyRegexFlags || !regex.flags)
    return regex.source;
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a = source[i + 2]) == null ? void 0 : _a.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    const regexTest = new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
};

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  var _a, _b, _c, _d;
  if (refs.target === "openApi3" && ((_a = def.keyType) == null ? void 0 : _a._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? {}
      }), {}),
      additionalProperties: false
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce((acc, [key, value]) => key === "type" ? acc : { ...acc, [key]: value }, {});
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  }
  return schema;
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || {};
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef() {
  return {
    not: {}
  };
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function decideAdditionalProperties(def, refs) {
  if (refs.removeAdditionalStrategy === "strict") {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys !== "strict" : parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  } else {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  }
}
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
      if (propDef === void 0 || propDef._def === void 0)
        return acc;
      const parsedDef = parseDef(propDef._def, {
        ...refs,
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      });
      if (parsedDef === void 0)
        return acc;
      return {
        properties: { ...acc.properties, [propName]: parsedDef },
        required: propDef.isOptional() ? acc.required : [...acc.required, propName]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: decideAdditionalProperties(def, refs)
  };
  if (!result.required.length)
    delete result.required;
  return result;
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  var _a;
  if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: {}
      },
      innerSchema
    ]
  } : {};
};

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef() {
  return {
    not: {}
  };
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef() {
  return {};
}

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  var _a;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a = refs.override) == null ? void 0 : _a.call(refs, def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser(def, def.typeName, refs);
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return {};
      }
      return refs.$refStrategy === "seen" ? {} : void 0;
    }
  }
};
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return parseDef(def.getter()._def, refs);
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
};
var addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};

// node_modules/.pnpm/zod-to-json-schema@3.23.1_zod@3.23.8/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  const refs = getRefs(options);
  const definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => ({
    ...acc,
    [name2]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name2]
    }, true) ?? {}
  }), {}) : void 0;
  const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = parseDef(schema._def, name === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false) ?? {};
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined = name === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  return combined;
};

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/zod.js
var defaultOptions3 = {
  dateStrategy: "integer",
  pipeStrategy: "output",
  $refStrategy: "none"
};
var zodToJSONSchema = (...params) => {
  params[1] = typeof params[1] == "object" ? { ...defaultOptions3, ...params[1] } : defaultOptions3;
  return zodToJsonSchema(...params);
};
async function validate5(schema, data, errorMap) {
  const result = await schema.safeParseAsync(data, { errorMap });
  if (result.success) {
    return {
      data: result.data,
      success: true
    };
  }
  return {
    issues: result.error.issues.map(({ message, path }) => ({ message, path })),
    success: false
  };
}
function _zod(schema, options) {
  return createAdapter({
    superFormValidationLibrary: "zod",
    validate: async (data) => validate5(schema, data, options == null ? void 0 : options.errorMap),
    jsonSchema: (options == null ? void 0 : options.jsonSchema) ?? zodToJSONSchema(schema, options == null ? void 0 : options.config),
    defaults: options == null ? void 0 : options.defaults
  });
}
function _zodClient(schema, options) {
  return {
    superFormValidationLibrary: "zod",
    validate: async (data) => validate5(schema, data, options == null ? void 0 : options.errorMap)
  };
}
var zod = memoize(_zod);
var zodClient = memoize(_zodClient);

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/vine.js
async function modules4() {
  const { Vine, errors } = await import(
    /* webpackIgnore: true */
    "./build-ISBLCGH3.js"
  );
  return { Vine, errors };
}
var fetchModule4 = memoize(modules4);
async function validate6(schema, data) {
  const { Vine, errors } = await fetchModule4();
  try {
    const output = await new Vine().validate({ schema, data });
    return {
      success: true,
      data: output
    };
  } catch (e) {
    if (e instanceof errors.E_VALIDATION_ERROR) {
      return {
        success: false,
        issues: e.messages.map((m) => ({
          path: m.field.split("."),
          message: m.message
        }))
      };
    } else {
      return { success: false, issues: [] };
    }
  }
}
function _vine(schema, options) {
  return createAdapter({
    superFormValidationLibrary: "vine",
    validate: async (data) => validate6(schema, data),
    jsonSchema: createJsonSchema(options),
    defaults: options.defaults
  });
}
function _vineClient(schema) {
  return {
    superFormValidationLibrary: "vine",
    validate: async (data) => validate6(schema, data)
  };
}
var vine = memoize(_vine);
var vineClient = memoize(_vineClient);

// node_modules/.pnpm/sveltekit-superforms@2.15.1_@sveltejs+kit@2.5.17_@sveltejs+vite-plugin-svelte@3.1.1_svelte@5._zzawhdfnlrfnvtderpjh43fm64/node_modules/sveltekit-superforms/dist/adapters/schemasafe.js
var import_schemasafe = __toESM(require_src(), 1);
var Email2 = /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;
var defaultOptions4 = {
  formats: {
    email: (str) => Email2.test(str)
  },
  includeErrors: true,
  allErrors: true
};
function cachedValidator(currentSchema, config) {
  if (!cache.has(currentSchema)) {
    cache.set(currentSchema, (0, import_schemasafe.validator)(currentSchema, {
      ...defaultOptions4,
      ...config
    }));
  }
  return cache.get(currentSchema);
}
function _schemasafe(schema, options) {
  return createAdapter({
    superFormValidationLibrary: "schemasafe",
    jsonSchema: schema,
    defaults: options == null ? void 0 : options.defaults,
    async validate(data) {
      const validator2 = cachedValidator(schema, options == null ? void 0 : options.config);
      const isValid = validator2(data);
      if (isValid) {
        return {
          data,
          success: true
        };
      }
      return {
        issues: (validator2.errors ?? []).map(({ instanceLocation, keywordLocation }) => ({
          message: keywordLocation,
          path: instanceLocation.split("/").slice(1)
        })),
        success: false
      };
    }
  });
}
function _schemasafeClient(schema, options) {
  return {
    superFormValidationLibrary: "schemasafe",
    async validate(data) {
      const validator2 = cachedValidator(schema, options == null ? void 0 : options.config);
      const isValid = validator2(data);
      if (isValid) {
        return {
          data,
          success: true
        };
      }
      return {
        issues: (validator2.errors ?? []).map(({ instanceLocation, keywordLocation }) => ({
          message: keywordLocation,
          path: instanceLocation.split("/").slice(1)
        })),
        success: false
      };
    }
  };
}
var schemasafe = memoize(_schemasafe);
var schemasafeClient = memoize(_schemasafeClient);
var cache = /* @__PURE__ */ new WeakMap();
export {
  arktype,
  arktypeClient,
  joi,
  joiClient,
  schemasafe,
  schemasafeClient,
  superformClient,
  typebox,
  typeboxClient,
  valibot,
  valibotClient,
  vine,
  vineClient,
  yup,
  yupClient,
  zod,
  zodClient
};
//# sourceMappingURL=sveltekit-superforms_adapters.js.map
