import {
  __publicField
} from "./chunk-DWA4UIM3.js";

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/arrays.js
var arrayFrom = (data) => Array.isArray(data) ? data : [data];
var spliterate = (list, by) => {
  const result = [[], []];
  for (const item of list) {
    if (by(item))
      result[0].push(item);
    else
      result[1].push(item);
  }
  return result;
};
var ReadonlyArray = Array;
var includes = (array, element) => array.includes(element);
var append = (to, value, opts) => {
  if (value === void 0)
    return to ?? [];
  if (to === void 0) {
    return value === void 0 ? [] : Array.isArray(value) ? value : [value];
  }
  if (opts == null ? void 0 : opts.prepend)
    Array.isArray(value) ? to.unshift(...value) : to.unshift(value);
  else
    Array.isArray(value) ? to.push(...value) : to.push(value);
  return to;
};
var appendUnique = (to, value) => {
  if (to === void 0)
    return [value];
  if (!to.includes(value))
    to.push(value);
  return to;
};
var groupBy = (array, discriminant) => array.reduce((result, item) => {
  const key = item[discriminant];
  result[key] ?? (result[key] = []);
  result[key].push(item);
  return result;
}, {});

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/clone.js
var shallowClone = (input) => Object.create(Object.getPrototypeOf(input), Object.getOwnPropertyDescriptors(input));

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/errors.js
var InternalArktypeError = class extends Error {
};
var throwInternalError = (message) => throwError(message, InternalArktypeError);
var throwError = (message, ctor = Error) => {
  throw new ctor(message);
};
var ParseError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ParseError");
  }
};
var throwParseError = (message) => throwError(message, ParseError);

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/flatMorph.js
function flatMorph(o, flatMapEntry) {
  var _a8;
  const inputIsArray = Array.isArray(o);
  const entries = Object.entries(o).flatMap((entry, i) => {
    const result = inputIsArray ? flatMapEntry(i, entry[1]) : flatMapEntry(...entry, i);
    const entrySet = Array.isArray(result[0]) || result.length === 0 ? (
      // if we have an empty array (for filtering) or an array with
      // another array as its first element, treat it as a list of
      result
    ) : [result];
    return entrySet;
  });
  const objectResult = Object.fromEntries(entries);
  return typeof ((_a8 = entries[0]) == null ? void 0 : _a8[0]) === "number" ? Object.values(objectResult) : objectResult;
}

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/records.js
var entriesOf = (o) => Object.entries(o);
var fromEntries = (entries) => Object.fromEntries(entries);
var isKeyOf = (k, o) => k in o;
var InnerDynamicBase = class {
  constructor(properties) {
    Object.assign(this, properties);
  }
};
var DynamicBase = class extends InnerDynamicBase {
};
var NoopBase = class {
};
var CastableBase = class extends NoopBase {
};
var splitByKeys = (o, leftKeys) => {
  const l = {};
  const r = {};
  let k;
  for (k in o) {
    if (k in leftKeys)
      l[k] = o[k];
    else
      r[k] = o[k];
  }
  return [l, r];
};
var pick = (o, keys) => splitByKeys(o, keys)[0];
var omit = (o, keys) => splitByKeys(o, keys)[1];
var isEmptyObject = (o) => Object.keys(o).length === 0;
var stringAndSymbolicEntriesOf = (o) => [
  ...Object.entries(o),
  ...Object.getOwnPropertySymbols(o).map((k) => [k, o[k]])
];
var defineProperties = (base, merged) => (
  // declared like this to avoid https://github.com/microsoft/TypeScript/issues/55049
  Object.defineProperties(base, Object.getOwnPropertyDescriptors(merged))
);
var unset = Symbol("represents an uninitialized value");

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/functions.js
var bound = (target, ctx) => {
  ctx.addInitializer(function() {
    this[ctx.name] = this[ctx.name].bind(this);
  });
};
var cached = (target, context) => function() {
  const value = target.call(this);
  Object.defineProperty(this, context.name, context.kind === "getter" ? { value } : {
    value: () => value,
    enumerable: false
  });
  return value;
};
var cachedThunk = (thunk) => {
  let result = unset;
  return () => result === unset ? result = thunk() : result;
};
var isThunk = (value) => typeof value === "function" && value.length === 0;
var DynamicFunction = class extends Function {
  constructor(...args) {
    const params = args.slice(0, -1);
    const body = args.at(-1);
    try {
      super(...params, body);
    } catch (e) {
      return throwInternalError(`Encountered an unexpected error while compiling your definition:
                Message: ${e} 
                Source: (${args.slice(0, -1)}) => {
                    ${args.at(-1)}
                }`);
    }
  }
};
var Callable = class extends NoopBase {
  constructor(f, opts) {
    super();
    return Object.assign(Object.setPrototypeOf(f.bind((opts == null ? void 0 : opts.bind) ?? this), this.constructor.prototype), opts == null ? void 0 : opts.attach);
  }
};
var envHasCsp = cachedThunk(() => {
  try {
    return new Function("return false")();
  } catch (e) {
    return true;
  }
});

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/domain.js
var hasDomain = (data, kind) => domainOf(data) === kind;
var domainOf = (data) => {
  const builtinType = typeof data;
  return builtinType === "object" ? data === null ? "null" : "object" : builtinType === "function" ? "object" : builtinType;
};
var enumerableDomainDescriptions = {
  boolean: "boolean",
  null: "null",
  undefined: "undefined"
};
var nonEnumerableDomainDescriptions = {
  bigint: "a bigint",
  number: "a number",
  object: "an object",
  string: "a string",
  symbol: "a symbol"
};
var domainDescriptions = {
  ...nonEnumerableDomainDescriptions,
  ...enumerableDomainDescriptions
};

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/objectKinds.js
var builtinConstructors = {
  Array,
  Date,
  Error,
  Function,
  Map,
  RegExp,
  Set,
  String,
  Number,
  Boolean,
  WeakMap,
  WeakSet,
  Promise
};
var objectKindOf = (data) => {
  var _a8;
  let prototype = Object.getPrototypeOf(data);
  while ((prototype == null ? void 0 : prototype.constructor) && (!isKeyOf(prototype.constructor.name, builtinConstructors) || !(data instanceof builtinConstructors[prototype.constructor.name])))
    prototype = Object.getPrototypeOf(prototype);
  const name = (_a8 = prototype == null ? void 0 : prototype.constructor) == null ? void 0 : _a8.name;
  if (name === void 0 || name === "Object")
    return void 0;
  return name;
};
var objectKindOrDomainOf = (data) => typeof data === "object" && data !== null ? objectKindOf(data) ?? "object" : domainOf(data);
var isArray = (data) => Array.isArray(data);
var objectKindDescriptions = {
  Array: "an array",
  Function: "a function",
  Date: "a Date",
  RegExp: "a RegExp",
  Error: "an Error",
  Map: "a Map",
  Set: "a Set",
  String: "a String object",
  Number: "a Number object",
  Boolean: "a Boolean object",
  Promise: "a Promise",
  WeakMap: "a WeakMap",
  WeakSet: "a WeakSet"
};
var getExactBuiltinConstructorName = (ctor) => {
  const constructorName = Object(ctor).name ?? null;
  return constructorName && isKeyOf(constructorName, builtinConstructors) && builtinConstructors[constructorName] === ctor ? constructorName : null;
};
var prototypeKeysOf = (value) => {
  const result = [];
  let curr = value;
  while (curr !== Object.prototype && curr !== null && curr !== void 0) {
    for (const k of Object.getOwnPropertyNames(curr))
      if (k !== "constructor" && !result.includes(k))
        result.push(k);
    for (const symbol of Object.getOwnPropertySymbols(curr))
      if (!result.includes(symbol))
        result.push(symbol);
    curr = Object.getPrototypeOf(curr);
  }
  return result;
};
var baseKeysByDomain = {
  bigint: prototypeKeysOf(0n),
  boolean: prototypeKeysOf(false),
  null: [],
  number: prototypeKeysOf(0),
  // TS doesn't include the Object prototype in keyof, so keyof object is never
  object: [],
  string: prototypeKeysOf(""),
  symbol: prototypeKeysOf(Symbol()),
  undefined: []
};
var getBaseDomainKeys = (domain) => [...baseKeysByDomain[domain]];
var constructorExtends = (ctor, base) => {
  let current = ctor.prototype;
  while (current !== null) {
    if (current === base.prototype)
      return true;
    current = Object.getPrototypeOf(current);
  }
  return false;
};

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/primitive.js
var serializePrimitive = (value) => typeof value === "string" ? JSON.stringify(value) : typeof value === "bigint" ? `${value}n` : `${value}`;

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/registry.js
if ("$ark" in globalThis) {
  throwError(`Tried to initialize an $ark registry but one already existed.
This probably means you are either depending on multiple versions of an arktype package,
or importing the same package from both ESM and CJS.
Review package.json versions across your repo to ensure consistency.`);
}
var registry = {};
globalThis.$ark = registry;
var namesByResolution = /* @__PURE__ */ new WeakMap();
var nameCounts = {};
var register = (value) => {
  const existingName = namesByResolution.get(value);
  if (existingName)
    return existingName;
  let name = baseNameFor(value);
  if (nameCounts[name])
    name = `${name}${nameCounts[name]++}`;
  else
    nameCounts[name] = 1;
  registry[name] = value;
  namesByResolution.set(value, name);
  return name;
};
var reference = (name) => `$ark.${name}`;
var registeredReference = (value) => reference(register(value));
var isDotAccessible = (keyName) => /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(keyName);
var compileSerializedValue = (value) => hasDomain(value, "object") || typeof value === "symbol" ? registeredReference(value) : serializePrimitive(value);
var baseNameFor = (value) => {
  switch (typeof value) {
    case "object": {
      if (value === null)
        break;
      const prefix = objectKindOf(value) ?? "object";
      return prefix[0].toLowerCase() + prefix.slice(1);
    }
    case "function":
      return isDotAccessible(value.name) ? value.name : "fn";
    case "symbol":
      return value.description && isDotAccessible(value.description) ? value.description : "symbol";
  }
  return throwInternalError(`Unexpected attempt to register serializable value of type ${domainOf(value)}`);
};

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/compilation.js
var CompiledFunction = class extends CastableBase {
  constructor(...args) {
    super();
    __publicField(this, "argNames");
    __publicField(this, "body", "");
    __publicField(this, "indentation", 0);
    this.argNames = args;
    for (const arg of args) {
      if (arg in this) {
        throw new Error(`Arg name '${arg}' would overwrite an existing property on FunctionBody`);
      }
      ;
      this[arg] = arg;
    }
  }
  indent() {
    this.indentation += 4;
    return this;
  }
  dedent() {
    this.indentation -= 4;
    return this;
  }
  prop(key, optional = false) {
    return compileLiteralPropAccess(key, optional);
  }
  index(key, optional = false) {
    return indexPropAccess(`${key}`, optional);
  }
  line(statement) {
    ;
    this.body += `${" ".repeat(this.indentation)}${statement}
`;
    return this;
  }
  const(identifier, expression) {
    this.line(`const ${identifier} = ${expression}`);
    return this;
  }
  let(identifier, expression) {
    return this.line(`let ${identifier} = ${expression}`);
  }
  set(identifier, expression) {
    return this.line(`${identifier} = ${expression}`);
  }
  if(condition, then) {
    return this.block(`if (${condition})`, then);
  }
  elseIf(condition, then) {
    return this.block(`else if (${condition})`, then);
  }
  else(then) {
    return this.block("else", then);
  }
  /** Current index is "i" */
  for(until, body, initialValue = 0) {
    return this.block(`for (let i = ${initialValue}; ${until}; i++)`, body);
  }
  /** Current key is "k" */
  forIn(object, body) {
    return this.block(`for (const k in ${object})`, body);
  }
  block(prefix, contents, suffix = "") {
    this.line(`${prefix} {`);
    this.indent();
    contents(this);
    this.dedent();
    return this.line(`}${suffix}`);
  }
  return(expression = "") {
    return this.line(`return ${expression}`);
  }
  compile() {
    return new DynamicFunction(...this.argNames, this.body);
  }
};
var compileLiteralPropAccess = (key, optional = false) => {
  if (typeof key === "string" && isDotAccessible(key))
    return `${optional ? "?" : ""}.${key}`;
  return indexPropAccess(serializeLiteralKey(key), optional);
};
var serializeLiteralKey = (key) => typeof key === "symbol" ? registeredReference(key) : JSON.stringify(key);
var indexPropAccess = (key, optional = false) => `${optional ? "?." : ""}[${key}]`;

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/generics.js
var id = Symbol("id");

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/hkt.js
var Hkt;
(function(Hkt2) {
  class Kind {
  }
  Hkt2.Kind = Kind;
  class Instantiable {
  }
  Hkt2.Instantiable = Instantiable;
  Hkt2.reify = (def) => def.hkt;
  class UnaryKind {
  }
  Hkt2.UnaryKind = UnaryKind;
  Hkt2.pipe = (...kinds) => (In) => kinds.reduce((out, kind) => kind.hkt(out), In);
})(Hkt || (Hkt = {}));

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/numericLiterals.js
var wellFormedNumberMatcher = /^(?!^-0$)-?(?:0|[1-9]\d*)(?:\.\d*[1-9])?$/;
var isWellFormedNumber = wellFormedNumberMatcher.test.bind(wellFormedNumberMatcher);
var numberLikeMatcher = /^-?\d*\.?\d*$/;
var isNumberLike = (s) => s.length !== 0 && numberLikeMatcher.test(s);
var wellFormedIntegerMatcher = /^(?:0|(?:-?[1-9]\d*))$/;
var isWellFormedInteger = wellFormedIntegerMatcher.test.bind(wellFormedIntegerMatcher);
var integerLikeMatcher = /^-?\d+$/;
var isIntegerLike = integerLikeMatcher.test.bind(integerLikeMatcher);
var numericLiteralDescriptions = {
  number: "a number",
  bigint: "a bigint",
  integer: "an integer"
};
var writeMalformedNumericLiteralMessage = (def, kind) => `'${def}' was parsed as ${numericLiteralDescriptions[kind]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`;
var isWellFormed = (def, kind) => kind === "number" ? isWellFormedNumber(def) : isWellFormedInteger(def);
var parseKind = (def, kind) => kind === "number" ? Number(def) : Number.parseInt(def);
var isKindLike = (def, kind) => kind === "number" ? isNumberLike(def) : isIntegerLike(def);
var tryParseNumber = (token, options) => parseNumeric(token, "number", options);
var tryParseInteger = (token, options) => parseNumeric(token, "integer", options);
var parseNumeric = (token, kind, options) => {
  const value = parseKind(token, kind);
  if (!Number.isNaN(value)) {
    if (isKindLike(token, kind)) {
      if (options == null ? void 0 : options.strict) {
        return isWellFormed(token, kind) ? value : throwParseError(writeMalformedNumericLiteralMessage(token, kind));
      }
      return value;
    }
  }
  return (options == null ? void 0 : options.errorOnFail) ? throwParseError((options == null ? void 0 : options.errorOnFail) === true ? `Failed to parse ${numericLiteralDescriptions[kind]} from '${token}'` : options == null ? void 0 : options.errorOnFail) : void 0;
};
var tryParseWellFormedBigint = (def) => {
  if (def[def.length - 1] !== "n")
    return;
  const maybeIntegerLiteral = def.slice(0, -1);
  let value;
  try {
    value = BigInt(maybeIntegerLiteral);
  } catch {
    return;
  }
  if (wellFormedIntegerMatcher.test(maybeIntegerLiteral))
    return value;
  if (integerLikeMatcher.test(maybeIntegerLiteral)) {
    return throwParseError(writeMalformedNumericLiteralMessage(def, "bigint"));
  }
};

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/serialize.js
var printable = (data, indent) => {
  switch (domainOf(data)) {
    case "object":
      return data instanceof Date ? data.toDateString() : JSON.stringify(_serialize(data, printableOpts, []), null, indent);
    case "symbol":
      return printableOpts.onSymbol(data);
    default:
      return serializePrimitive(data);
  }
};
var printableOpts = {
  onCycle: () => "(cycle)",
  onSymbol: (v) => `Symbol(${register(v)})`,
  onFunction: (v) => `Function(${register(v)})`
};
var _serialize = (data, opts, seen) => {
  switch (domainOf(data)) {
    case "object": {
      if (typeof data === "function")
        return printableOpts.onFunction(data);
      if (seen.includes(data))
        return "(cycle)";
      const nextSeen = [...seen, data];
      if (Array.isArray(data))
        return data.map((item) => _serialize(item, opts, nextSeen));
      if (data instanceof Date)
        return data.toDateString();
      const result = {};
      for (const k in data)
        result[k] = _serialize(data[k], opts, nextSeen);
      return result;
    }
    case "symbol":
      return printableOpts.onSymbol(data);
    case "bigint":
      return `${data}n`;
    case "undefined":
      return opts.onUndefined ?? "undefined";
    default:
      return data;
  }
};

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/strings.js
var capitalize = (s) => s[0].toUpperCase() + s.slice(1);

// node_modules/.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/traits.js
var implementedTraits = Symbol("implementedTraits");

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/utils.js
var makeRootAndArrayPropertiesMutable = (o) => (
  // TODO: this cast should not be required, but it seems TS is referencing
  // the wrong parameters here?
  flatMorph(o, (k, v) => [k, isArray(v) ? [...v] : v])
);
var pathToPropString = (path) => {
  const propAccessChain = path.reduce((s, k) => typeof k === "string" && isDotAccessible(k) ? `${s}.${k}` : `${s}[${printable(k)}]`, "");
  return propAccessChain[0] === "." ? propAccessChain.slice(1) : propAccessChain;
};
var arkKind = Symbol("ArkTypeInternalKind");
var hasArkKind = (value, kind) => (value == null ? void 0 : value[arkKind]) === kind;
var isNode = (value) => hasArkKind(value, "root") || hasArkKind(value, "constraint");
var inferred = Symbol("inferred");

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/implement.js
var basisKinds = ["unit", "proto", "domain"];
var structuralKinds = [
  "required",
  "optional",
  "index",
  "sequence"
];
var refinementKinds = [
  "regex",
  "divisor",
  "exactLength",
  "max",
  "min",
  "maxLength",
  "minLength",
  "before",
  "after"
];
var constraintKinds = [
  ...refinementKinds,
  ...structuralKinds,
  "structure",
  "predicate"
];
var rootKinds = [
  "alias",
  "union",
  "morph",
  "unit",
  "intersection",
  "proto",
  "domain"
];
var nodeKinds = [...rootKinds, ...constraintKinds];
var constraintKeys = flatMorph(constraintKinds, (i, kind) => [kind, 1]);
var structureKeys = flatMorph([...structuralKinds, "undeclared"], (i, k) => [k, 1]);
var precedenceByKind = flatMorph(nodeKinds, (i, kind) => [kind, i]);
var isNodeKind = (value) => typeof value === "string" && value in precedenceByKind;
var precedenceOfKind = (kind) => precedenceByKind[kind];
var schemaKindsRightOf = (kind) => rootKinds.slice(precedenceOfKind(kind) + 1);
var defaultValueSerializer = (v) => {
  if (typeof v === "string" || typeof v === "boolean" || typeof v === "number" || v === null)
    return v;
  return compileSerializedValue(v);
};
var compileErrorContext = (ctx) => {
  let result = "{ ";
  for (const [k, v] of Object.entries(ctx))
    result += `${k}: ${compileSerializedValue(v)}, `;
  return result + " }";
};
var baseKeys = {
  description: { meta: true }
};
var implementNode = (_) => {
  var _a8, _b6, _c, _d;
  const implementation = _;
  if (implementation.hasAssociatedError) {
    (_a8 = implementation.defaults).expected ?? (_a8.expected = (ctx) => "description" in ctx ? ctx.description : implementation.defaults.description(ctx));
    (_b6 = implementation.defaults).actual ?? (_b6.actual = (data) => printable(data));
    (_c = implementation.defaults).problem ?? (_c.problem = (ctx) => `must be ${ctx.expected}${ctx.actual ? ` (was ${ctx.actual})` : ""}`);
    (_d = implementation.defaults).message ?? (_d.message = (ctx) => {
      if (ctx.path.length === 0)
        return ctx.problem;
      const problemWithLocation = `${ctx.propString} ${ctx.problem}`;
      if (problemWithLocation[0] === "[") {
        return `value at ${problemWithLocation}`;
      }
      return problemWithLocation;
    });
  }
  Object.assign(implementation.keys, baseKeys);
  return implementation;
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/config.js
var globalConfig = {};
var mergeConfigs = (base, extensions) => {
  const result = { ...base };
  let k;
  for (k in extensions) {
    result[k] = isNodeKind(k) ? {
      ...base[k],
      ...extensions[k]
    } : extensions[k];
  }
  return result;
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/errors.js
var _a, _b;
var ArkError = class extends (_b = CastableBase, _a = arkKind, _b) {
  constructor(input, ctx) {
    super();
    __publicField(this, "input");
    __publicField(this, _a, "error");
    __publicField(this, "path");
    __publicField(this, "data");
    __publicField(this, "nodeConfig");
    this.input = input;
    defineProperties(this, input);
    const data = ctx.data;
    if (input.code === "union") {
      input.errors = input.errors.flatMap((e) => e.hasCode("union") ? e.errors : e);
    }
    this.nodeConfig = ctx.config[this.code];
    this.path = input.path ?? [...ctx.path];
    if (input.relativePath)
      this.path.push(...input.relativePath);
    this.data = "data" in input ? input.data : data;
  }
  hasCode(code) {
    return this.code === code;
  }
  get propString() {
    return pathToPropString(this.path);
  }
  get expected() {
    var _a8, _b6;
    return this.input.expected ?? ((_b6 = (_a8 = this.nodeConfig).expected) == null ? void 0 : _b6.call(_a8, this.input));
  }
  get actual() {
    var _a8, _b6;
    return this.input.actual !== void 0 ? this.input.actual : (_b6 = (_a8 = this.nodeConfig).actual) == null ? void 0 : _b6.call(_a8, this.data);
  }
  get problem() {
    return this.input.problem ?? this.nodeConfig.problem(this);
  }
  get message() {
    return this.input.message ?? this.nodeConfig.message(this);
  }
  toString() {
    return this.message;
  }
  throw() {
    throw this;
  }
};
var ArkErrors = class extends ReadonlyArray {
  constructor(ctx) {
    super();
    __publicField(this, "ctx");
    __publicField(this, "byPath", {});
    __publicField(this, "count", 0);
    __publicField(this, "mutable", this);
    this.ctx = ctx;
  }
  add(error) {
    const existing = this.byPath[error.propString];
    if (existing) {
      const errorIntersection = new ArkError({
        code: "intersection",
        errors: existing.hasCode("intersection") ? [...existing.errors, error] : [existing, error]
      }, this.ctx);
      const existingIndex = this.indexOf(existing);
      this.mutable[existingIndex === -1 ? this.length : existingIndex] = errorIntersection;
      this.byPath[error.propString] = errorIntersection;
    } else {
      this.byPath[error.propString] = error;
      this.mutable.push(error);
    }
    this.count++;
  }
  get summary() {
    return this.toString();
  }
  get message() {
    return this.toString();
  }
  toString() {
    return this.join("\n");
  }
  throw() {
    throw new AggregateError(this, this.message);
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/traversal.js
var TraversalContext = class {
  constructor(root2, config) {
    __publicField(this, "root");
    __publicField(this, "config");
    __publicField(this, "path", []);
    __publicField(this, "queuedMorphs", []);
    __publicField(this, "errors", new ArkErrors(this));
    __publicField(this, "branches", []);
    __publicField(this, "seen", {});
    this.root = root2;
    this.config = config;
  }
  get currentBranch() {
    return this.branches.at(-1);
  }
  queueMorphs(morphs) {
    var _a8;
    const input = {
      path: [...this.path],
      morphs
    };
    ((_a8 = this.currentBranch) == null ? void 0 : _a8.queuedMorphs.push(input)) ?? this.queuedMorphs.push(input);
  }
  finalize() {
    if (this.hasError())
      return this.errors;
    while (this.queuedMorphs.length) {
      const { path, morphs } = this.queuedMorphs.shift();
      const key = path.at(-1);
      let parent;
      if (key !== void 0) {
        parent = this.root;
        for (let pathIndex = 0; pathIndex < path.length - 1; pathIndex++)
          parent = parent[path[pathIndex]];
      }
      this.path = path;
      for (const morph of morphs) {
        const result = morph(parent === void 0 ? this.root : parent[key], this);
        if (result instanceof ArkErrors)
          return result;
        if (this.hasError())
          return this.errors;
        if (result instanceof ArkError) {
          this.error(result);
          return this.errors;
        }
        if (parent === void 0)
          this.root = result;
        else
          parent[key] = result;
      }
    }
    return this.root;
  }
  get currentErrorCount() {
    return this.currentBranch ? this.currentBranch.error ? 1 : 0 : this.errors.count;
  }
  hasError() {
    return this.currentErrorCount !== 0;
  }
  get failFast() {
    return this.branches.length !== 0;
  }
  error(input) {
    const errCtx = typeof input === "object" ? input.code ? input : { ...input, code: "predicate" } : { code: "predicate", expected: input };
    const error = new ArkError(errCtx, this);
    if (this.currentBranch)
      this.currentBranch.error = error;
    else
      this.errors.add(error);
    return error;
  }
  get data() {
    let result = this.root;
    for (const segment of this.path)
      result = result == null ? void 0 : result[segment];
    return result;
  }
  invalid(input) {
    this.error(input);
    return false;
  }
  pushBranch() {
    this.branches.push({
      error: void 0,
      queuedMorphs: []
    });
  }
  popBranch() {
    return this.branches.pop();
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/node.js
var BaseNode = class extends Callable {
  constructor(attachments) {
    super(
      // pipedFromCtx allows us internally to reuse TraversalContext
      // through pipes and keep track of piped paths. It is not exposed
      (data, pipedFromCtx) => {
        if (!this.includesMorph && !this.allowsRequiresContext && this.allows(data))
          return data;
        if (pipedFromCtx) {
          this.traverseApply(data, pipedFromCtx);
          return pipedFromCtx.data;
        }
        const ctx = new TraversalContext(data, this.$.resolvedConfig);
        this.traverseApply(data, ctx);
        return ctx.finalize();
      },
      { attach: attachments }
    );
    __publicField(this, "attachments");
    __publicField(this, "qualifiedId", `${this.$.id}${this.id}`);
    __publicField(this, "includesMorph", this.kind === "morph" || this.hasKind("optional") && this.hasDefault() || this.hasKind("structure") && this.undeclared === "delete" || this.children.some((child) => child.includesMorph));
    __publicField(
      this,
      "allowsRequiresContext",
      // if a predicate accepts exactly one arg, we can safely skip passing context
      this.hasKind("predicate") && this.inner.predicate.length !== 1 || this.kind === "alias" || this.children.some((child) => child.allowsRequiresContext)
    );
    __publicField(this, "referencesById", this.children.reduce((result, child) => Object.assign(result, child.referencesById), { [this.id]: this }));
    __publicField(this, "precedence", precedenceOfKind(this.kind));
    __publicField(this, "jit", false);
    __publicField(this, "allows", (data) => {
      if (this.allowsRequiresContext) {
        return this.traverseAllows(data, new TraversalContext(data, this.$.resolvedConfig));
      }
      return this.traverseAllows(data);
    });
    // unfortunately we can't use the @cached
    // decorator from @arktype/util on these for now
    // as they cause a deopt in V8
    __publicField(this, "_in");
    __publicField(this, "_out");
    __publicField(this, "_description");
    this.attachments = attachments;
  }
  get references() {
    return Object.values(this.referencesById);
  }
  traverse(data) {
    return this(data);
  }
  get in() {
    this._in ?? (this._in = this.getIo("in"));
    return this._in;
  }
  get out() {
    this._out ?? (this._out = this.getIo("out"));
    return this._out;
  }
  get description() {
    var _a8, _b6;
    this._description ?? (this._description = this.inner.description ?? ((_b6 = (_a8 = this.$.resolvedConfig[this.kind]).description) == null ? void 0 : _b6.call(_a8, this)));
    return this._description;
  }
  getIo(kind) {
    if (!this.includesMorph)
      return this;
    const ioInner = {};
    for (const [k, v] of this.entries) {
      const keySchemaImplementation = this.impl.keys[k];
      if (keySchemaImplementation.meta)
        continue;
      if (keySchemaImplementation.child) {
        const childValue = v;
        ioInner[k] = isArray(childValue) ? childValue.map((child) => child[kind]) : childValue[kind];
      } else
        ioInner[k] = v;
    }
    return this.$.node(this.kind, ioInner);
  }
  toJSON() {
    return this.json;
  }
  toString() {
    return this.expression;
  }
  equals(other) {
    return this.typeHash === other.typeHash;
  }
  assertHasKind(kind) {
    if (!this.kind === kind)
      throwError(`${this.kind} node was not of asserted kind ${kind}`);
    return this;
  }
  hasKind(kind) {
    return this.kind === kind;
  }
  isBasis() {
    return includes(basisKinds, this.kind);
  }
  isConstraint() {
    return includes(constraintKinds, this.kind);
  }
  isRefinement() {
    return includes(refinementKinds, this.kind);
  }
  isRoot() {
    return includes(rootKinds, this.kind);
  }
  hasUnit(value) {
    return this.hasKind("unit") && this.allows(value);
  }
  hasOpenIntersection() {
    return this.impl.intersectionIsOpen;
  }
  get nestableExpression() {
    return this.expression;
  }
  bindScope($) {
    if (this.$ === $)
      return this;
    return new this.constructor(Object.assign(shallowClone(this.attachments), { $ }));
  }
  firstReference(filter) {
    return this.references.find((n) => n !== this && filter(n));
  }
  firstReferenceOrThrow(filter) {
    return this.firstReference(filter) ?? throwError(`${this.id} had no references matching predicate ${filter}`);
  }
  firstReferenceOfKind(kind) {
    return this.firstReference((node2) => node2.kind === kind);
  }
  firstReferenceOfKindOrThrow(kind) {
    return this.firstReference((node2) => node2.kind === kind) ?? throwError(`${this.id} had no ${kind} references`);
  }
  transform(mapper, opts) {
    return this._transform(mapper, {
      seen: {},
      path: [],
      shouldTransform: (opts == null ? void 0 : opts.shouldTransform) ?? (() => true)
    });
  }
  _transform(mapper, ctx) {
    if (ctx.seen[this.id])
      return this.$.lazilyResolve(ctx.seen[this.id]);
    if (!ctx.shouldTransform(this, ctx))
      return this;
    let transformedNode;
    ctx.seen[this.id] = () => transformedNode;
    const innerWithTransformedChildren = flatMorph(this.inner, (k, v) => {
      if (!this.impl.keys[k].child)
        return [k, v];
      const children = v;
      if (!isArray(children)) {
        const transformed2 = children._transform(mapper, ctx);
        return transformed2 ? [k, transformed2] : [];
      }
      const transformed = children.flatMap((n) => {
        const transformedChild = n._transform(mapper, ctx);
        return transformedChild ?? [];
      });
      return transformed.length ? [k, transformed] : [];
    });
    delete ctx.seen[this.id];
    const transformedInner = mapper(this.kind, innerWithTransformedChildren, ctx);
    if (transformedInner === null)
      return null;
    if (isEmptyObject(transformedInner))
      return null;
    if ((this.kind === "required" || this.kind === "optional" || this.kind === "index") && !("value" in transformedInner))
      return null;
    if (this.kind === "morph") {
      ;
      transformedInner.in ?? (transformedInner.in = this.$.keywords.unknown);
    }
    return transformedNode = this.$.node(this.kind, transformedInner);
  }
  configureShallowDescendants(configOrDescription) {
    const config = typeof configOrDescription === "string" ? { description: configOrDescription } : configOrDescription;
    return this.transform((kind, inner) => ({ ...inner, ...config }), {
      shouldTransform: (node2) => node2.kind !== "structure"
    });
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/disjoint.js
var Disjoint = class _Disjoint {
  constructor(sources) {
    __publicField(this, "sources");
    this.sources = sources;
  }
  clone() {
    return new _Disjoint(this.sources);
  }
  static from(kind, l, r) {
    return new _Disjoint({
      "[]": {
        [kind]: {
          l,
          r
        }
      }
    });
  }
  static fromEntries(entries) {
    if (!entries.length) {
      return throwInternalError("Unexpected attempt to create a disjoint from no entries");
    }
    return new _Disjoint({ "[]": fromEntries(entries) });
  }
  get flat() {
    return entriesOf(this.sources).flatMap(([path, disjointKinds]) => entriesOf(disjointKinds).map(([kind, disjoint]) => ({
      path,
      kind,
      disjoint
    })));
  }
  describeReasons() {
    const reasons = this.flat;
    if (reasons.length === 1) {
      const { path, disjoint } = reasons[0];
      const pathString = JSON.parse(path).join(".");
      return `Intersection${pathString && ` at ${pathString}`} of ${describeReasons(disjoint)} results in an unsatisfiable type`;
    }
    return `The following intersections result in unsatisfiable types:
• ${reasons.map(({ path, disjoint }) => `${path}: ${describeReasons(disjoint)}`).join("\n• ")}`;
  }
  isEmpty() {
    return this.flat.length === 0;
  }
  throw() {
    return throwParseError(this.describeReasons());
  }
  invert() {
    const invertedEntries = entriesOf(this.sources).map(([path, disjoints]) => [
      path,
      flatMorph(disjoints, (kind, disjoint) => [
        kind,
        { l: disjoint.r, r: disjoint.l }
      ])
    ]);
    return new _Disjoint(fromEntries(invertedEntries));
  }
  add(input) {
    entriesOf(input.sources).forEach(([path, disjoints]) => Object.assign(this.sources[path] ?? {}, disjoints));
  }
  withPrefixKey(key) {
    const entriesWithPrefix = entriesOf(this.sources).map(([path, disjoints]) => {
      const segments = JSON.parse(path);
      segments.unshift(typeof key === "symbol" ? register(key) : key);
      const pathWithPrefix = JSON.stringify(segments);
      return [pathWithPrefix, disjoints];
    });
    return new _Disjoint(fromEntries(entriesWithPrefix));
  }
  toString() {
    return printable(this.sources);
  }
};
var describeReasons = (source) => `${describeReason(source.l)} and ${describeReason(source.r)}`;
var describeReason = (value) => hasArkKind(value, "root") ? value.expression : isArray(value) ? value.map(describeReason).join(" | ") : String(value);

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/intersections.js
var intersectionCache = {};
var intersectNodesRoot = (l, r, $) => intersectNodes(l, r, { $, invert: false, pipe: false });
var pipeNodesRoot = (l, r, $) => intersectNodes(l, r, { $, invert: false, pipe: true });
var intersectNodes = (l, r, ctx) => {
  const operator = ctx.pipe ? "|>" : "&";
  const lrCacheKey = `${l.typeHash}${operator}${r.typeHash}`;
  if (intersectionCache[lrCacheKey] !== void 0)
    return intersectionCache[lrCacheKey];
  if (!ctx.pipe) {
    const rlCacheKey = `${r.typeHash}${operator}${l.typeHash}`;
    if (intersectionCache[rlCacheKey] !== void 0) {
      const rlResult = intersectionCache[rlCacheKey];
      const lrResult = rlResult instanceof Disjoint ? rlResult.invert() : rlResult;
      intersectionCache[lrCacheKey] = lrResult;
      return lrResult;
    }
  }
  if (l.equals(r))
    return l;
  let result;
  if (ctx.pipe && l.hasKind("morph")) {
    result = ctx.invert ? pipeToMorph(r, l, ctx) : pipeFromMorph(l, r, ctx);
  } else if (ctx.pipe && r.hasKind("morph")) {
    result = ctx.invert ? pipeFromMorph(r, l, ctx) : pipeToMorph(l, r, ctx);
  } else {
    const leftmostKind = l.precedence < r.precedence ? l.kind : r.kind;
    const implementation = l.impl.intersections[r.kind] ?? r.impl.intersections[l.kind];
    if (implementation === void 0) {
      result = null;
    } else if (leftmostKind === l.kind)
      result = implementation(l, r, ctx);
    else {
      result = implementation(r, l, { ...ctx, invert: !ctx.invert });
      if (result instanceof Disjoint)
        result = result.invert();
    }
  }
  if (isNode(result)) {
    if (l.equals(result))
      result = l;
    else if (r.equals(result))
      result = r;
  }
  intersectionCache[lrCacheKey] = result;
  return result;
};
var pipeFromMorph = (from, to, ctx) => {
  const morphs = [...from.morphs];
  if (from.validatedOut) {
    const outIntersection = intersectNodes(from.validatedOut, to, ctx);
    if (outIntersection instanceof Disjoint)
      return outIntersection;
    morphs[morphs.length - 1] = outIntersection;
  } else
    morphs.push(to);
  return ctx.$.node("morph", {
    morphs,
    in: from.in
  });
};
var pipeToMorph = (from, to, ctx) => {
  const result = intersectNodes(from, to.in, ctx);
  if (result instanceof Disjoint)
    return result;
  return ctx.$.node("morph", {
    morphs: to.morphs,
    in: result
  });
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/constraint.js
var _a2, _b2;
var BaseConstraint = class extends (_b2 = BaseNode, _a2 = arkKind, _b2) {
  constructor() {
    super(...arguments);
    __publicField(this, _a2, "constraint");
    __publicField(this, "impliedSiblings");
  }
  intersect(r) {
    return intersectNodesRoot(this, r, this.$);
  }
};
var RawPrimitiveConstraint = class extends BaseConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "traverseApply", (data, ctx) => {
      if (!this.traverseAllows(data, ctx))
        ctx.error(this.errorContext);
    });
  }
  compile(js) {
    if (js.traversalKind === "Allows")
      js.return(this.compiledCondition);
    else {
      js.if(this.compiledNegation, () => js.line(`${js.ctx}.error(${this.compiledErrorContext})`));
    }
  }
  get errorContext() {
    return { code: this.kind, description: this.description, ...this.inner };
  }
  get compiledErrorContext() {
    return compileErrorContext(this.errorContext);
  }
};
var constraintKeyParser = (kind) => (schema2, ctx) => {
  if (isArray(schema2)) {
    if (schema2.length === 0) {
      return;
    }
    return schema2.map((schema3) => ctx.$.node(kind, schema3)).sort((l, r) => l.innerHash < r.innerHash ? -1 : 1);
  }
  const child = ctx.$.node(kind, schema2);
  return child.hasOpenIntersection() ? [child] : child;
};
var intersectConstraints = (s) => {
  var _a8;
  const head = s.r.shift();
  if (!head) {
    let result = s.l.length === 0 && s.kind === "structure" ? s.ctx.$.keywords.unknown.raw : s.ctx.$.node(s.kind, Object.assign(s.baseInner, unflattenConstraints(s.l)), { prereduced: true });
    for (const root2 of s.roots) {
      if (result instanceof Disjoint)
        return result;
      result = intersectNodes(root2, result, s.ctx);
    }
    return result;
  }
  let matched = false;
  for (let i = 0; i < s.l.length; i++) {
    const result = intersectNodes(s.l[i], head, s.ctx);
    if (result === null)
      continue;
    if (result instanceof Disjoint)
      return result;
    if (!matched) {
      if (result.isRoot()) {
        s.roots.push(result);
        s.l.splice(i);
        return intersectConstraints(s);
      }
      s.l[i] = result;
      matched = true;
    } else if (!s.l.includes(result)) {
      return throwInternalError(`Unexpectedly encountered multiple distinct intersection results for refinement ${result}`);
    }
  }
  if (!matched)
    s.l.push(head);
  if (s.kind === "intersection")
    (_a8 = head.impliedSiblings) == null ? void 0 : _a8.forEach((node2) => appendUnique(s.r, node2));
  return intersectConstraints(s);
};
var flattenConstraints = (inner) => {
  const result = Object.entries(inner).flatMap(([k, v]) => k in constraintKeys ? v : []).sort((l, r) => l.precedence < r.precedence ? -1 : l.precedence > r.precedence ? 1 : l.innerHash < r.innerHash ? -1 : 1);
  return result;
};
var unflattenConstraints = (constraints) => {
  const inner = {};
  for (const constraint of constraints) {
    if (constraint.hasOpenIntersection()) {
      inner[constraint.kind] = append(inner[constraint.kind], constraint);
    } else {
      if (inner[constraint.kind]) {
        return throwInternalError(`Unexpected intersection of closed refinements of kind ${constraint.kind}`);
      }
      inner[constraint.kind] = constraint;
    }
  }
  return inner;
};
var throwInvalidOperandError = (...args) => throwParseError(writeInvalidOperandMessage(...args));
var writeInvalidOperandMessage = (kind, expected, actual) => `${capitalize(kind)} operand must be ${expected.description} (was ${actual.exclude(expected).description})`;

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/generic.js
var validateUninstantiatedGenericNode = (g) => {
  g.$.schema(g.def, {
    // // TODO: probably don't need raw once this is fixed.
    // args: flatMorph(g.params, (_, name) => [name, g.$.raw.keywords.unknown])
  });
  return g;
};
var _a3, _b3;
var GenericRoot = class extends (_b3 = Callable, _a3 = arkKind, _b3) {
  constructor(params, def, $) {
    super((...args) => {
      args;
      return $.schema(def);
    });
    __publicField(this, "params");
    __publicField(this, "def");
    __publicField(this, "$");
    __publicField(this, _a3, "generic");
    this.params = params;
    this.def = def;
    this.$ = $;
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/predicate.js
var predicateImplementation = implementNode({
  kind: "predicate",
  hasAssociatedError: true,
  collapsibleKey: "predicate",
  keys: {
    predicate: {}
  },
  normalize: (schema2) => typeof schema2 === "function" ? { predicate: schema2 } : schema2,
  defaults: {
    description: (node2) => `valid according to ${node2.predicate.name || "an anonymous predicate"}`
  },
  intersectionIsOpen: true,
  intersections: {
    // TODO: allow changed order to be the same type
    // as long as the narrows in l and r are individually safe to check
    // in the order they're specified, checking them in the order
    // resulting from this intersection should also be safe.
    predicate: () => null
  }
});
var PredicateNode = class extends BaseConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "serializedPredicate", registeredReference(this.predicate));
    __publicField(this, "compiledCondition", `${this.serializedPredicate}(data, ctx)`);
    __publicField(this, "compiledNegation", `!${this.compiledCondition}`);
    __publicField(this, "impliedBasis", null);
    __publicField(this, "expression", this.serializedPredicate);
    __publicField(this, "traverseAllows", this.predicate);
    __publicField(this, "errorContext", {
      code: "predicate",
      description: this.description
    });
    __publicField(this, "compiledErrorContext", `{ code: "predicate", description: "${this.description}" }`);
    __publicField(this, "traverseApply", (data, ctx) => {
      if (!this.predicate(data, ctx) && !ctx.hasError())
        ctx.error(this.errorContext);
    });
  }
  compile(js) {
    if (js.traversalKind === "Allows") {
      js.return(this.compiledCondition);
      return;
    }
    js.if(`${this.compiledNegation} && !ctx.hasError()`, () => js.line(`ctx.error(${this.compiledErrorContext})`));
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/divisor.js
var divisorImplementation = implementNode({
  kind: "divisor",
  collapsibleKey: "rule",
  keys: {
    rule: {}
  },
  normalize: (schema2) => typeof schema2 === "number" ? { rule: schema2 } : schema2,
  hasAssociatedError: true,
  defaults: {
    description: (node2) => node2.rule === 1 ? "an integer" : `a multiple of ${node2.rule}`
  },
  intersections: {
    divisor: (l, r, ctx) => ctx.$.node("divisor", {
      rule: Math.abs(l.rule * r.rule / greatestCommonDivisor(l.rule, r.rule))
    })
  }
});
var DivisorNode = class extends RawPrimitiveConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "traverseAllows", (data) => data % this.rule === 0);
    __publicField(this, "compiledCondition", `data % ${this.rule} === 0`);
    __publicField(this, "compiledNegation", `data % ${this.rule} !== 0`);
    __publicField(this, "impliedBasis", this.$.keywords.number.raw);
    __publicField(this, "expression", `% ${this.rule}`);
  }
};
var greatestCommonDivisor = (l, r) => {
  let previous;
  let greatestCommonDivisor2 = l;
  let current = r;
  while (current !== 0) {
    previous = current;
    current = greatestCommonDivisor2 % current;
    greatestCommonDivisor2 = previous;
  }
  return greatestCommonDivisor2;
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/range.js
var BaseRange = class extends RawPrimitiveConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "boundOperandKind", operandKindsByBoundKind[this.kind]);
    __publicField(this, "compiledActual", this.boundOperandKind === "value" ? `data` : this.boundOperandKind === "length" ? `data.length` : `data.valueOf()`);
    __publicField(this, "comparator", compileComparator(this.kind, this.exclusive));
    __publicField(this, "numericLimit", this.rule.valueOf());
    __publicField(this, "expression", `${this.comparator}${this.rule}`);
    __publicField(this, "compiledCondition", `${this.compiledActual} ${this.comparator} ${this.numericLimit}`);
    __publicField(this, "compiledNegation", `${this.compiledActual} ${negatedComparators[this.comparator]} ${this.numericLimit}`);
    // we need to compute stringLimit before errorContext, which references it
    // transitively through description for date bounds
    __publicField(this, "stringLimit", this.boundOperandKind === "date" ? dateLimitToString(this.numericLimit) : `${this.numericLimit}`);
    __publicField(this, "limitKind", this.comparator["0"] === "<" ? "upper" : "lower");
  }
  isStricterThan(r) {
    const thisLimitIsStricter = this.limitKind === "upper" ? this.numericLimit < r.numericLimit : this.numericLimit > r.numericLimit;
    return thisLimitIsStricter || this.numericLimit === r.numericLimit && this.exclusive === true && !r.exclusive;
  }
  overlapsRange(r) {
    if (this.isStricterThan(r))
      return false;
    if (this.numericLimit === r.numericLimit && (this.exclusive || r.exclusive))
      return false;
    return true;
  }
  overlapIsUnit(r) {
    return this.numericLimit === r.numericLimit && !this.exclusive && !r.exclusive;
  }
};
var negatedComparators = {
  "<": ">=",
  "<=": ">",
  ">": "<=",
  ">=": "<"
};
var boundKindPairsByLower = {
  min: "max",
  minLength: "maxLength",
  after: "before"
};
var parseExclusiveKey = {
  // omit key with value false since it is the default
  parse: (flag) => flag || void 0
};
var parseDateLimit = (limit) => typeof limit === "string" || typeof limit === "number" ? new Date(limit) : limit;
var operandKindsByBoundKind = {
  min: "value",
  max: "value",
  minLength: "length",
  maxLength: "length",
  after: "date",
  before: "date"
};
var compileComparator = (kind, exclusive) => `${isKeyOf(kind, boundKindPairsByLower) ? ">" : "<"}${exclusive ? "" : "="}`;
var dateLimitToString = (limit) => typeof limit === "string" ? limit : new Date(limit).toLocaleString();
var writeUnboundableMessage = (root2) => `Bounded expression ${root2} must be a number, string, Array, or Date`;

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/after.js
var afterImplementation = implementNode({
  kind: "after",
  collapsibleKey: "rule",
  hasAssociatedError: true,
  keys: {
    rule: {
      parse: parseDateLimit,
      serialize: (schema2) => schema2.toISOString()
    },
    exclusive: parseExclusiveKey
  },
  normalize: (schema2) => typeof schema2 === "number" || typeof schema2 === "string" || schema2 instanceof Date ? { rule: schema2 } : schema2,
  defaults: {
    description: (node2) => node2.exclusive ? `after ${node2.stringLimit}` : `${node2.stringLimit} or later`,
    actual: (data) => data.toLocaleString()
  },
  intersections: {
    after: (l, r) => l.isStricterThan(r) ? l : r
  }
});
var AfterNode = class extends BaseRange {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", this.$.keywords.Date.raw);
    __publicField(this, "traverseAllows", this.exclusive ? (data) => data > this.rule : (data) => data >= this.rule);
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/before.js
var beforeImplementation = implementNode({
  kind: "before",
  collapsibleKey: "rule",
  hasAssociatedError: true,
  keys: {
    rule: {
      parse: parseDateLimit,
      serialize: (schema2) => schema2.toISOString()
    },
    exclusive: parseExclusiveKey
  },
  normalize: (schema2) => typeof schema2 === "number" || typeof schema2 === "string" || schema2 instanceof Date ? { rule: schema2 } : schema2,
  defaults: {
    description: (node2) => node2.exclusive ? `before ${node2.stringLimit}` : `${node2.stringLimit} or earlier`,
    actual: (data) => data.toLocaleString()
  },
  intersections: {
    before: (l, r) => l.isStricterThan(r) ? l : r,
    after: (before, after, ctx) => before.overlapsRange(after) ? before.overlapIsUnit(after) ? ctx.$.node("unit", { unit: before.rule }) : null : Disjoint.from("range", before, after)
  }
});
var BeforeNode = class extends BaseRange {
  constructor() {
    super(...arguments);
    __publicField(this, "traverseAllows", this.exclusive ? (data) => data < this.rule : (data) => data <= this.rule);
    __publicField(this, "impliedBasis", this.$.keywords.Date.raw);
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/exactLength.js
var exactLengthImplementation = implementNode({
  kind: "exactLength",
  collapsibleKey: "rule",
  keys: {
    rule: {}
  },
  normalize: (schema2) => typeof schema2 === "number" ? { rule: schema2 } : schema2,
  hasAssociatedError: true,
  defaults: {
    description: (node2) => `exactly length ${node2.rule}`,
    actual: (data) => `${data.length}`
  },
  intersections: {
    exactLength: (l, r, ctx) => new Disjoint({
      '["length"]': {
        unit: {
          l: ctx.$.node("unit", { unit: l.rule }),
          r: ctx.$.node("unit", { unit: r.rule })
        }
      }
    }),
    minLength: (exactLength, minLength) => (minLength.exclusive ? exactLength.rule > minLength.rule : exactLength.rule >= minLength.rule) ? exactLength : Disjoint.from("range", exactLength, minLength),
    maxLength: (exactLength, maxLength) => (maxLength.exclusive ? exactLength.rule < maxLength.rule : exactLength.rule <= maxLength.rule) ? exactLength : Disjoint.from("range", exactLength, maxLength)
  }
});
var ExactLengthNode = class extends RawPrimitiveConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "traverseAllows", (data) => data.length === this.rule);
    __publicField(this, "compiledCondition", `data.length === ${this.rule}`);
    __publicField(this, "compiledNegation", `data.length !== ${this.rule}`);
    __publicField(this, "impliedBasis", this.$.keywords.lengthBoundable.raw);
    __publicField(this, "expression", `{ length: ${this.rule} }`);
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/max.js
var maxImplementation = implementNode({
  kind: "max",
  collapsibleKey: "rule",
  hasAssociatedError: true,
  keys: {
    rule: {},
    exclusive: parseExclusiveKey
  },
  normalize: (schema2) => typeof schema2 === "number" ? { rule: schema2 } : schema2,
  defaults: {
    description: (node2) => `${node2.exclusive ? "less than" : "at most"} ${node2.rule}`
  },
  intersections: {
    max: (l, r) => l.isStricterThan(r) ? l : r,
    min: (max, min, ctx) => max.overlapsRange(min) ? max.overlapIsUnit(min) ? ctx.$.node("unit", { unit: max.rule }) : null : Disjoint.from("range", max, min)
  }
});
var MaxNode = class extends BaseRange {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", this.$.keywords.number.raw);
    __publicField(this, "traverseAllows", this.exclusive ? (data) => data < this.rule : (data) => data <= this.rule);
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/maxLength.js
var maxLengthImplementation = implementNode({
  kind: "maxLength",
  collapsibleKey: "rule",
  hasAssociatedError: true,
  keys: {
    rule: {},
    exclusive: parseExclusiveKey
  },
  normalize: (schema2) => typeof schema2 === "number" ? { rule: schema2 } : schema2,
  defaults: {
    description: (node2) => node2.exclusive ? `less than length ${node2.rule}` : `at most length ${node2.rule}`,
    actual: (data) => `${data.length}`
  },
  intersections: {
    maxLength: (l, r) => l.isStricterThan(r) ? l : r,
    minLength: (max, min, ctx) => max.overlapsRange(min) ? max.overlapIsUnit(min) ? ctx.$.node("exactLength", { rule: max.rule }) : null : Disjoint.from("range", max, min)
  }
});
var MaxLengthNode = class extends BaseRange {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", this.$.keywords.lengthBoundable.raw);
    __publicField(this, "traverseAllows", this.exclusive ? (data) => data.length < this.rule : (data) => data.length <= this.rule);
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/min.js
var minImplementation = implementNode({
  kind: "min",
  collapsibleKey: "rule",
  hasAssociatedError: true,
  keys: {
    rule: {},
    exclusive: parseExclusiveKey
  },
  normalize: (schema2) => typeof schema2 === "number" ? { rule: schema2 } : schema2,
  defaults: {
    description: (node2) => `${node2.exclusive ? "more than" : "at least"} ${node2.rule}`
  },
  intersections: {
    min: (l, r) => l.isStricterThan(r) ? l : r
  }
});
var MinNode = class extends BaseRange {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", this.$.keywords.number.raw);
    __publicField(this, "traverseAllows", this.exclusive ? (data) => data > this.rule : (data) => data >= this.rule);
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/minLength.js
var minLengthImplementation = implementNode({
  kind: "minLength",
  collapsibleKey: "rule",
  hasAssociatedError: true,
  keys: {
    rule: {},
    exclusive: parseExclusiveKey
  },
  normalize: (schema2) => typeof schema2 === "number" ? { rule: schema2 } : schema2,
  defaults: {
    description: (node2) => node2.exclusive ? node2.rule === 0 ? "non-empty" : `more than length ${node2.rule}` : node2.rule === 1 ? "non-empty" : `at least length ${node2.rule}`,
    actual: (data) => `${data.length}`
  },
  intersections: {
    minLength: (l, r) => l.isStricterThan(r) ? l : r
  }
});
var MinLengthNode = class extends BaseRange {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", this.$.keywords.lengthBoundable.raw);
    __publicField(this, "traverseAllows", this.exclusive ? (data) => data.length > this.rule : (data) => data.length >= this.rule);
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/kinds.js
var boundImplementationsByKind = {
  min: minImplementation,
  max: maxImplementation,
  minLength: minLengthImplementation,
  maxLength: maxLengthImplementation,
  exactLength: exactLengthImplementation,
  after: afterImplementation,
  before: beforeImplementation
};
var boundClassesByKind = {
  min: MinNode,
  max: MaxNode,
  minLength: MinLengthNode,
  maxLength: MaxLengthNode,
  exactLength: ExactLengthNode,
  after: AfterNode,
  before: BeforeNode
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/regex.js
var regexImplementation = implementNode({
  kind: "regex",
  collapsibleKey: "rule",
  keys: {
    rule: {},
    flags: {}
  },
  normalize: (schema2) => typeof schema2 === "string" ? { rule: schema2 } : schema2 instanceof RegExp ? schema2.flags ? { rule: schema2.source, flags: schema2.flags } : { rule: schema2.source } : schema2,
  hasAssociatedError: true,
  intersectionIsOpen: true,
  defaults: {
    description: (node2) => `matched by ${node2.rule}`
  },
  intersections: {
    // for now, non-equal regex are naively intersected:
    // https://github.com/arktypeio/arktype/issues/853
    regex: () => null
  }
});
var RegexNode = class extends RawPrimitiveConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "instance", new RegExp(this.rule, this.flags));
    __publicField(this, "expression", `${this.instance}`);
    __publicField(this, "traverseAllows", this.instance.test.bind(this.instance));
    __publicField(this, "compiledCondition", `${this.expression}.test(data)`);
    __publicField(this, "compiledNegation", `!${this.compiledCondition}`);
    __publicField(this, "impliedBasis", this.$.keywords.string.raw);
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/root.js
var _a4, _b4;
var BaseRoot = class extends (_b4 = BaseNode, _a4 = arkKind, _b4) {
  constructor() {
    super(...arguments);
    __publicField(this, "branches", this.hasKind("union") ? this.inner.branches : [this]);
    __publicField(this, _a4, "root");
    __publicField(this, "_keyof");
  }
  get raw() {
    return this;
  }
  keyof() {
    if (!this._keyof) {
      this._keyof = this.rawKeyOf();
      if (this._keyof.branches.length === 0) {
        throwParseError(`keyof ${this.expression} results in an unsatisfiable type`);
      }
    }
    return this._keyof;
  }
  intersect(r) {
    const rNode = this.$.parseRoot(r);
    return intersectNodesRoot(this, rNode, this.$);
  }
  and(r) {
    const result = this.intersect(r);
    return result instanceof Disjoint ? result.throw() : result;
  }
  or(r) {
    const rNode = this.$.parseRoot(r);
    const branches = [...this.branches, ...rNode.branches];
    return this.$.schema(branches);
  }
  assert(data) {
    const result = this.traverse(data);
    return result instanceof ArkErrors ? result.throw() : result;
  }
  // get<key extends PropertyKey>(
  // 	...path: readonly (key | Root<key>)[]
  // ): this {
  // 	return this
  // }
  extract(r) {
    const rNode = this.$.parseRoot(r);
    return this.$.schema(this.branches.filter((branch) => branch.extends(rNode)));
  }
  exclude(r) {
    const rNode = this.$.parseRoot(r);
    return this.$.schema(this.branches.filter((branch) => !branch.extends(rNode)));
  }
  array() {
    return this.$.schema({
      proto: Array,
      sequence: this
    }, { prereduced: true });
  }
  overlaps(r) {
    const intersection = this.intersect(r);
    return !(intersection instanceof Disjoint);
  }
  extends(r) {
    const intersection = this.intersect(r);
    return !(intersection instanceof Disjoint) && this.equals(intersection);
  }
  subsumes(r) {
    return r.extends(this);
  }
  configure(configOrDescription) {
    return this.configureShallowDescendants(configOrDescription);
  }
  describe(description) {
    return this.configure(description);
  }
  from(input) {
    return this.assert(input);
  }
  pipe(...morphs) {
    return morphs.reduce((acc, morph) => acc.pipeOnce(morph), this);
  }
  pipeOnce(morph) {
    if (hasArkKind(morph, "root")) {
      const result = pipeNodesRoot(this, morph, this.$);
      if (result instanceof Disjoint)
        return result.throw();
      return result;
    }
    if (this.hasKind("union")) {
      const branches = this.branches.map((node2) => node2.pipe(morph));
      return this.$.node("union", { ...this.inner, branches });
    }
    if (this.hasKind("morph")) {
      return this.$.node("morph", {
        ...this.inner,
        morphs: [...this.morphs, morph]
      });
    }
    return this.$.node("morph", {
      in: this,
      morphs: [morph]
    });
  }
  narrow(predicate) {
    return this.constrainOut("predicate", predicate);
  }
  constrain(kind, schema2) {
    return this._constrain("in", kind, schema2);
  }
  constrainOut(kind, schema2) {
    return this._constrain("out", kind, schema2);
  }
  _constrain(io, kind, schema2) {
    const constraint = this.$.node(kind, schema2);
    if (constraint.impliedBasis && !this[io].extends(constraint.impliedBasis)) {
      return throwInvalidOperandError(kind, constraint.impliedBasis, this);
    }
    const partialIntersection = this.$.node("intersection", {
      [kind]: constraint
    });
    const result = io === "in" ? intersectNodesRoot(this, partialIntersection, this.$) : pipeNodesRoot(this, partialIntersection, this.$);
    if (result instanceof Disjoint)
      result.throw();
    return result;
  }
  onUndeclaredKey(undeclared) {
    return this.transform((kind, inner) => kind === "structure" ? undeclared === "ignore" ? omit(inner, { undeclared: 1 }) : { ...inner, undeclared } : inner, { shouldTransform: (node2) => !includes(structuralKinds, node2.kind) });
  }
  satisfying(predicate) {
    return this.constrain("predicate", predicate);
  }
  divisibleBy(schema2) {
    return this.constrain("divisor", schema2);
  }
  matching(schema2) {
    return this.constrain("regex", schema2);
  }
  atLeast(schema2) {
    return this.constrain("min", schema2);
  }
  atMost(schema2) {
    return this.constrain("max", schema2);
  }
  moreThan(schema2) {
    return this.constrain("min", exclusivizeRangeSchema(schema2));
  }
  lessThan(schema2) {
    return this.constrain("max", exclusivizeRangeSchema(schema2));
  }
  atLeastLength(schema2) {
    return this.constrain("minLength", schema2);
  }
  atMostLength(schema2) {
    return this.constrain("maxLength", schema2);
  }
  moreThanLength(schema2) {
    return this.constrain("minLength", exclusivizeRangeSchema(schema2));
  }
  lessThanLength(schema2) {
    return this.constrain("maxLength", exclusivizeRangeSchema(schema2));
  }
  exactlyLength(schema2) {
    return this.constrain("exactLength", schema2);
  }
  atOrAfter(schema2) {
    return this.constrain("after", schema2);
  }
  atOrBefore(schema2) {
    return this.constrain("before", schema2);
  }
  laterThan(schema2) {
    return this.constrain("after", exclusivizeRangeSchema(schema2));
  }
  earlierThan(schema2) {
    return this.constrain("before", exclusivizeRangeSchema(schema2));
  }
};
var exclusivizeRangeSchema = (schema2) => typeof schema2 === "object" && !(schema2 instanceof Date) ? { ...schema2, exclusive: true } : {
  rule: schema2,
  exclusive: true
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/utils.js
var defineRightwardIntersections = (kind, implementation) => flatMorph(schemaKindsRightOf(kind), (i, kind2) => [
  kind2,
  implementation
]);

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/alias.js
var __runInitializers = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var AliasNode = (() => {
  var _a8;
  let _classSuper = BaseRoot;
  let _instanceExtraInitializers = [];
  let _get_resolution_decorators;
  return _a8 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __publicField(this, "expression", (__runInitializers(this, _instanceExtraInitializers), this.alias));
      __publicField(this, "traverseAllows", (data, ctx) => {
        const seen = ctx.seen[this.id];
        if (seen == null ? void 0 : seen.includes(data))
          return true;
        ctx.seen[this.id] = append(seen, data);
        return this.resolution.traverseAllows(data, ctx);
      });
      __publicField(this, "traverseApply", (data, ctx) => {
        const seen = ctx.seen[this.id];
        if (seen == null ? void 0 : seen.includes(data))
          return;
        ctx.seen[this.id] = append(seen, data);
        this.resolution.traverseApply(data, ctx);
      });
    }
    get resolution() {
      var _a9;
      return ((_a9 = this.resolve) == null ? void 0 : _a9.call(this)) ?? this.$.resolveRoot(this.alias);
    }
    rawKeyOf() {
      return this.resolution.keyof();
    }
    compile(js) {
      js.if(`ctx.seen.${this.id}?.includes(data)`, () => js.return(true));
      js.line(`ctx.seen.${this.id} ??= []`).line(`ctx.seen.${this.id}.push(data)`);
      js.return(js.invoke(this.resolution));
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _get_resolution_decorators = [cached];
    __esDecorate(_a8, null, _get_resolution_decorators, { kind: "getter", name: "resolution", static: false, private: false, access: { has: (obj) => "resolution" in obj, get: (obj) => obj.resolution }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_a8, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a8;
})();
var normalizeAliasSchema = (schema2) => typeof schema2 === "string" ? { alias: schema2.slice(1) } : schema2;
var aliasImplementation = implementNode({
  kind: "alias",
  hasAssociatedError: false,
  collapsibleKey: "alias",
  keys: {
    alias: {
      serialize: (schema2) => `$${schema2}`
    },
    resolve: {}
  },
  normalize: normalizeAliasSchema,
  defaults: {
    description: (node2) => node2.alias
  },
  intersections: {
    alias: (l, r, ctx) => ctx.$.lazilyResolve(() => neverIfDisjoint(intersectNodes(l.resolution, r.resolution, ctx), ctx.$), `${l.alias}${ctx.pipe ? "|>" : "&"}${r.alias}`),
    ...defineRightwardIntersections("alias", (l, r, ctx) => ctx.$.lazilyResolve(() => neverIfDisjoint(intersectNodes(l.resolution, r, ctx), ctx.$), `${l.alias}${ctx.pipe ? "|>" : "&"}${r.alias}`))
  }
});
var neverIfDisjoint = (result, $) => result instanceof Disjoint ? $.keywords.never.raw : result;

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/basis.js
var RawBasis = class extends BaseRoot {
  constructor() {
    super(...arguments);
    __publicField(this, "traverseApply", (data, ctx) => {
      if (!this.traverseAllows(data, ctx))
        ctx.error(this.errorContext);
    });
  }
  rawKeyOf() {
    return this.$.units(this.literalKeys);
  }
  get errorContext() {
    return { code: this.kind, description: this.description, ...this.inner };
  }
  get compiledErrorContext() {
    return compileErrorContext(this.errorContext);
  }
  compile(js) {
    if (js.traversalKind === "Allows")
      js.return(this.compiledCondition);
    else {
      js.if(this.compiledNegation, () => js.line(`${js.ctx}.error(${this.compiledErrorContext})`));
    }
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/domain.js
var DomainNode = class extends RawBasis {
  constructor() {
    super(...arguments);
    __publicField(this, "traverseAllows", (data) => domainOf(data) === this.domain);
    __publicField(this, "compiledCondition", this.domain === "object" ? `((typeof data === "object" && data !== null) || typeof data === "function")` : `typeof data === "${this.domain}"`);
    __publicField(this, "compiledNegation", this.domain === "object" ? `((typeof data !== "object" || data === null) && typeof data !== "function")` : `typeof data !== "${this.domain}"`);
    __publicField(this, "expression", this.domain);
    __publicField(this, "literalKeys", getBaseDomainKeys(this.domain));
  }
};
var domainImplementation = implementNode({
  kind: "domain",
  hasAssociatedError: true,
  collapsibleKey: "domain",
  keys: {
    domain: {}
  },
  normalize: (schema2) => typeof schema2 === "string" ? { domain: schema2 } : schema2,
  defaults: {
    description: (node2) => domainDescriptions[node2.domain],
    actual: (data) => typeof data === "boolean" ? `${data}` : domainOf(data)
  },
  intersections: {
    domain: (l, r) => Disjoint.from("domain", l, r)
  }
});

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/declare.js
var metaKeys = { description: 1 };

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/intersection.js
var _a5;
var IntersectionNode = class extends BaseRoot {
  constructor() {
    super(...arguments);
    __publicField(this, "basis", this.domain ?? this.proto ?? null);
    __publicField(this, "refinements", this.children.filter((node2) => node2.isRefinement()));
    __publicField(this, "expression", ((_a5 = this.structure) == null ? void 0 : _a5.expression) || this.children.map((node2) => node2.nestableExpression).join(" & ") || "unknown");
    __publicField(this, "traverseAllows", (data, ctx) => this.children.every((child) => child.traverseAllows(data, ctx)));
    __publicField(this, "traverseApply", (data, ctx) => {
      const errorCount = ctx.currentErrorCount;
      if (this.basis) {
        this.basis.traverseApply(data, ctx);
        if (ctx.currentErrorCount > errorCount)
          return;
      }
      if (this.refinements.length) {
        for (let i = 0; i < this.refinements.length - 1; i++) {
          this.refinements[i].traverseApply(data, ctx);
          if (ctx.failFast && ctx.currentErrorCount > errorCount)
            return;
        }
        this.refinements.at(-1).traverseApply(data, ctx);
        if (ctx.currentErrorCount > errorCount)
          return;
      }
      if (this.structure) {
        this.structure.traverseApply(data, ctx);
        if (ctx.currentErrorCount > errorCount)
          return;
      }
      if (this.predicate) {
        for (let i = 0; i < this.predicate.length - 1; i++) {
          this.predicate[i].traverseApply(data, ctx);
          if (ctx.failFast && ctx.currentErrorCount > errorCount)
            return;
        }
        this.predicate.at(-1).traverseApply(data, ctx);
      }
    });
  }
  compile(js) {
    if (js.traversalKind === "Allows") {
      this.children.forEach((child) => js.check(child));
      js.return(true);
      return;
    }
    js.initializeErrorCount();
    if (this.basis) {
      js.check(this.basis);
      if (this.children.length > 1)
        js.returnIfFail();
    }
    if (this.refinements.length) {
      for (let i = 0; i < this.refinements.length - 1; i++) {
        js.check(this.refinements[i]);
        js.returnIfFailFast();
      }
      js.check(this.refinements.at(-1));
      if (this.structure || this.predicate)
        js.returnIfFail();
    }
    if (this.structure) {
      js.check(this.structure);
      if (this.predicate)
        js.returnIfFail();
    }
    if (this.predicate) {
      for (let i = 0; i < this.predicate.length - 1; i++) {
        js.check(this.predicate[i]);
        js.returnIfFail();
      }
      js.check(this.predicate.at(-1));
    }
  }
  rawKeyOf() {
    var _a8;
    return this.basis ? this.structure ? this.basis.rawKeyOf().or(this.structure.keyof()) : this.basis.rawKeyOf() : ((_a8 = this.structure) == null ? void 0 : _a8.keyof()) ?? this.$.keywords.never.raw;
  }
};
var intersectIntersections = (l, r, ctx) => {
  if (hasArkKind(l, "root") && l.hasKind("intersection"))
    return intersectIntersections(l.inner, r, ctx);
  if (hasArkKind(r, "root") && r.hasKind("intersection"))
    return intersectIntersections(l, r.inner, ctx);
  const baseInner = isEmptyObject(l) ? pick(r, metaKeys) : {};
  const lBasis = l.proto ?? l.domain;
  const rBasis = r.proto ?? r.domain;
  const basisResult = lBasis ? rBasis ? intersectNodes(lBasis, rBasis, ctx) : lBasis : rBasis;
  if (basisResult instanceof Disjoint)
    return basisResult;
  if (basisResult)
    baseInner[basisResult.kind] = basisResult;
  return intersectConstraints({
    kind: "intersection",
    baseInner,
    l: flattenConstraints(l),
    r: flattenConstraints(r),
    roots: [],
    ctx
  });
};
var intersectionImplementation = implementNode({
  kind: "intersection",
  hasAssociatedError: true,
  normalize: (rawSchema2) => {
    if (isNode(rawSchema2))
      return rawSchema2;
    const { structure, ...schema2 } = rawSchema2;
    const hasRootStructureKey = !!structure;
    const normalizedStructure = structure ?? {};
    const normalized = flatMorph(schema2, (k, v) => {
      if (isKeyOf(k, structureKeys)) {
        if (hasRootStructureKey) {
          throwParseError(`Flattened structure key ${k} cannot be specified alongside a root 'structure' key.`);
        }
        normalizedStructure[k] = v;
        return [];
      }
      return [k, v];
    });
    if (!isEmptyObject(normalizedStructure))
      normalized.structure = normalizedStructure;
    return normalized;
  },
  finalizeJson: ({ structure, ...rest }) => hasDomain(structure, "object") ? { ...structure, ...rest } : rest,
  keys: {
    domain: {
      child: true,
      parse: (schema2, ctx) => ctx.$.node("domain", schema2)
    },
    proto: {
      child: true,
      parse: (schema2, ctx) => ctx.$.node("proto", schema2)
    },
    structure: {
      child: true,
      parse: (schema2, ctx) => ctx.$.node("structure", schema2),
      serialize: (node2) => {
        var _a8;
        if (!((_a8 = node2.sequence) == null ? void 0 : _a8.minLength))
          return node2.collapsibleJson;
        const { sequence, ...structureJson } = node2.collapsibleJson;
        const { minVariadicLength, ...sequenceJson } = sequence;
        const collapsibleSequenceJson = sequenceJson.variadic && Object.keys(sequenceJson).length === 1 ? sequenceJson.variadic : sequenceJson;
        return { ...structureJson, sequence: collapsibleSequenceJson };
      }
    },
    divisor: {
      child: true,
      parse: constraintKeyParser("divisor")
    },
    max: {
      child: true,
      parse: constraintKeyParser("max")
    },
    min: {
      child: true,
      parse: constraintKeyParser("min")
    },
    maxLength: {
      child: true,
      parse: constraintKeyParser("maxLength")
    },
    minLength: {
      child: true,
      parse: constraintKeyParser("minLength")
    },
    exactLength: {
      child: true,
      parse: constraintKeyParser("exactLength")
    },
    before: {
      child: true,
      parse: constraintKeyParser("before")
    },
    after: {
      child: true,
      parse: constraintKeyParser("after")
    },
    regex: {
      child: true,
      parse: constraintKeyParser("regex")
    },
    predicate: {
      child: true,
      parse: constraintKeyParser("predicate")
    }
  },
  // leverage reduction logic from intersection and identity to ensure initial
  // parse result is reduced
  reduce: (inner, $) => (
    // we cast union out of the result here since that only occurs when intersecting two sequences
    // that cannot occur when reducing a single intersection schema using unknown
    intersectIntersections({}, inner, {
      $,
      invert: false,
      pipe: false
    })
  ),
  defaults: {
    description: (node2) => {
      var _a8;
      return node2.children.length === 0 ? "unknown" : ((_a8 = node2.structure) == null ? void 0 : _a8.description) ?? node2.children.map((child) => child.description).join(" and ");
    },
    expected: (source) => `  • ${source.errors.map((e) => e.expected).join("\n  • ")}`,
    problem: (ctx) => `${ctx.actual} must be...
${ctx.expected}`
  },
  intersections: {
    intersection: (l, r, ctx) => intersectIntersections(l, r, ctx),
    ...defineRightwardIntersections("intersection", (l, r, ctx) => {
      var _a8;
      if (l.children.length === 0)
        return r;
      const basis = l.basis ? intersectNodes(l.basis, r, ctx) : r;
      return basis instanceof Disjoint ? basis : ((_a8 = l == null ? void 0 : l.basis) == null ? void 0 : _a8.equals(basis)) ? (
        // if the basis doesn't change, return the original intesection
        l
      ) : l.$.node("intersection", Object.assign(omit(l.inner, metaKeys), {
        [basis.kind]: basis
      }), { prereduced: true });
    })
  }
});

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/morph.js
var morphInputKinds = [
  "intersection",
  "unit",
  "domain",
  "proto"
];
var morphImplementation = implementNode({
  kind: "morph",
  hasAssociatedError: false,
  keys: {
    in: {
      child: true,
      parse: (schema2, ctx) => ctx.$.node(morphInputKinds, schema2)
    },
    morphs: {
      parse: arrayFrom,
      serialize: (morphs) => morphs.map((m) => hasArkKind(m, "root") ? m.json : registeredReference(m))
    }
  },
  normalize: (schema2) => schema2,
  defaults: {
    description: (node2) => {
      var _a8;
      return `a morph from ${node2.in.description} to ${((_a8 = node2.out) == null ? void 0 : _a8.description) ?? "unknown"}`;
    }
  },
  intersections: {
    morph: (l, r, ctx) => {
      if (l.morphs.some((morph, i) => morph !== r.morphs[i]))
        return throwParseError("Invalid intersection of morphs");
      const inTersection = intersectNodes(l.in, r.in, ctx);
      if (inTersection instanceof Disjoint)
        return inTersection;
      return ctx.$.schema(inTersection.branches.map((inBranch) => ctx.$.node("morph", {
        morphs: l.morphs,
        in: inBranch
      })));
    },
    ...defineRightwardIntersections("morph", (l, r, ctx) => {
      const inTersection = intersectNodes(l.in, r, ctx);
      return inTersection instanceof Disjoint ? inTersection : inTersection.kind === "union" ? ctx.$.node("union", inTersection.branches.map((branch) => ({
        ...l.inner,
        in: branch
      }))) : ctx.$.node("morph", {
        ...l.inner,
        in: inTersection
      });
    })
  }
});
var _a6;
var MorphNode = class extends BaseRoot {
  constructor() {
    super(...arguments);
    __publicField(this, "serializedMorphs", this.morphs.map(registeredReference));
    __publicField(this, "compiledMorphs", `[${this.serializedMorphs}]`);
    __publicField(this, "traverseAllows", (data, ctx) => this.in.traverseAllows(data, ctx));
    __publicField(this, "traverseApply", (data, ctx) => {
      this.in.traverseApply(data, ctx);
      ctx.queueMorphs(this.morphs);
    });
    __publicField(this, "expression", `(In: ${this.in.expression}) => Out<${((_a6 = this.out) == null ? void 0 : _a6.expression) ?? "unknown"}>`);
    __publicField(this, "lastMorph", this.inner.morphs.at(-1));
    __publicField(this, "validatedOut", hasArkKind(this.lastMorph, "root") ? Object.assign(this.referencesById, this.lastMorph.out.referencesById) && this.lastMorph.out : void 0);
  }
  compile(js) {
    if (js.traversalKind === "Allows") {
      js.return(js.invoke(this.in));
      return;
    }
    js.line(js.invoke(this.in));
    js.line(`ctx.queueMorphs(${this.compiledMorphs})`);
  }
  get in() {
    return this.inner.in;
  }
  get out() {
    return this.validatedOut ?? this.$.keywords.unknown.raw;
  }
  rawKeyOf() {
    return this.in.rawKeyOf();
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/proto.js
var protoImplementation = implementNode({
  kind: "proto",
  hasAssociatedError: true,
  collapsibleKey: "proto",
  keys: {
    proto: {
      serialize: (ctor) => getExactBuiltinConstructorName(ctor) ?? defaultValueSerializer(ctor)
    }
  },
  normalize: (schema2) => typeof schema2 === "string" ? { proto: builtinConstructors[schema2] } : typeof schema2 === "function" ? { proto: schema2 } : typeof schema2.proto === "string" ? { ...schema2, proto: builtinConstructors[schema2.proto] } : schema2,
  defaults: {
    description: (node2) => node2.builtinName ? objectKindDescriptions[node2.builtinName] : `an instance of ${node2.proto.name}`,
    actual: (data) => objectKindOrDomainOf(data)
  },
  intersections: {
    proto: (l, r) => constructorExtends(l.proto, r.proto) ? l : constructorExtends(r.proto, l.proto) ? r : Disjoint.from("proto", l, r),
    domain: (proto, domain, ctx) => domain.domain === "object" ? proto : Disjoint.from("domain", ctx.$.keywords.object.raw, domain)
  }
});
var ProtoNode = class extends RawBasis {
  constructor() {
    super(...arguments);
    __publicField(this, "builtinName", getExactBuiltinConstructorName(this.proto));
    __publicField(this, "serializedConstructor", this.json.proto);
    __publicField(this, "compiledCondition", `data instanceof ${this.serializedConstructor}`);
    __publicField(this, "compiledNegation", `!(${this.compiledCondition})`);
    __publicField(this, "literalKeys", prototypeKeysOf(this.proto.prototype));
    __publicField(this, "traverseAllows", (data) => data instanceof this.proto);
    __publicField(this, "expression", this.proto.name);
    __publicField(this, "domain", "object");
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/union.js
var __runInitializers2 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var unionChildKinds = [
  ...schemaKindsRightOf("union"),
  "alias"
];
var unionImplementation = implementNode({
  kind: "union",
  hasAssociatedError: true,
  collapsibleKey: "branches",
  keys: {
    ordered: {},
    branches: {
      child: true,
      parse: (schema2, ctx) => {
        const branches = schema2.map((branch) => ctx.$.node(unionChildKinds, branch));
        if (!ctx.schema.ordered)
          branches.sort((l, r) => l.innerHash < r.innerHash ? -1 : 1);
        return branches;
      }
    }
  },
  normalize: (schema2) => isArray(schema2) ? { branches: schema2 } : schema2,
  reduce: (inner, $) => {
    const reducedBranches = reduceBranches(inner);
    if (reducedBranches.length === 1)
      return reducedBranches[0];
    if (reducedBranches.length === inner.branches.length)
      return;
    return $.node("union", {
      ...inner,
      branches: reducedBranches
    }, { prereduced: true });
  },
  defaults: {
    description: (node2) => describeBranches(node2.branches.map((branch) => branch.description)),
    expected: (ctx) => {
      const byPath = groupBy(ctx.errors, "propString");
      const pathDescriptions = Object.entries(byPath).map(([path, errors]) => {
        const branchesAtPath = [];
        errors.forEach((errorAtPath) => (
          // avoid duplicate messages when multiple branches
          // are invalid due to the same error
          appendUnique(branchesAtPath, errorAtPath.expected)
        ));
        const expected = describeBranches(branchesAtPath);
        const actual = errors.every((e) => e.actual === errors[0].actual) ? errors[0].actual : printable(errors[0].data);
        return `${path && `${path} `}must be ${expected}${actual && ` (was ${actual})`}`;
      });
      return describeBranches(pathDescriptions);
    },
    problem: (ctx) => ctx.expected,
    message: (ctx) => ctx.problem
  },
  intersections: {
    union: (l, r, ctx) => {
      if (l.isNever !== r.isNever) {
        return Disjoint.from("presence", l, r);
      }
      let resultBranches;
      if (l.ordered) {
        if (r.ordered)
          return Disjoint.from("indiscriminableMorphs", l, r);
        resultBranches = intersectBranches(r.branches, l.branches, ctx);
        if (resultBranches instanceof Disjoint)
          resultBranches.invert();
      } else
        resultBranches = intersectBranches(l.branches, r.branches, ctx);
      if (resultBranches instanceof Disjoint)
        return resultBranches;
      return ctx.$.schema(l.ordered || r.ordered ? {
        branches: resultBranches,
        ordered: true
      } : { branches: resultBranches });
    },
    ...defineRightwardIntersections("union", (l, r, ctx) => {
      const branches = intersectBranches(l.branches, [r], ctx);
      if (branches instanceof Disjoint)
        return branches;
      if (branches.length === 1)
        return branches[0];
      return ctx.$.schema(l.ordered ? { branches, ordered: true } : { branches });
    })
  }
});
var UnionNode = (() => {
  var _a8;
  let _classSuper = BaseRoot;
  let _instanceExtraInitializers = [];
  let _discriminate_decorators;
  return _a8 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __publicField(this, "isNever", (__runInitializers2(this, _instanceExtraInitializers), this.branches.length === 0));
      __publicField(this, "isBoolean", this.branches.length === 2 && this.branches[0].hasUnit(false) && this.branches[1].hasUnit(true));
      __publicField(this, "unitBranches", this.branches.filter((n) => n.hasKind("unit")));
      __publicField(this, "discriminant", this.discriminate());
      __publicField(this, "discriminantJson", this.discriminant ? discriminantToJson(this.discriminant) : null);
      __publicField(this, "expression", this.isNever ? "never" : this.isBoolean ? "boolean" : this.branches.map((branch) => branch.nestableExpression).join(" | "));
      __publicField(this, "traverseAllows", (data, ctx) => this.branches.some((b) => b.traverseAllows(data, ctx)));
      __publicField(this, "traverseApply", (data, ctx) => {
        const errors = [];
        for (let i = 0; i < this.branches.length; i++) {
          ctx.pushBranch();
          this.branches[i].traverseApply(data, ctx);
          if (!ctx.hasError())
            return ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs);
          errors.push(ctx.popBranch().error);
        }
        ctx.error({ code: "union", errors });
      });
    }
    compile(js) {
      if (!this.discriminant || // if we have a union of two units like `boolean`, the
      // undiscriminated compilation will be just as fast
      this.unitBranches.length === this.branches.length && this.branches.length === 2)
        return this.compileIndiscriminable(js);
      const condition = this.discriminant.path.reduce((acc, segment) => acc + compileLiteralPropAccess(segment, true), this.discriminant.kind === "domain" ? "typeof data" : "data");
      const cases = this.discriminant.cases;
      const caseKeys = Object.keys(cases);
      js.block(`switch(${condition})`, () => {
        for (const k in cases) {
          const v = cases[k];
          const caseCondition = k === "default" ? "default" : `case ${k}`;
          js.line(`${caseCondition}: return ${v === true ? v : js.invoke(v)}`);
        }
        return js;
      });
      if (js.traversalKind === "Allows") {
        js.return(false);
        return;
      }
      const expected = describeBranches(this.discriminant.kind === "domain" ? caseKeys.map((k) => domainDescriptions[k.slice(1, -1)]) : caseKeys);
      js.line(`ctx.error({
	expected: ${JSON.stringify(expected)},
	actual: ${condition},
	relativePath: ${JSON.stringify(this.discriminant.path)}
})`);
    }
    compileIndiscriminable(js) {
      if (js.traversalKind === "Apply") {
        js.const("errors", "[]");
        this.branches.forEach((branch) => js.line("ctx.pushBranch()").line(js.invoke(branch)).if("!ctx.hasError()", () => js.return("ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs)")).line("errors.push(ctx.popBranch().error)"));
        js.line(`ctx.error({ code: "union", errors })`);
      } else {
        this.branches.forEach((branch) => js.if(`${js.invoke(branch)}`, () => js.return(true)));
        js.return(false);
      }
    }
    rawKeyOf() {
      return this.branches.reduce((result, branch) => result.and(branch.rawKeyOf()), this.$.keywords.unknown.raw);
    }
    get nestableExpression() {
      return this.isBoolean ? "boolean" : super.nestableExpression;
    }
    discriminate() {
      if (this.branches.length < 2)
        return null;
      if (this.unitBranches.length === this.branches.length) {
        const cases2 = flatMorph(this.unitBranches, (i, unit) => [
          `${unit.serializedValue}`,
          true
        ]);
        return {
          path: [],
          kind: "unit",
          cases: cases2
        };
      }
      const casesBySpecifier = {};
      for (let lIndex = 0; lIndex < this.branches.length - 1; lIndex++) {
        const l = this.branches[lIndex];
        for (let rIndex = lIndex + 1; rIndex < this.branches.length; rIndex++) {
          const r = this.branches[rIndex];
          const result = intersectNodesRoot(l.in, r.in, l.$);
          if (!(result instanceof Disjoint))
            continue;
          for (const { path: path2, kind: kind2, disjoint } of result.flat) {
            if (!isKeyOf(kind2, discriminantKinds))
              continue;
            const qualifiedDiscriminant = `${path2}${kind2}`;
            let lSerialized;
            let rSerialized;
            if (kind2 === "domain") {
              lSerialized = `"${disjoint.l.domain}"`;
              rSerialized = `"${disjoint.r.domain}"`;
            } else if (kind2 === "unit") {
              lSerialized = disjoint.l.serializedValue;
              rSerialized = disjoint.r.serializedValue;
            } else {
              return throwInternalError(`Unexpected attempt to discriminate disjoint kind '${kind2}'`);
            }
            if (!casesBySpecifier[qualifiedDiscriminant]) {
              casesBySpecifier[qualifiedDiscriminant] = {
                [lSerialized]: [l],
                [rSerialized]: [r]
              };
              continue;
            }
            const cases2 = casesBySpecifier[qualifiedDiscriminant];
            if (!isKeyOf(lSerialized, cases2))
              cases2[lSerialized] = [l];
            else if (!cases2[lSerialized].includes(l))
              cases2[lSerialized].push(l);
            if (!isKeyOf(rSerialized, cases2))
              cases2[rSerialized] = [r];
            else if (!cases2[rSerialized].includes(r))
              cases2[rSerialized].push(r);
          }
        }
      }
      const bestDiscriminantEntry = entriesOf(casesBySpecifier).sort((a, b) => Object.keys(a[1]).length - Object.keys(b[1]).length).at(-1);
      if (!bestDiscriminantEntry)
        return null;
      const [specifier, bestCases] = bestDiscriminantEntry;
      const [path, kind] = parseDiscriminantKey(specifier);
      let defaultBranches = [...this.branches];
      const cases = flatMorph(bestCases, (k, caseBranches) => {
        const prunedBranches = [];
        defaultBranches = defaultBranches.filter((n) => !caseBranches.includes(n));
        for (const branch of caseBranches) {
          const pruned = pruneDiscriminant(kind, path, branch);
          if (pruned === null)
            return [k, true];
          prunedBranches.push(pruned);
        }
        const caseNode = prunedBranches.length === 1 ? prunedBranches[0] : this.$.node("union", prunedBranches);
        Object.assign(this.referencesById, caseNode.referencesById);
        return [k, caseNode];
      });
      if (defaultBranches.length) {
        cases.default = this.$.node("union", defaultBranches, {
          prereduced: true
        });
        Object.assign(this.referencesById, cases.default.referencesById);
      }
      return {
        kind,
        path,
        cases
      };
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _discriminate_decorators = [cached];
    __esDecorate2(_a8, null, _discriminate_decorators, { kind: "method", name: "discriminate", static: false, private: false, access: { has: (obj) => "discriminate" in obj, get: (obj) => obj.discriminate }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_a8, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a8;
})();
var discriminantToJson = (discriminant) => ({
  kind: discriminant.kind,
  path: discriminant.path,
  cases: flatMorph(discriminant.cases, (k, node2) => [
    k,
    node2 === true ? node2 : node2.hasKind("union") && node2.discriminantJson ? node2.discriminantJson : node2.json
  ])
});
var describeBranches = (descriptions) => {
  if (descriptions.length === 0)
    return "never";
  if (descriptions.length === 1)
    return descriptions[0];
  if (descriptions.length === 2 && descriptions[0] === "false" && descriptions[1] === "true" || descriptions[0] === "true" && descriptions[1] === "false")
    return "boolean";
  let description = "";
  for (let i = 0; i < descriptions.length - 1; i++) {
    description += descriptions[i];
    if (i < descriptions.length - 2)
      description += ", ";
  }
  description += ` or ${descriptions[descriptions.length - 1]}`;
  return description;
};
var intersectBranches = (l, r, ctx) => {
  const batchesByR = r.map(() => []);
  for (let lIndex = 0; lIndex < l.length; lIndex++) {
    let candidatesByR = {};
    for (let rIndex = 0; rIndex < r.length; rIndex++) {
      if (batchesByR[rIndex] === null) {
        continue;
      }
      if (l[lIndex].equals(r[rIndex])) {
        batchesByR[rIndex] = null;
        candidatesByR = {};
        break;
      }
      const branchIntersection = intersectNodes(l[lIndex], r[rIndex], ctx);
      if (branchIntersection instanceof Disjoint) {
        continue;
      }
      if (branchIntersection.equals(l[lIndex])) {
        batchesByR[rIndex].push(l[lIndex]);
        candidatesByR = {};
        break;
      }
      if (branchIntersection.equals(r[rIndex])) {
        batchesByR[rIndex] = null;
      } else {
        candidatesByR[rIndex] = branchIntersection;
      }
    }
    for (const rIndex in candidatesByR) {
      batchesByR[rIndex][lIndex] = candidatesByR[rIndex];
    }
  }
  const resultBranches = batchesByR.flatMap(
    // ensure unions returned from branchable intersections like sequence are flattened
    (batch, i) => (batch == null ? void 0 : batch.flatMap((branch) => branch.branches)) ?? r[i]
  );
  return resultBranches.length === 0 ? Disjoint.from("union", l, r) : resultBranches;
};
var reduceBranches = ({ branches, ordered }) => {
  if (branches.length < 2)
    return branches;
  const uniquenessByIndex = branches.map(() => true);
  for (let i = 0; i < branches.length; i++) {
    for (let j = i + 1; j < branches.length && uniquenessByIndex[i] && uniquenessByIndex[j]; j++) {
      if (branches[i].equals(branches[j])) {
        uniquenessByIndex[j] = false;
        continue;
      }
      const intersection = intersectNodesRoot(branches[i].in, branches[j].in, branches[0].$);
      if (intersection instanceof Disjoint)
        continue;
      if (intersection.equals(branches[i].in)) {
        uniquenessByIndex[i] = !!ordered;
      } else if (intersection.equals(branches[j].in))
        uniquenessByIndex[j] = false;
    }
  }
  return branches.filter((_, i) => uniquenessByIndex[i]);
};
var discriminantKinds = {
  domain: 1,
  unit: 1
};
var parseDiscriminantKey = (key) => {
  const lastPathIndex = key.lastIndexOf("]");
  const parsedPath = JSON.parse(key.slice(0, lastPathIndex + 1));
  const parsedKind = key.slice(lastPathIndex + 1);
  return [parsedPath, parsedKind];
};
var pruneDiscriminant = (discriminantKind, path, branch) => branch.transform((nodeKind, inner, ctx) => {
  if (nodeKind === "domain" && inner.domain === "object" && path.length > ctx.path.length)
    return null;
  if ((discriminantKind === nodeKind || nodeKind === "domain" && ctx.path.length === path.length) && ctx.path.length === path.length && ctx.path.every((segment, i) => segment === path[i]))
    return null;
  return inner;
}, {
  shouldTransform: (node2) => node2.children.length !== 0 || node2.kind === "domain" || node2.kind === "unit"
});

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/unit.js
var unitImplementation = implementNode({
  kind: "unit",
  hasAssociatedError: true,
  keys: {
    unit: {
      preserveUndefined: true,
      serialize: (schema2) => schema2 instanceof Date ? schema2.toISOString() : defaultValueSerializer(schema2)
    }
  },
  normalize: (schema2) => schema2,
  defaults: {
    description: (node2) => printable(node2.unit),
    problem: ({ expected, actual }) => `${expected === actual ? `must be reference equal to ${expected} (serialized to the same value)` : `must be ${expected} (was ${actual})`}`
  },
  intersections: {
    unit: (l, r) => Disjoint.from("unit", l, r),
    ...defineRightwardIntersections("unit", (l, r) => r.allows(l.unit) ? l : Disjoint.from("assignability", l, r.hasKind("intersection") ? r.children.find((rConstraint) => !rConstraint.allows(l.unit)) : r))
  }
});
var UnitNode = class extends RawBasis {
  constructor() {
    super(...arguments);
    __publicField(this, "compiledValue", this.json.unit);
    __publicField(this, "serializedValue", typeof this.unit === "string" || this.unit instanceof Date ? JSON.stringify(this.compiledValue) : this.compiledValue);
    __publicField(this, "literalKeys", prototypeKeysOf(this.unit));
    __publicField(this, "compiledCondition", compileEqualityCheck(this.unit, this.serializedValue));
    __publicField(this, "compiledNegation", compileEqualityCheck(this.unit, this.serializedValue, "negated"));
    __publicField(this, "expression", printable(this.unit));
    __publicField(this, "domain", domainOf(this.unit));
    __publicField(this, "traverseAllows", this.unit instanceof Date ? (data) => data instanceof Date && data.toISOString() === this.compiledValue : (data) => data === this.unit);
  }
};
var compileEqualityCheck = (unit, serializedValue, negated) => {
  if (unit instanceof Date) {
    const condition = `data instanceof Date && data.toISOString() === ${serializedValue}`;
    return negated ? `!(${condition})` : condition;
  }
  return `data ${negated ? "!" : "="}== ${serializedValue}`;
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/index.js
var indexImplementation = implementNode({
  kind: "index",
  hasAssociatedError: false,
  intersectionIsOpen: true,
  keys: {
    signature: {
      child: true,
      parse: (schema2, ctx) => {
        const key = ctx.$.schema(schema2);
        if (!key.extends(ctx.$.keywords.propertyKey)) {
          return throwParseError(writeInvalidPropertyKeyMessage(key.expression));
        }
        const enumerableBranches = key.branches.filter((b) => b.hasKind("unit"));
        if (enumerableBranches.length) {
          return throwParseError(writeEnumerableIndexBranches(enumerableBranches.map((b) => printable(b.unit))));
        }
        return key;
      }
    },
    value: {
      child: true,
      parse: (schema2, ctx) => ctx.$.schema(schema2)
    }
  },
  normalize: (schema2) => schema2,
  defaults: {
    description: (node2) => `[${node2.signature.expression}]: ${node2.value.description}`
  },
  intersections: {
    index: (l, r, ctx) => {
      if (l.signature.equals(r.signature)) {
        const valueIntersection = intersectNodes(l.value, r.value, ctx);
        const value = valueIntersection instanceof Disjoint ? ctx.$.keywords.never.raw : valueIntersection;
        return ctx.$.node("index", { signature: l.signature, value });
      }
      if (l.signature.extends(r.signature) && l.value.subsumes(r.value))
        return r;
      if (r.signature.extends(l.signature) && r.value.subsumes(l.value))
        return l;
      return null;
    }
  }
});
var IndexNode = class extends BaseConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", this.$.keywords.object.raw);
    __publicField(this, "expression", `[${this.signature.expression}]: ${this.value.expression}`);
    __publicField(this, "traverseAllows", (data, ctx) => stringAndSymbolicEntriesOf(data).every((entry) => {
      if (this.signature.traverseAllows(entry[0], ctx)) {
        ctx == null ? void 0 : ctx.path.push(entry[0]);
        const allowed = this.value.traverseAllows(entry[1], ctx);
        ctx == null ? void 0 : ctx.path.pop();
        return allowed;
      }
      return true;
    }));
    __publicField(this, "traverseApply", (data, ctx) => stringAndSymbolicEntriesOf(data).forEach((entry) => {
      if (this.signature.traverseAllows(entry[0], ctx)) {
        ctx.path.push(entry[0]);
        this.value.traverseApply(entry[1], ctx);
        ctx.path.pop();
      }
    }));
  }
  _transform(mapper, ctx) {
    ctx.path.push(this.signature);
    const result = super._transform(mapper, ctx);
    ctx.path.pop();
    return result;
  }
  compile() {
  }
};
var writeEnumerableIndexBranches = (keys) => `Index keys ${keys.join(", ")} should be specified as named props.`;
var writeInvalidPropertyKeyMessage = (indexSchema) => `Indexed key definition '${indexSchema}' must be a string, number or symbol`;

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/prop.js
var intersectProps = (l, r, ctx) => {
  if (l.key !== r.key)
    return null;
  const key = l.key;
  let value = intersectNodes(l.value, r.value, ctx);
  const kind = l.required || r.required ? "required" : "optional";
  if (value instanceof Disjoint) {
    if (kind === "optional")
      value = ctx.$.keywords.never.raw;
    else
      return value.withPrefixKey(l.compiledKey);
  }
  if (kind === "required") {
    return ctx.$.node("required", {
      key,
      value
    });
  }
  const defaultIntersection = l.hasDefault() ? r.hasDefault() ? l.default === r.default ? l.default : throwParseError(`Invalid intersection of default values ${printable(l.default)} & ${printable(r.default)}`) : l.default : r.hasDefault() ? r.default : unset;
  return ctx.$.node("optional", {
    key,
    value,
    // unset is stripped during parsing
    default: defaultIntersection
  });
};
var BaseProp = class extends BaseConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "required", this.kind === "required");
    __publicField(this, "impliedBasis", this.$.keywords.object.raw);
    __publicField(this, "serializedKey", compileSerializedValue(this.key));
    __publicField(this, "compiledKey", typeof this.key === "string" ? this.key : this.serializedKey);
    __publicField(this, "defaultValueMorphs", [
      (data) => {
        data[this.key] = this.default;
        return data;
      }
    ]);
    __publicField(this, "defaultValueMorphsReference", registeredReference(this.defaultValueMorphs));
    __publicField(this, "traverseAllows", (data, ctx) => {
      if (this.key in data) {
        ctx == null ? void 0 : ctx.path.push(this.key);
        const allowed = this.value.traverseAllows(data[this.key], ctx);
        ctx == null ? void 0 : ctx.path.pop();
        return allowed;
      }
      return !this.required;
    });
    __publicField(this, "traverseApply", (data, ctx) => {
      if (this.key in data) {
        ctx.path.push(this.key);
        this.value.traverseApply(data[this.key], ctx);
        ctx.path.pop();
      } else if (this.hasKind("required"))
        ctx.error(this.errorContext);
      else if (this.hasKind("optional") && this.hasDefault())
        ctx.queueMorphs(this.defaultValueMorphs);
    });
  }
  _transform(mapper, ctx) {
    ctx.path.push(this.key);
    const result = super._transform(mapper, ctx);
    ctx.path.pop();
    return result;
  }
  hasDefault() {
    return "default" in this;
  }
  compile(js) {
    js.if(`${this.serializedKey} in data`, () => js.traverseKey(this.serializedKey, `data${js.prop(this.key)}`, this.value));
    if (this.hasKind("required")) {
      js.else(() => {
        if (js.traversalKind === "Apply")
          return js.line(`ctx.error(${this.compiledErrorContext})`);
        else
          return js.return(false);
      });
    } else if (js.traversalKind === "Apply" && "default" in this) {
      js.else(() => js.line(`ctx.queueMorphs(${this.defaultValueMorphsReference})`));
    }
    if (js.traversalKind === "Allows")
      js.return(true);
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/optional.js
var optionalImplementation = implementNode({
  kind: "optional",
  hasAssociatedError: false,
  intersectionIsOpen: true,
  keys: {
    key: {},
    value: {
      child: true,
      parse: (schema2, ctx) => ctx.$.schema(schema2)
    },
    default: {
      preserveUndefined: true
    }
  },
  normalize: (schema2) => schema2,
  defaults: {
    description: (node2) => `${node2.compiledKey}?: ${node2.value.description}`
  },
  intersections: {
    optional: intersectProps
  }
});
var OptionalNode = class extends BaseProp {
  constructor() {
    super(...arguments);
    __publicField(this, "expression", `${this.compiledKey}?: ${this.value.expression}`);
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/required.js
var RequiredNode = class extends BaseProp {
  constructor() {
    super(...arguments);
    __publicField(this, "expression", `${this.compiledKey}: ${this.value.expression}`);
    __publicField(this, "errorContext", Object.freeze({
      code: "required",
      missingValueDescription: this.value.description,
      relativePath: [this.key]
    }));
    __publicField(this, "compiledErrorContext", compileErrorContext(this.errorContext));
  }
};
var requiredImplementation = implementNode({
  kind: "required",
  hasAssociatedError: true,
  intersectionIsOpen: true,
  keys: {
    key: {},
    value: {
      child: true,
      parse: (schema2, ctx) => ctx.$.schema(schema2)
    }
  },
  normalize: (schema2) => schema2,
  defaults: {
    description: (node2) => `${node2.compiledKey}: ${node2.value.description}`,
    expected: (ctx) => ctx.missingValueDescription,
    actual: () => "missing"
  },
  intersections: {
    required: intersectProps,
    optional: intersectProps
  }
});

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/sequence.js
var fixedSequenceKeySchemaDefinition = {
  child: true,
  parse: (schema2, ctx) => schema2.length === 0 ? (
    // empty affixes are omitted. an empty array should therefore
    // be specified as `{ proto: Array, length: 0 }`
    void 0
  ) : schema2.map((element) => ctx.$.schema(element))
};
var sequenceImplementation = implementNode({
  kind: "sequence",
  hasAssociatedError: false,
  collapsibleKey: "variadic",
  keys: {
    prefix: fixedSequenceKeySchemaDefinition,
    optionals: fixedSequenceKeySchemaDefinition,
    variadic: {
      child: true,
      parse: (schema2, ctx) => ctx.$.schema(schema2, ctx)
    },
    minVariadicLength: {
      // minVariadicLength is reflected in the id of this node,
      // but not its IntersectionNode parent since it is superceded by the minLength
      // node it implies
      parse: (min) => min === 0 ? void 0 : min
    },
    postfix: fixedSequenceKeySchemaDefinition
  },
  normalize: (schema2) => {
    var _a8, _b6;
    if (typeof schema2 === "string")
      return { variadic: schema2 };
    if ("variadic" in schema2 || "prefix" in schema2 || "optionals" in schema2 || "postfix" in schema2 || "minVariadicLength" in schema2) {
      if ((_a8 = schema2.postfix) == null ? void 0 : _a8.length) {
        if (!schema2.variadic)
          return throwParseError(postfixWithoutVariadicMessage);
        if ((_b6 = schema2.optionals) == null ? void 0 : _b6.length)
          return throwParseError(postfixFollowingOptionalMessage);
      }
      if (schema2.minVariadicLength && !schema2.variadic) {
        return throwParseError("minVariadicLength may not be specified without a variadic element");
      }
      return schema2;
    }
    return { variadic: schema2 };
  },
  reduce: (raw, $) => {
    var _a8, _b6, _c, _d, _e, _f;
    let minVariadicLength = raw.minVariadicLength ?? 0;
    const prefix = ((_a8 = raw.prefix) == null ? void 0 : _a8.slice()) ?? [];
    const optional = ((_b6 = raw.optionals) == null ? void 0 : _b6.slice()) ?? [];
    const postfix = ((_c = raw.postfix) == null ? void 0 : _c.slice()) ?? [];
    if (raw.variadic) {
      while ((_d = optional.at(-1)) == null ? void 0 : _d.equals(raw.variadic))
        optional.pop();
      if (optional.length === 0) {
        while ((_e = prefix.at(-1)) == null ? void 0 : _e.equals(raw.variadic)) {
          prefix.pop();
          minVariadicLength++;
        }
      }
      while ((_f = postfix[0]) == null ? void 0 : _f.equals(raw.variadic)) {
        postfix.shift();
        minVariadicLength++;
      }
    } else if (optional.length === 0) {
      prefix.push(...postfix.splice(0));
    }
    if (
      // if any variadic adjacent elements were moved to minVariadicLength
      minVariadicLength !== raw.minVariadicLength || // or any postfix elements were moved to prefix
      raw.prefix && raw.prefix.length !== prefix.length
    ) {
      return $.node("sequence", {
        ...raw,
        // empty lists will be omitted during parsing
        prefix,
        postfix,
        optionals: optional,
        minVariadicLength
      }, { prereduced: true });
    }
  },
  defaults: {
    description: (node2) => {
      if (node2.isVariadicOnly)
        return `${node2.variadic.nestableExpression}[]`;
      const innerDescription = node2.tuple.map((element) => element.kind === "optionals" ? `${element.node.nestableExpression}?` : element.kind === "variadic" ? `...${element.node.nestableExpression}[]` : element.node.expression).join(", ");
      return `[${innerDescription}]`;
    }
  },
  intersections: {
    sequence: (l, r, ctx) => {
      const rootState = _intersectSequences({
        l: l.tuple,
        r: r.tuple,
        disjoint: new Disjoint({}),
        result: [],
        fixedVariants: [],
        ctx
      });
      const viableBranches = rootState.disjoint.isEmpty() ? [rootState, ...rootState.fixedVariants] : rootState.fixedVariants;
      return viableBranches.length === 0 ? rootState.disjoint : viableBranches.length === 1 ? ctx.$.node("sequence", sequenceTupleToInner(viableBranches[0].result)) : ctx.$.node("union", viableBranches.map((state) => ({
        proto: Array,
        sequence: sequenceTupleToInner(state.result)
      })));
    }
    // exactLength, minLength, and maxLength don't need to be defined
    // here since impliedSiblings guarantees they will be added
    // directly to the IntersectionNode parent of the SequenceNode
    // they exist on
  }
});
var SequenceNode = class extends BaseConstraint {
  constructor() {
    super(...arguments);
    __publicField(this, "impliedBasis", this.$.keywords.Array.raw);
    __publicField(this, "prefix", this.inner.prefix ?? []);
    __publicField(this, "optionals", this.inner.optionals ?? []);
    __publicField(this, "prevariadic", [...this.prefix, ...this.optionals]);
    __publicField(this, "postfix", this.inner.postfix ?? []);
    __publicField(this, "isVariadicOnly", this.prevariadic.length + this.postfix.length === 0);
    __publicField(this, "minVariadicLength", this.inner.minVariadicLength ?? 0);
    __publicField(this, "minLength", this.prefix.length + this.minVariadicLength + this.postfix.length);
    __publicField(this, "minLengthNode", this.minLength === 0 ? null : this.$.node("minLength", this.minLength));
    __publicField(this, "maxLength", this.variadic ? null : this.minLength + this.optionals.length);
    __publicField(this, "maxLengthNode", this.maxLength === null ? null : this.$.node("maxLength", this.maxLength));
    __publicField(this, "impliedSiblings", this.minLengthNode ? this.maxLengthNode ? [this.minLengthNode, this.maxLengthNode] : [this.minLengthNode] : this.maxLengthNode ? [this.maxLengthNode] : []);
    // minLength/maxLength should be checked by Intersection before either traversal
    __publicField(this, "traverseAllows", (data, ctx) => {
      for (let i = 0; i < data.length; i++)
        if (!this.childAtIndex(data, i).traverseAllows(data[i], ctx))
          return false;
      return true;
    });
    __publicField(this, "traverseApply", (data, ctx) => {
      for (let i = 0; i < data.length; i++) {
        ctx.path.push(i);
        this.childAtIndex(data, i).traverseApply(data[i], ctx);
        ctx.path.pop();
      }
    });
    __publicField(this, "tuple", sequenceInnerToTuple(this.inner));
    // this depends on tuple so needs to come after it
    __publicField(this, "expression", this.description);
  }
  childAtIndex(data, index) {
    if (index < this.prevariadic.length)
      return this.prevariadic[index];
    const firstPostfixIndex = data.length - this.postfix.length;
    if (index >= firstPostfixIndex)
      return this.postfix[index - firstPostfixIndex];
    return this.variadic ?? throwInternalError(`Unexpected attempt to access index ${index} on ${this}`);
  }
  // minLength/maxLength compilation should be handled by Intersection
  compile(js) {
    this.prefix.forEach((node2, i) => js.traverseKey(`${i}`, `data[${i}]`, node2));
    this.optionals.forEach((node2, i) => {
      const dataIndex = `${i + this.prefix.length}`;
      js.if(`${dataIndex} >= ${js.data}.length`, () => js.traversalKind === "Allows" ? js.return(true) : js.return());
      js.traverseKey(dataIndex, `data[${dataIndex}]`, node2);
    });
    if (this.variadic) {
      if (this.postfix.length) {
        js.const("firstPostfixIndex", `${js.data}.length${this.postfix.length ? `- ${this.postfix.length}` : ""}`);
      }
      js.for(`i < ${this.postfix.length ? "firstPostfixIndex" : "data.length"}`, () => js.traverseKey("i", "data[i]", this.variadic), this.prevariadic.length);
      this.postfix.forEach((node2, i) => {
        const keyExpression = `firstPostfixIndex + ${i}`;
        js.traverseKey(keyExpression, `data[${keyExpression}]`, node2);
      });
    }
    if (js.traversalKind === "Allows")
      js.return(true);
  }
  _transform(mapper, ctx) {
    ctx.path.push(this.$.keywords.nonNegativeIntegerString.raw);
    const result = super._transform(mapper, ctx);
    ctx.path.pop();
    return result;
  }
};
var sequenceInnerToTuple = (inner) => {
  var _a8, _b6, _c;
  const tuple = [];
  (_a8 = inner.prefix) == null ? void 0 : _a8.forEach((node2) => tuple.push({ kind: "prefix", node: node2 }));
  (_b6 = inner.optionals) == null ? void 0 : _b6.forEach((node2) => tuple.push({ kind: "optionals", node: node2 }));
  if (inner.variadic)
    tuple.push({ kind: "variadic", node: inner.variadic });
  (_c = inner.postfix) == null ? void 0 : _c.forEach((node2) => tuple.push({ kind: "postfix", node: node2 }));
  return tuple;
};
var sequenceTupleToInner = (tuple) => tuple.reduce((result, node2) => {
  if (node2.kind === "variadic")
    result.variadic = node2.node;
  else
    result[node2.kind] = append(result[node2.kind], node2.node);
  return result;
}, {});
var postfixFollowingOptionalMessage = "A postfix required element cannot follow an optional element";
var postfixWithoutVariadicMessage = "A postfix element requires a variadic element";
var _intersectSequences = (s) => {
  var _a8, _b6;
  const [lHead, ...lTail] = s.l;
  const [rHead, ...rTail] = s.r;
  if (!lHead || !rHead)
    return s;
  const lHasPostfix = ((_a8 = lTail.at(-1)) == null ? void 0 : _a8.kind) === "postfix";
  const rHasPostfix = ((_b6 = rTail.at(-1)) == null ? void 0 : _b6.kind) === "postfix";
  const kind = lHead.kind === "prefix" || rHead.kind === "prefix" ? "prefix" : lHead.kind === "optionals" || rHead.kind === "optionals" ? (
    // if either operand has postfix elements, the full-length
    // intersection can't include optional elements (though they may
    // exist in some of the fixed length variants)
    lHasPostfix || rHasPostfix ? "prefix" : "optionals"
  ) : lHead.kind === "postfix" || rHead.kind === "postfix" ? "postfix" : "variadic";
  if (lHead.kind === "prefix" && rHead.kind === "variadic" && rHasPostfix) {
    const postfixBranchResult = _intersectSequences({
      ...s,
      fixedVariants: [],
      r: rTail.map((element) => ({ ...element, kind: "prefix" }))
    });
    if (postfixBranchResult.disjoint.isEmpty())
      s.fixedVariants.push(postfixBranchResult);
  } else if (rHead.kind === "prefix" && lHead.kind === "variadic" && lHasPostfix) {
    const postfixBranchResult = _intersectSequences({
      ...s,
      fixedVariants: [],
      l: lTail.map((element) => ({ ...element, kind: "prefix" }))
    });
    if (postfixBranchResult.disjoint.isEmpty())
      s.fixedVariants.push(postfixBranchResult);
  }
  const result = intersectNodes(lHead.node, rHead.node, s.ctx);
  if (result instanceof Disjoint) {
    if (kind === "prefix" || kind === "postfix") {
      s.disjoint.add(result.withPrefixKey(
        // TODO: more precise path handling for Disjoints
        kind === "prefix" ? `${s.result.length}` : `-${lTail.length + 1}`
      ));
      s.result = [...s.result, { kind, node: s.ctx.$.keywords.never.raw }];
    } else if (kind === "optionals") {
      return s;
    } else {
      return _intersectSequences({
        ...s,
        fixedVariants: [],
        // if there were any optional elements, there will be no postfix elements
        // so this mapping will never occur (which would be illegal otherwise)
        l: lTail.map((element) => ({ ...element, kind: "prefix" })),
        r: lTail.map((element) => ({ ...element, kind: "prefix" }))
      });
    }
  } else
    s.result = [...s.result, { kind, node: result }];
  const lRemaining = s.l.length;
  const rRemaining = s.r.length;
  if (lHead.kind !== "variadic" || lRemaining >= rRemaining && (rHead.kind === "variadic" || rRemaining === 1))
    s.l = lTail;
  if (rHead.kind !== "variadic" || rRemaining >= lRemaining && (lHead.kind === "variadic" || lRemaining === 1))
    s.r = rTail;
  return _intersectSequences(s);
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/shared.js
var arrayIndexMatcher = /(?:0|(?:[1-9]\\d*))$/;
var arrayIndexMatcherReference = registeredReference(arrayIndexMatcher);

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/structure.js
var __runInitializers3 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate3 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var StructureNode = (() => {
  var _a8, _b6, _c;
  let _classSuper = BaseConstraint;
  let _instanceExtraInitializers = [];
  let _keyof_decorators;
  return _c = class extends _classSuper {
    constructor() {
      super(...arguments);
      __publicField(this, "impliedBasis", (__runInitializers3(this, _instanceExtraInitializers), this.$.keywords.object.raw));
      __publicField(this, "impliedSiblings", this.children.flatMap((n) => n.impliedSiblings ?? []));
      __publicField(this, "props", this.required ? this.optional ? [...this.required, ...this.optional] : this.required : this.optional ?? []);
      __publicField(this, "propsByKey", flatMorph(this.props, (i, node2) => [node2.key, node2]));
      __publicField(this, "propsByKeyReference", registeredReference(this.propsByKey));
      __publicField(this, "expression", structuralExpression(this));
      __publicField(this, "requiredLiteralKeys", ((_a8 = this.required) == null ? void 0 : _a8.map((node2) => node2.key)) ?? []);
      __publicField(this, "optionalLiteralKeys", ((_b6 = this.optional) == null ? void 0 : _b6.map((node2) => node2.key)) ?? []);
      __publicField(this, "literalKeys", [
        ...this.requiredLiteralKeys,
        ...this.optionalLiteralKeys
      ]);
      __publicField(this, "exhaustive", this.undeclared !== void 0 || this.index !== void 0);
      __publicField(this, "traverseAllows", (data, ctx) => this._traverse("Allows", data, ctx));
      __publicField(this, "traverseApply", (data, ctx) => this._traverse("Apply", data, ctx));
      __publicField(this, "_traverse", (traversalKind, data, ctx) => {
        const errorCount = (ctx == null ? void 0 : ctx.currentErrorCount) ?? 0;
        for (let i = 0; i < this.props.length; i++) {
          if (traversalKind === "Allows") {
            if (!this.props[i].traverseAllows(data, ctx))
              return false;
          } else {
            this.props[i].traverseApply(data, ctx);
            if (ctx.failFast && ctx.currentErrorCount > errorCount)
              return false;
          }
        }
        if (this.sequence) {
          if (traversalKind === "Allows") {
            if (!this.sequence.traverseAllows(data, ctx))
              return false;
          } else {
            this.sequence.traverseApply(data, ctx);
            if (ctx.failFast && ctx.currentErrorCount > errorCount)
              return false;
          }
        }
        if (!this.exhaustive)
          return true;
        const keys = Object.keys(data);
        keys.push(...Object.getOwnPropertySymbols(data));
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          let matched = false;
          if (this.index) {
            for (const node2 of this.index) {
              if (node2.signature.traverseAllows(k, ctx)) {
                if (traversalKind === "Allows") {
                  ctx == null ? void 0 : ctx.path.push(k);
                  const result = node2.value.traverseAllows(data[k], ctx);
                  ctx == null ? void 0 : ctx.path.pop();
                  if (!result)
                    return false;
                } else {
                  ctx.path.push(k);
                  node2.value.traverseApply(data[k], ctx);
                  ctx.path.pop();
                  if (ctx.failFast && ctx.currentErrorCount > errorCount)
                    return false;
                }
                matched = true;
              }
            }
          }
          if (this.undeclared) {
            matched || (matched = k in this.propsByKey);
            matched || (matched = this.sequence !== void 0 && typeof k === "string" && arrayIndexMatcher.test(k));
            if (!matched) {
              if (traversalKind === "Allows")
                return false;
              if (this.undeclared === "reject")
                ctx.error({ expected: "removed", actual: null, relativePath: [k] });
              else {
                ctx.queueMorphs([
                  (data2) => {
                    delete data2[k];
                    return data2;
                  }
                ]);
              }
              if (ctx.failFast)
                return false;
            }
          }
          ctx == null ? void 0 : ctx.path.pop();
        }
        return true;
      });
    }
    keyof() {
      var _a9;
      let branches = this.$.units(this.literalKeys).branches;
      (_a9 = this.index) == null ? void 0 : _a9.forEach(({ signature: index }) => {
        branches = branches.concat(index.branches);
      });
      return this.$.node("union", branches);
    }
    omit(...keys) {
      return this.$.node("structure", omitFromInner(this.inner, keys));
    }
    merge(r) {
      const inner = makeRootAndArrayPropertiesMutable(omitFromInner(this.inner, [r.keyof()]));
      if (r.required)
        inner.required = append(inner.required, r.required);
      if (r.optional)
        inner.optional = append(inner.optional, r.optional);
      if (r.index)
        inner.index = append(inner.index, r.index);
      if (r.sequence)
        inner.sequence = r.sequence;
      if (r.undeclared)
        inner.undeclared = r.undeclared;
      else
        delete inner.undeclared;
      return this.$.node("structure", inner);
    }
    compile(js) {
      if (js.traversalKind === "Apply")
        js.initializeErrorCount();
      this.props.forEach((prop) => {
        js.check(prop);
        if (js.traversalKind === "Apply")
          js.returnIfFailFast();
      });
      if (this.sequence) {
        js.check(this.sequence);
        if (js.traversalKind === "Apply")
          js.returnIfFailFast();
      }
      if (this.exhaustive) {
        js.const("keys", "Object.keys(data)");
        js.line("keys.push(...Object.getOwnPropertySymbols(data))");
        js.for("i < keys.length", () => this.compileExhaustiveEntry(js));
      }
      if (js.traversalKind === "Allows")
        js.return(true);
    }
    compileExhaustiveEntry(js) {
      var _a9, _b7;
      js.const("k", "keys[i]");
      if (this.undeclared)
        js.let("matched", false);
      (_a9 = this.index) == null ? void 0 : _a9.forEach((node2) => {
        js.if(`${js.invoke(node2.signature, { arg: "k", kind: "Allows" })}`, () => {
          js.traverseKey("k", "data[k]", node2.value);
          if (this.undeclared)
            js.set("matched", true);
          return js;
        });
      });
      if (this.undeclared) {
        if (((_b7 = this.props) == null ? void 0 : _b7.length) !== 0)
          js.line(`matched ||= k in ${this.propsByKeyReference}`);
        if (this.sequence) {
          js.line(`matched ||= typeof k === "string" && ${arrayIndexMatcherReference}.test(k)`);
        }
        js.if("!matched", () => {
          if (js.traversalKind === "Allows")
            return js.return(false);
          return this.undeclared === "reject" ? js.line(`ctx.error({ expected: "removed", actual: null, relativePath: [k] })`).if("ctx.failFast", () => js.return()) : js.line(`ctx.queueMorphs([data => { delete data[k]; return data }])`);
        });
      }
      return js;
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _keyof_decorators = [cached];
    __esDecorate3(_c, null, _keyof_decorators, { kind: "method", name: "keyof", static: false, private: false, access: { has: (obj) => "keyof" in obj, get: (obj) => obj.keyof }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_c, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _c;
})();
var omitFromInner = (inner, keys) => {
  const result = { ...inner };
  keys.forEach((k) => {
    if (result.required) {
      result.required = result.required.filter((b) => typeof k === "function" ? !k.allows(b.key) : k !== b.key);
    }
    if (result.optional) {
      result.optional = result.optional.filter((b) => typeof k === "function" ? !k.allows(b.key) : k !== b.key);
    }
    if (result.index && typeof k === "function") {
      result.index = result.index.filter((n) => !n.signature.extends(k));
    }
  });
  return result;
};
var createStructuralWriter = (childStringProp) => (node2) => {
  var _a8, _b6;
  if (node2.props.length || node2.index) {
    const parts = ((_a8 = node2.index) == null ? void 0 : _a8.map(String)) ?? [];
    node2.props.forEach((node3) => parts.push(node3[childStringProp]));
    if (node2.undeclared)
      parts.push(`+ (undeclared): ${node2.undeclared}`);
    const objectLiteralDescription = `{ ${parts.join(", ")} }`;
    return node2.sequence ? `${objectLiteralDescription} & ${node2.sequence.description}` : objectLiteralDescription;
  }
  return ((_b6 = node2.sequence) == null ? void 0 : _b6.description) ?? "{}";
};
var structuralDescription = createStructuralWriter("description");
var structuralExpression = createStructuralWriter("expression");
var structureImplementation = implementNode({
  kind: "structure",
  hasAssociatedError: false,
  normalize: (schema2) => schema2,
  keys: {
    required: {
      child: true,
      parse: constraintKeyParser("required")
    },
    optional: {
      child: true,
      parse: constraintKeyParser("optional")
    },
    index: {
      child: true,
      parse: constraintKeyParser("index")
    },
    sequence: {
      child: true,
      parse: constraintKeyParser("sequence")
    },
    undeclared: {
      parse: (behavior) => behavior === "ignore" ? void 0 : behavior
    }
  },
  defaults: {
    description: structuralDescription
  },
  intersections: {
    structure: (l, r, ctx) => {
      const lInner = { ...l.inner };
      const rInner = { ...r.inner };
      if (l.undeclared) {
        const lKey = l.keyof();
        const disjointRKeys = r.requiredLiteralKeys.filter((k) => !lKey.allows(k));
        if (disjointRKeys.length) {
          return Disjoint.from("presence", ctx.$.keywords.never.raw, r.propsByKey[disjointRKeys[0]].value).withPrefixKey(disjointRKeys[0]);
        }
        if (rInner.optional)
          rInner.optional = rInner.optional.filter((n) => lKey.allows(n.key));
        if (rInner.index) {
          rInner.index = rInner.index.flatMap((n) => {
            if (n.signature.extends(lKey))
              return n;
            const indexOverlap = intersectNodesRoot(lKey, n.signature, ctx.$);
            if (indexOverlap instanceof Disjoint)
              return [];
            const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);
            if (normalized.required) {
              rInner.required = rInner.required ? [...rInner.required, ...normalized.required] : normalized.required;
            }
            return normalized.index ?? [];
          });
        }
      }
      if (r.undeclared) {
        const rKey = r.keyof();
        const disjointLKeys = l.requiredLiteralKeys.filter((k) => !rKey.allows(k));
        if (disjointLKeys.length) {
          return Disjoint.from("presence", l.propsByKey[disjointLKeys[0]].value, ctx.$.keywords.never.raw).withPrefixKey(disjointLKeys[0]);
        }
        if (lInner.optional)
          lInner.optional = lInner.optional.filter((n) => rKey.allows(n.key));
        if (lInner.index) {
          lInner.index = lInner.index.flatMap((n) => {
            if (n.signature.extends(rKey))
              return n;
            const indexOverlap = intersectNodesRoot(rKey, n.signature, ctx.$);
            if (indexOverlap instanceof Disjoint)
              return [];
            const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);
            if (normalized.required) {
              lInner.required = lInner.required ? [...lInner.required, ...normalized.required] : normalized.required;
            }
            return normalized.index ?? [];
          });
        }
      }
      const baseInner = {};
      if (l.undeclared || r.undeclared) {
        baseInner.undeclared = l.undeclared === "reject" || r.undeclared === "reject" ? "reject" : "delete";
      }
      return intersectConstraints({
        kind: "structure",
        baseInner,
        l: flattenConstraints(lInner),
        r: flattenConstraints(rInner),
        roots: [],
        ctx
      });
    }
  }
});
var normalizeIndex = (signature, value, $) => {
  const [enumerableBranches, nonEnumerableBranches] = spliterate(signature.branches, (k) => k.hasKind("unit"));
  if (!enumerableBranches.length)
    return { index: $.node("index", { signature, value }) };
  const normalized = {};
  normalized.required = enumerableBranches.map((n) => $.node("required", { key: n.unit, value }));
  if (nonEnumerableBranches.length) {
    normalized.index = $.node("index", {
      signature: nonEnumerableBranches,
      value
    });
  }
  return normalized;
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/kinds.js
var nodeImplementationsByKind = {
  ...boundImplementationsByKind,
  alias: aliasImplementation,
  domain: domainImplementation,
  unit: unitImplementation,
  proto: protoImplementation,
  union: unionImplementation,
  morph: morphImplementation,
  intersection: intersectionImplementation,
  divisor: divisorImplementation,
  regex: regexImplementation,
  predicate: predicateImplementation,
  required: requiredImplementation,
  optional: optionalImplementation,
  index: indexImplementation,
  sequence: sequenceImplementation,
  structure: structureImplementation
};
var nodeClassesByKind = {
  ...boundClassesByKind,
  alias: AliasNode,
  domain: DomainNode,
  unit: UnitNode,
  proto: ProtoNode,
  union: UnionNode,
  morph: MorphNode,
  intersection: IntersectionNode,
  divisor: DivisorNode,
  regex: RegexNode,
  predicate: PredicateNode,
  required: RequiredNode,
  optional: OptionalNode,
  index: IndexNode,
  sequence: SequenceNode,
  structure: StructureNode
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/module.js
var RootModule = class extends DynamicBase {
  // ensure `[arkKind]` is non-enumerable so it doesn't get spread on import/export
  get [arkKind]() {
    return "module";
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/parse.js
var schemaKindOf = (schema2, allowedKinds) => {
  const kind = discriminateRootKind(schema2);
  if (allowedKinds && !allowedKinds.includes(kind)) {
    return throwParseError(`Root of kind ${kind} should be one of ${allowedKinds}`);
  }
  return kind;
};
var discriminateRootKind = (schema2) => {
  switch (typeof schema2) {
    case "string":
      return schema2[0] === "$" ? "alias" : "domain";
    case "function":
      return hasArkKind(schema2, "root") ? schema2.kind : "proto";
    case "object": {
      if (schema2 === null)
        break;
      if ("morphs" in schema2)
        return "morph";
      if ("branches" in schema2 || isArray(schema2))
        return "union";
      if ("unit" in schema2)
        return "unit";
      if ("alias" in schema2)
        return "alias";
      const schemaKeys = Object.keys(schema2);
      if (schemaKeys.length === 0 || schemaKeys.some((k) => k in constraintKeys))
        return "intersection";
      if ("proto" in schema2)
        return "proto";
      if ("domain" in schema2)
        return "domain";
    }
  }
  return throwParseError(`${printable(schema2)} is not a valid type schema`);
};
var nodeCache = {};
var serializeListableChild = (listableNode) => isArray(listableNode) ? listableNode.map((node2) => node2.collapsibleJson) : listableNode.collapsibleJson;
var parseNode = (kind, ctx) => {
  const impl = nodeImplementationsByKind[kind];
  const inner = {};
  const schemaEntries = entriesOf(ctx.schema).sort(([lKey], [rKey]) => isNodeKind(lKey) ? isNodeKind(rKey) ? precedenceOfKind(lKey) - precedenceOfKind(rKey) : 1 : isNodeKind(rKey) ? -1 : lKey < rKey ? -1 : 1);
  const children = [];
  for (const entry of schemaEntries) {
    const k = entry[0];
    const keyImpl = impl.keys[k];
    if (!keyImpl)
      return throwParseError(`Key ${k} is not valid on ${kind} schema`);
    const v = keyImpl.parse ? keyImpl.parse(entry[1], ctx) : entry[1];
    if (v !== unset && (v !== void 0 || keyImpl.preserveUndefined))
      inner[k] = v;
  }
  const entries = entriesOf(inner);
  let json2 = {};
  let typeJson = {};
  entries.forEach(([k, v]) => {
    const listableNode = v;
    const keyImpl = impl.keys[k];
    const serialize = keyImpl.serialize ?? (keyImpl.child ? serializeListableChild : defaultValueSerializer);
    json2[k] = serialize(listableNode);
    if (keyImpl.child) {
      if (isArray(listableNode))
        children.push(...listableNode);
      else
        children.push(listableNode);
    }
    if (!keyImpl.meta)
      typeJson[k] = json2[k];
  });
  if (impl.finalizeJson) {
    json2 = impl.finalizeJson(json2);
    typeJson = impl.finalizeJson(typeJson);
  }
  let collapsibleJson = json2;
  const collapsibleKeys = Object.keys(collapsibleJson);
  if (collapsibleKeys.length === 1 && collapsibleKeys[0] === impl.collapsibleKey) {
    collapsibleJson = collapsibleJson[impl.collapsibleKey];
    if (
      // if the collapsibleJson is still an object
      hasDomain(collapsibleJson, "object") && // and the JSON did not include any implied keys
      Object.keys(json2).length === 1
    ) {
      json2 = collapsibleJson;
      typeJson = collapsibleJson;
    }
  }
  const innerHash = JSON.stringify({ kind, ...json2 });
  if (ctx.reduceTo) {
    nodeCache[innerHash] = ctx.reduceTo;
    return ctx.reduceTo;
  }
  const typeHash = JSON.stringify({ kind, ...typeJson });
  if (impl.reduce && !ctx.prereduced) {
    const reduced = impl.reduce(inner, ctx.$);
    if (reduced) {
      if (reduced instanceof Disjoint)
        return reduced.throw();
      if (ctx.alias)
        reduced.alias ?? (reduced.alias = ctx.alias);
      return reduced;
    }
  }
  if (nodeCache[innerHash])
    return nodeCache[innerHash];
  const attachments = {
    id: ctx.id,
    kind,
    impl,
    inner,
    entries,
    json: json2,
    typeJson,
    collapsibleJson,
    children,
    innerHash,
    typeHash,
    $: ctx.$
  };
  if (ctx.alias)
    attachments.alias = ctx.alias;
  for (const k in inner) {
    if (k !== "description" && k !== "in" && k !== "out")
      attachments[k] = inner[k];
  }
  const node2 = new nodeClassesByKind[kind](attachments);
  nodeCache[innerHash] = node2;
  return node2;
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/compile.js
var NodeCompiler = class extends CompiledFunction {
  constructor(traversalKind) {
    super("data", "ctx");
    __publicField(this, "traversalKind");
    __publicField(this, "path", []);
    __publicField(this, "discriminants", []);
    this.traversalKind = traversalKind;
  }
  invoke(node2, opts) {
    const arg = (opts == null ? void 0 : opts.arg) ?? this.data;
    if (this.requiresContextFor(node2))
      return `${this.reference(node2, opts)}(${arg}, ${this.ctx})`;
    return `${this.reference(node2, opts)}(${arg})`;
  }
  reference(node2, opts) {
    const invokedKind = (opts == null ? void 0 : opts.kind) ?? this.traversalKind;
    const base = `this.${node2.id}${invokedKind}`;
    return (opts == null ? void 0 : opts.bind) ? `${base}.bind(${opts == null ? void 0 : opts.bind})` : base;
  }
  requiresContextFor(node2) {
    return this.traversalKind === "Apply" || node2.allowsRequiresContext;
  }
  initializeErrorCount() {
    return this.const("errorCount", "ctx.currentErrorCount");
  }
  returnIfFail() {
    return this.if("ctx.currentErrorCount > errorCount", () => this.return());
  }
  returnIfFailFast() {
    return this.if("ctx.failFast && ctx.currentErrorCount > errorCount", () => this.return());
  }
  traverseKey(keyExpression, accessExpression, node2) {
    const requiresContext = this.requiresContextFor(node2);
    if (requiresContext)
      this.line(`${this.ctx}.path.push(${keyExpression})`);
    this.check(node2, {
      arg: accessExpression
    });
    if (requiresContext)
      this.line(`${this.ctx}.path.pop()`);
    return this;
  }
  check(node2, opts) {
    return this.traversalKind === "Allows" ? this.if(`!${this.invoke(node2, opts)}`, () => this.return(false)) : this.line(this.invoke(node2, opts));
  }
  writeMethod(name) {
    return `${name}(${this.argNames.join(", ")}){
${this.body}    }
`;
  }
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/scope.js
var __runInitializers4 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate4 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var defaultConfig = Object.assign(flatMorph(nodeImplementationsByKind, (kind, implementation) => [
  kind,
  implementation.defaults
]), {
  jitless: envHasCsp(),
  registerKeywords: false,
  prereducedAliases: false
});
var nonInheritedKeys = [
  "registerKeywords",
  "prereducedAliases"
];
var extendConfig = (base, extension) => {
  if (!extension)
    return base;
  const result = mergeConfigs(base, extension);
  nonInheritedKeys.forEach((k) => {
    if (!(k in extension))
      delete result[k];
  });
  return result;
};
var resolveConfig = (config) => extendConfig(extendConfig(defaultConfig, globalConfig), config);
var schemaBranchesOf = (schema2) => isArray(schema2) ? schema2 : "branches" in schema2 && isArray(schema2.branches) ? schema2.branches : void 0;
var throwMismatchedNodeRootError = (expected, actual) => throwParseError(`Node of kind ${actual} is not valid as a ${expected} definition`);
var writeDuplicateAliasError = (alias) => `#${alias} duplicates public alias ${alias}`;
var nodeCountsByPrefix = {};
var nodesById = {};
var scopeCount = 0;
var scopesById = {};
var RawRootScope = (() => {
  var _a8, _b6;
  let _instanceExtraInitializers = [];
  let _schema_decorators;
  let _defineRoot_decorators;
  let _units_decorators;
  return _a8 = arkKind, _b6 = class {
    constructor(def, config) {
      __publicField(this, "config", __runInitializers4(this, _instanceExtraInitializers));
      __publicField(this, "resolvedConfig");
      __publicField(this, "id", `$${++scopeCount}`);
      __publicField(this, _a8, "scope");
      __publicField(this, "referencesById", {});
      __publicField(this, "references", []);
      __publicField(this, "resolutions", {});
      __publicField(this, "json", {});
      __publicField(this, "exportedNames");
      __publicField(this, "aliases", {});
      __publicField(this, "resolved", false);
      __publicField(this, "lazyResolutions", []);
      __publicField(this, "node", ((kinds, nodeSchema, opts) => {
        var _a9;
        let kind = typeof kinds === "string" ? kinds : schemaKindOf(nodeSchema, kinds);
        let schema2 = nodeSchema;
        if (isNode(schema2) && schema2.kind === kind)
          return schema2.bindScope(this);
        if (kind === "alias" && !(opts == null ? void 0 : opts.prereduced)) {
          const resolution = this.resolveRoot(normalizeAliasSchema(schema2).alias);
          schema2 = resolution;
          kind = resolution.kind;
        } else if (kind === "union" && hasDomain(schema2, "object")) {
          const branches = schemaBranchesOf(schema2);
          if ((branches == null ? void 0 : branches.length) === 1) {
            schema2 = branches[0];
            kind = schemaKindOf(schema2);
          }
        }
        const impl = nodeImplementationsByKind[kind];
        const normalizedSchema = ((_a9 = impl.normalize) == null ? void 0 : _a9.call(impl, schema2)) ?? schema2;
        if (isNode(normalizedSchema)) {
          return normalizedSchema.kind === kind ? normalizedSchema.bindScope(this) : throwMismatchedNodeRootError(kind, normalizedSchema.kind);
        }
        const prefix = (opts == null ? void 0 : opts.alias) ?? kind;
        nodeCountsByPrefix[prefix] ?? (nodeCountsByPrefix[prefix] = 0);
        const id2 = `${prefix}${++nodeCountsByPrefix[prefix]}`;
        const node2 = parseNode(kind, {
          ...opts,
          id: id2,
          $: this,
          schema: normalizedSchema
        }).bindScope(this);
        nodesById[id2] = node2;
        if (this.resolved) {
          if (!this.resolvedConfig.jitless)
            bindCompiledScope(node2.references);
        } else {
          Object.assign(this.referencesById, node2.referencesById);
        }
        return node2;
      }).bind(this));
      __publicField(this, "_exportedResolutions");
      __publicField(this, "_exports");
      this.config = config ?? {};
      this.resolvedConfig = resolveConfig(config);
      this.exportedNames = Object.keys(def).filter((k) => {
        if (k[0] === "#") {
          const name = k.slice(1);
          if (name in this.aliases)
            throwParseError(writeDuplicateAliasError(name));
          this.aliases[name] = def[k];
          return false;
        }
        if (k in this.aliases)
          throwParseError(writeDuplicateAliasError(k));
        this.aliases[k] = def[k];
        return true;
      });
      if (this.ambient) {
        this.ambient.export();
        this.resolutions = flatMorph(this.ambient.resolutions, (alias, resolution) => [
          alias,
          hasArkKind(resolution, "root") ? resolution.bindScope(this) : resolution
        ]);
      }
      scopesById[this.id] = this;
    }
    /** @internal */
    get keywords() {
      return _b6.keywords;
    }
    get ambient() {
      return this.constructor.ambient;
    }
    get raw() {
      return this;
    }
    schema(def, opts) {
      return this.node(schemaKindOf(def), def, opts);
    }
    defineRoot(def) {
      return def;
    }
    units(values, opts) {
      const uniqueValues = [];
      for (const value of values)
        if (!uniqueValues.includes(value))
          uniqueValues.push(value);
      const branches = uniqueValues.map((unit) => this.node("unit", { unit }, opts));
      return this.node("union", branches, {
        ...opts,
        prereduced: true
      });
    }
    lazilyResolve(resolve, syntheticAlias) {
      if (!syntheticAlias) {
        nodeCountsByPrefix.synthetic ?? (nodeCountsByPrefix.synthetic = 0);
        syntheticAlias = `synthetic${++nodeCountsByPrefix.synthetic}`;
      }
      const node2 = this.node("alias", {
        alias: syntheticAlias,
        resolve
      }, { prereduced: true });
      this.lazyResolutions.push(node2);
      return node2;
    }
    parseRoot(def, opts) {
      return this.schema(def, opts);
    }
    resolveRoot(name) {
      return this.maybeResolveRoot(name) ?? throwParseError(writeUnresolvableMessage(name));
    }
    maybeResolveRoot(name) {
      const result = this.maybeResolveGenericOrRoot(name);
      if (hasArkKind(result, "generic"))
        return;
      return result;
    }
    maybeResolveGenericOrRoot(name) {
      const resolution = this.maybeResolve(name);
      if (hasArkKind(resolution, "module"))
        return throwParseError(writeMissingSubmoduleAccessMessage(name));
      return resolution;
    }
    preparseRoot(def) {
      return def;
    }
    maybeResolve(name) {
      const resolution = this.maybeShallowResolve(name);
      return typeof resolution === "string" ? this.node("alias", { alias: resolution }, { prereduced: true }) : resolution;
    }
    maybeShallowResolve(name) {
      const cached2 = this.resolutions[name];
      if (cached2)
        return cached2;
      let def = this.aliases[name];
      if (!def)
        return this.maybeResolveSubalias(name);
      def = this.preparseRoot(def);
      if (hasArkKind(def, "generic"))
        return this.resolutions[name] = validateUninstantiatedGenericNode(def);
      if (hasArkKind(def, "module"))
        return this.resolutions[name] = def;
      this.resolutions[name] = name;
      return this.resolutions[name] = this.parseRoot(def);
    }
    /** If name is a valid reference to a submodule alias, return its resolution  */
    maybeResolveSubalias(name) {
      return resolveSubalias(this.aliases, name);
    }
    import(...names) {
      return new RootModule(flatMorph(this.export(...names), (alias, value) => [
        `#${alias}`,
        value
      ]));
    }
    export(...names) {
      if (!this._exports) {
        this._exports = {};
        for (const name of this.exportedNames) {
          const resolution = this.maybeResolve(name);
          if (hasArkKind(resolution, "root")) {
            resolution.references.filter((node2) => node2.hasKind("alias")).forEach((aliasNode) => {
              Object.assign(aliasNode.referencesById, aliasNode.resolution.referencesById);
              resolution.references.forEach((ref) => {
                if (aliasNode.id in ref.referencesById)
                  Object.assign(ref.referencesById, aliasNode.referencesById);
              });
            });
          }
          this._exports[name] = resolution;
        }
        this.lazyResolutions.forEach((node2) => node2.resolution);
        this._exportedResolutions = resolutionsOfModule(this, this._exports);
        Object.assign(this.json, flatMorph(this._exportedResolutions, (k, v) => hasArkKind(v, "root") ? [k, v.json] : []));
        Object.assign(this.resolutions, this._exportedResolutions);
        if (this.config.registerKeywords)
          Object.assign(_b6.keywords, this._exportedResolutions);
        this.references = Object.values(this.referencesById);
        if (!this.resolvedConfig.jitless)
          bindCompiledScope(this.references);
        this.resolved = true;
      }
      const namesToExport = names.length ? names : this.exportedNames;
      return new RootModule(flatMorph(namesToExport, (_, name) => [
        name,
        this._exports[name]
      ]));
    }
    resolve(name) {
      return this.export()[name];
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    _schema_decorators = [bound];
    _defineRoot_decorators = [bound];
    _units_decorators = [bound];
    __esDecorate4(_b6, null, _schema_decorators, { kind: "method", name: "schema", static: false, private: false, access: { has: (obj) => "schema" in obj, get: (obj) => obj.schema }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate4(_b6, null, _defineRoot_decorators, { kind: "method", name: "defineRoot", static: false, private: false, access: { has: (obj) => "defineRoot" in obj, get: (obj) => obj.defineRoot }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate4(_b6, null, _units_decorators, { kind: "method", name: "units", static: false, private: false, access: { has: (obj) => "units" in obj, get: (obj) => obj.units }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_b6, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), // these allow builtin types to be accessed during parsing without cyclic imports
  // they are populated as each scope is parsed with `registerKeywords` in its config
  /** @internal */
  __publicField(_b6, "keywords", {}), __publicField(_b6, "ambient"), _b6;
})();
var resolveSubalias = (base, name) => {
  const dotIndex = name.indexOf(".");
  if (dotIndex === -1)
    return;
  const dotPrefix = name.slice(0, dotIndex);
  const prefixSchema = base[dotPrefix];
  if (prefixSchema === void 0)
    return;
  if (!hasArkKind(prefixSchema, "module"))
    return throwParseError(writeNonSubmoduleDotMessage(dotPrefix));
  const subalias = name.slice(dotIndex + 1);
  const resolution = prefixSchema[subalias];
  if (resolution === void 0) {
    if (hasArkKind(resolution, "module"))
      return resolveSubalias(resolution, subalias);
    return throwParseError(writeUnresolvableMessage(name));
  }
  if (hasArkKind(resolution, "root") || hasArkKind(resolution, "generic"))
    return resolution;
  throwInternalError(`Unexpected resolution for alias '${name}': ${printable(resolution)}`);
};
var schemaScope = (aliases, config) => new RootScope(aliases, config);
var RootScope = RawRootScope;
var root = new RootScope({});
var schema = root.schema;
var node = root.node;
var defineRoot = root.defineRoot;
var units = root.units;
var rawSchema = root.raw.schema;
var rawNode = root.raw.node;
var defineRawRoot = root.raw.defineRoot;
var rawUnits = root.raw.units;
var resolutionsOfModule = ($, typeSet) => {
  const result = {};
  for (const k in typeSet) {
    const v = typeSet[k];
    if (hasArkKind(v, "module")) {
      const innerResolutions = resolutionsOfModule($, v);
      const prefixedResolutions = flatMorph(innerResolutions, (innerK, innerV) => [`${k}.${innerK}`, innerV]);
      Object.assign(result, prefixedResolutions);
    } else if (hasArkKind(v, "generic"))
      result[k] = v;
    else if (hasArkKind(v, "root"))
      result[k] = v;
    else
      throwInternalError(`Unexpected scope resolution ${printable(v)}`);
  }
  return result;
};
var writeUnresolvableMessage = (token) => `'${token}' is unresolvable`;
var writeNonSubmoduleDotMessage = (name) => `'${name}' must reference a module to be accessed using dot syntax`;
var writeMissingSubmoduleAccessMessage = (name) => `Reference to submodule '${name}' must specify an alias`;
var bindCompiledScope = (references) => {
  const compiledTraversals = compileScope(references);
  for (const node2 of references) {
    if (node2.jit) {
      continue;
    }
    node2.jit = true;
    node2.traverseAllows = compiledTraversals[`${node2.id}Allows`].bind(compiledTraversals);
    if (node2.isRoot() && !node2.allowsRequiresContext) {
      node2.allows = node2.traverseAllows;
    }
    node2.traverseApply = compiledTraversals[`${node2.id}Apply`].bind(compiledTraversals);
  }
};
var compileScope = (references) => new CompiledFunction().block("return", (js) => {
  references.forEach((node2) => {
    const allowsCompiler = new NodeCompiler("Allows").indent();
    node2.compile(allowsCompiler);
    const applyCompiler = new NodeCompiler("Apply").indent();
    node2.compile(applyCompiler);
    js.line(`${allowsCompiler.writeMethod(`${node2.id}Allows`)},`).line(`${applyCompiler.writeMethod(`${node2.id}Apply`)},`);
  });
  return js;
}).compile()();

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/tsKeywords.js
var tsKeywords = schemaScope({
  any: {},
  bigint: "bigint",
  // since we know this won't be reduced, it can be safely cast to a union
  boolean: [{ unit: false }, { unit: true }],
  false: { unit: false },
  never: [],
  null: { unit: null },
  number: "number",
  object: "object",
  string: "string",
  symbol: "symbol",
  true: { unit: true },
  unknown: {},
  void: { unit: void 0 },
  undefined: { unit: void 0 }
}, { prereducedAliases: true, registerKeywords: true }).export();

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/internal.js
var internalKeywords = schemaScope({
  lengthBoundable: ["string", Array],
  propertyKey: ["string", "symbol"],
  nonNegativeIntegerString: { domain: "string", regex: arrayIndexMatcher }
}, {
  prereducedAliases: true,
  registerKeywords: true
}).export();
root.node("union", {
  branches: [
    "string",
    "number",
    "object",
    "bigint",
    "symbol",
    { unit: true },
    { unit: false },
    { unit: null },
    { unit: void 0 }
  ]
}, { reduceTo: root.node("intersection", {}, { prereduced: true }) });

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/jsObjects.js
var jsObjects = schemaScope({
  Array,
  Function,
  Date,
  Error,
  Map,
  RegExp,
  Set,
  WeakMap,
  WeakSet,
  Promise
}, { prereducedAliases: true, registerKeywords: true }).export();

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/utils/date.js
var dayDelimiterMatcher = /^[./-]$/;
var iso8601Matcher = /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
var isValidDateInstance = (date2) => !Number.isNaN(+date2);
var writeFormattedExpected = (format) => `a ${format}-formatted date`;
var tryParseDatePattern = (data, opts) => {
  if (!(opts == null ? void 0 : opts.format)) {
    const result = new Date(data);
    return isValidDateInstance(result) ? result : "a valid date";
  }
  if (opts.format === "iso8601") {
    return iso8601Matcher.test(data) ? new Date(data) : writeFormattedExpected("iso8601");
  }
  const dataParts = data.split(dayDelimiterMatcher);
  const delimiter = data[dataParts[0].length];
  const formatParts = delimiter ? opts.format.split(delimiter) : [opts.format];
  if (dataParts.length !== formatParts.length)
    return writeFormattedExpected(opts.format);
  const parsedParts = {};
  for (let i = 0; i < formatParts.length; i++) {
    if (dataParts[i].length !== formatParts[i].length && // if format is "m" or "d", data is allowed to be 1 or 2 characters
    !(formatParts[i].length === 1 && dataParts[i].length === 2))
      return writeFormattedExpected(opts.format);
    parsedParts[formatParts[i][0]] = dataParts[i];
  }
  const date2 = /* @__PURE__ */ new Date(`${parsedParts.m}/${parsedParts.d}/${parsedParts.y}`);
  if (`${date2.getDate()}` === parsedParts.d)
    return date2;
  return writeFormattedExpected(opts.format);
};

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/utils/regex.js
var defineRegex = (regex, description) => root.defineRoot({
  domain: "string",
  regex: {
    rule: regex.source,
    flags: regex.flags,
    description
  }
});

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/parsing.js
var number = root.defineRoot({
  in: defineRegex(wellFormedNumberMatcher, "a well-formed numeric string"),
  morphs: (s) => Number.parseFloat(s)
});
var integer = root.defineRoot({
  in: defineRegex(wellFormedIntegerMatcher, "a well-formed integer string"),
  morphs: (s, ctx) => {
    if (!isWellFormedInteger(s))
      return ctx.error("a well-formed integer string");
    const parsed = Number.parseInt(s);
    return Number.isSafeInteger(parsed) ? parsed : ctx.error("an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER");
  }
});
var url = root.defineRoot({
  in: "string",
  morphs: (s, ctx) => {
    try {
      return new URL(s);
    } catch {
      return ctx.error("a valid URL");
    }
  }
});
var json = root.defineRoot({
  in: "string",
  morphs: (s, ctx) => {
    try {
      return JSON.parse(s);
    } catch {
      return ctx.error("a valid JSON string");
    }
  }
});
var date = root.defineRoot({
  in: "string",
  morphs: (s, ctx) => {
    const result = tryParseDatePattern(s);
    return typeof result === "string" ? ctx.error(result) : result;
  }
});
var parsing = schemaScope({
  url,
  number,
  integer,
  date,
  json
}).export();

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/utils/creditCard.js
var isLuhnValid = (creditCardInput) => {
  const sanitized = creditCardInput.replace(/[- ]+/g, "");
  let sum = 0;
  let digit;
  let tmpNum;
  let shouldDouble = false;
  for (let i = sanitized.length - 1; i >= 0; i--) {
    digit = sanitized.substring(i, i + 1);
    tmpNum = Number.parseInt(digit, 10);
    if (shouldDouble) {
      tmpNum *= 2;
      if (tmpNum >= 10)
        sum += tmpNum % 10 + 1;
      else
        sum += tmpNum;
    } else
      sum += tmpNum;
    shouldDouble = !shouldDouble;
  }
  return !!(sum % 10 === 0 ? sanitized : false);
};
var creditCardMatcher = /^(?:4[0-9]{12}(?:[0-9]{3,6})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12,15}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14}|^(81[0-9]{14,17}))$/;

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/utils/ip.js
var ipv4Segment = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
var ipv4Address = `(${ipv4Segment}[.]){3}${ipv4Segment}`;
var ipv4Matcher = new RegExp(`^${ipv4Address}$`);
var ipv4 = defineRegex(ipv4Matcher, "a valid IPv4 address");
var ipv6Segment = "(?:[0-9a-fA-F]{1,4})";
var ipv6Matcher = new RegExp(`^((?:${ipv6Segment}:){7}(?:${ipv6Segment}|:)|(?:${ipv6Segment}:){6}(?:${ipv4Address}|:${ipv6Segment}|:)|(?:${ipv6Segment}:){5}(?::${ipv4Address}|(:${ipv6Segment}){1,2}|:)|(?:${ipv6Segment}:){4}(?:(:${ipv6Segment}){0,1}:${ipv4Address}|(:${ipv6Segment}){1,3}|:)|(?:${ipv6Segment}:){3}(?:(:${ipv6Segment}){0,2}:${ipv4Address}|(:${ipv6Segment}){1,4}|:)|(?:${ipv6Segment}:){2}(?:(:${ipv6Segment}){0,3}:${ipv4Address}|(:${ipv6Segment}){1,5}|:)|(?:${ipv6Segment}:){1}(?:(:${ipv6Segment}){0,4}:${ipv4Address}|(:${ipv6Segment}){1,6}|:)|(?::((?::${ipv6Segment}){0,5}:${ipv4Address}|(?::${ipv6Segment}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`);
var ipv6 = defineRegex(ipv6Matcher, "a valid IPv6 address");
var ip = root.defineRoot([ipv4, ipv6]);

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/validation.js
var url2 = root.defineRoot({
  domain: "string",
  predicate: {
    predicate: (s) => {
      try {
        new URL(s);
      } catch {
        return false;
      }
      return true;
    },
    description: "a valid URL"
  }
});
var emailMatcher = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$/;
var email = defineRegex(emailMatcher, "a valid email");
var uuidMatcher = /^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$/;
var uuid = defineRegex(uuidMatcher, "a valid UUID");
var semverMatcher = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
var semver = defineRegex(semverMatcher, "a valid semantic version (see https://semver.org/)");
var creditCard = root.defineRoot({
  domain: "string",
  regex: {
    rule: creditCardMatcher.source,
    description: "a valid credit card number"
  },
  predicate: {
    predicate: isLuhnValid,
    description: "a valid credit card number"
  }
});
var validation = schemaScope({
  alpha: defineRegex(/^[A-Za-z]*$/, "only letters"),
  alphanumeric: defineRegex(/^[A-Za-z\d]*$/, "only letters and digits 0-9"),
  digits: defineRegex(/^\d*$/, "only digits 0-9"),
  lowercase: defineRegex(/^[a-z]*$/, "only lowercase letters"),
  uppercase: defineRegex(/^[A-Z]*$/, "only uppercase letters"),
  creditCard,
  email,
  uuid,
  url: url2,
  semver,
  ip,
  integer: {
    domain: "number",
    divisor: 1
  }
}, { prereducedAliases: true }).export();

// node_modules/.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/keywords.js
var ambientRootScope = schemaScope({
  ...tsKeywords,
  ...jsObjects,
  ...validation,
  parse: parsing
  // TODO: remove cast
});
RawRootScope.ambient = ambientRootScope.raw;
var keywordNodes = ambientRootScope.export();

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/generic.js
var _a7, _b5;
var Generic = class extends (_b5 = Callable, _a7 = arkKind, _b5) {
  constructor(params, def, $) {
    super((...args) => {
      args;
      return $.parseRoot(def);
    });
    __publicField(this, "params");
    __publicField(this, "def");
    __publicField(this, "$");
    __publicField(this, _a7, "generic");
    this.params = params;
    this.def = def;
    this.$ = $;
  }
};

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/match.js
var createMatchParser = ($) => (() => {
}).bind($);

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/scanner.js
var Scanner = class _Scanner {
  constructor(def) {
    __publicField(this, "chars");
    __publicField(this, "i");
    this.chars = [...def];
    this.i = 0;
  }
  /** Get lookahead and advance scanner by one */
  shift() {
    return this.chars[this.i++] ?? "";
  }
  get lookahead() {
    return this.chars[this.i] ?? "";
  }
  get nextLookahead() {
    return this.chars[this.i + 1] ?? "";
  }
  get length() {
    return this.chars.length;
  }
  shiftUntil(condition) {
    let shifted = "";
    while (this.lookahead) {
      if (condition(this, shifted)) {
        if (shifted[shifted.length - 1] === _Scanner.escapeToken)
          shifted = shifted.slice(0, -1);
        else
          break;
      }
      shifted += this.shift();
    }
    return shifted;
  }
  shiftUntilNextTerminator() {
    this.shiftUntilNonWhitespace();
    return this.shiftUntil(_Scanner.lookaheadIsTerminator);
  }
  shiftUntilNonWhitespace() {
    return this.shiftUntil(_Scanner.lookaheadIsNotWhitespace);
  }
  jumpToIndex(i) {
    this.i = i < 0 ? this.length + i : i;
  }
  get location() {
    return this.i;
  }
  get unscanned() {
    return this.chars.slice(this.i, this.length).join("");
  }
  get scanned() {
    return this.chars.slice(0, this.i).join("");
  }
  sliceChars(start, end) {
    return this.chars.slice(start, end).join("");
  }
  lookaheadIs(char) {
    return this.lookahead === char;
  }
  lookaheadIsIn(tokens) {
    return this.lookahead in tokens;
  }
};
(function(Scanner2) {
  Scanner2.lookaheadIsTerminator = (scanner) => scanner.lookahead in Scanner2.terminatingChars;
  Scanner2.lookaheadIsNotWhitespace = (scanner) => !(scanner.lookahead in Scanner2.whiteSpaceTokens);
  Scanner2.terminatingChars = {
    "<": true,
    ">": true,
    "=": true,
    "|": true,
    "&": true,
    ")": true,
    "[": true,
    "%": true,
    " ": true,
    ",": true
  };
  Scanner2.finalizingLookaheads = {
    ">": true,
    ",": true,
    "": true
  };
  Scanner2.escapeToken = "\\";
  Scanner2.whiteSpaceTokens = {
    " ": true,
    "\n": true,
    "	": true
  };
  Scanner2.lookaheadIsFinalizing = (lookahead, unscanned) => lookahead === ">" ? unscanned[0] === "=" ? (
    // >== would only occur in an expression like Array<number>==5
    // otherwise, >= would only occur as part of a bound like number>=5
    unscanned[1] === "="
  ) : unscanned.trimStart() === "" || isKeyOf(unscanned.trimStart()[0], Scanner2.terminatingChars) : lookahead === ",";
})(Scanner || (Scanner = {}));

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/objectLiteral.js
var parseObjectLiteral = (def, ctx) => {
  var _a8;
  let spread;
  const structure = {};
  const parsedEntries = stringAndSymbolicEntriesOf(def).map(parseEntry);
  if (((_a8 = parsedEntries[0]) == null ? void 0 : _a8.kind) === "...") {
    const spreadEntry = parsedEntries.shift();
    const spreadNode = ctx.$.parse(spreadEntry.value, ctx);
    if (!spreadNode.hasKind("intersection") || !spreadNode.structure) {
      return throwParseError(writeInvalidSpreadTypeMessage(typeof spreadEntry.value === "string" ? spreadEntry.value : printable(spreadEntry.value)));
    }
    spread = spreadNode.structure;
  }
  for (const entry of parsedEntries) {
    if (entry.kind === "...")
      return throwParseError(nonLeadingSpreadError);
    if (entry.kind === "+") {
      if (entry.value !== "reject" && entry.value !== "delete" && entry.value !== "ignore")
        throwParseError(writeInvalidUndeclaredBehaviorMessage(entry.value));
      structure.undeclared = entry.value;
      continue;
    }
    if (entry.kind === "index") {
      const key = ctx.$.parse(entry.key, ctx);
      const value = ctx.$.parse(entry.value, ctx);
      const normalizedSignature = normalizeIndex(key, value, ctx.$);
      if (normalizedSignature.required) {
        structure.required = append(structure.required, normalizedSignature.required);
      }
      if (normalizedSignature.index)
        structure.index = append(structure.index, normalizedSignature.index);
    } else {
      const value = ctx.$.parse(entry.value, ctx);
      const inner = { key: entry.key, value };
      if (entry.default !== unset) {
        const out = value(entry.default);
        if (out instanceof ArkErrors)
          throwParseError(`Default value at ${printable(entry.key)} ${out}`);
        value.assert(entry.default);
        inner.default = entry.default;
      }
      structure[entry.kind] = append(structure[entry.kind], inner);
    }
  }
  const structureNode = ctx.$.node("structure", structure);
  return ctx.$.schema({
    domain: "object",
    structure: (spread == null ? void 0 : spread.merge(structureNode)) ?? structureNode
  });
};
var writeInvalidUndeclaredBehaviorMessage = (actual) => `Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${printable(actual)})`;
var nonLeadingSpreadError = "Spread operator may only be used as the first key in an object";
var parseEntry = ([key, value]) => {
  const parsedKey = parseKey(key);
  if (isArray(value) && value[1] === "=") {
    if (parsedKey.kind !== "required")
      throwParseError(invalidDefaultKeyKindMessage);
    return {
      kind: "optional",
      key: parsedKey.key,
      value: value[0],
      default: value[2]
    };
  }
  return {
    kind: parsedKey.kind,
    key: parsedKey.key,
    value,
    default: unset
  };
};
var invalidDefaultKeyKindMessage = `Only required keys may specify default values, e.g. { ark: ['string', '=', '⛵'] }`;
var parseKey = (key) => typeof key === "symbol" ? { kind: "required", key } : key.at(-1) === "?" ? key.at(-2) === Scanner.escapeToken ? { kind: "required", key: `${key.slice(0, -2)}?` } : {
  kind: "optional",
  key: key.slice(0, -1)
} : key[0] === "[" && key.at(-1) === "]" ? { kind: "index", key: key.slice(1, -1) } : key[0] === Scanner.escapeToken && key[1] === "[" && key.at(-1) === "]" ? { kind: "required", key: key.slice(1) } : key === "..." || key === "+" ? { kind: key, key } : {
  kind: "required",
  key: key === "\\..." ? "..." : key === "\\+" ? "+" : key
};
var writeInvalidSpreadTypeMessage = (def) => `Spread operand must resolve to an object literal type (was ${def})`;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/semantic/validate.js
var writePrefixedPrivateReferenceMessage = (def) => `Private type references should not include '#'. Use '${def.slice(1)}' instead.`;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/reduce/shared.js
var minComparators = {
  ">": true,
  ">=": true
};
var maxComparators = {
  "<": true,
  "<=": true
};
var invertedComparators = {
  "<": ">",
  ">": "<",
  "<=": ">=",
  ">=": "<=",
  "==": "=="
};
var writeUnmatchedGroupCloseMessage = (unscanned) => `Unmatched )${unscanned === "" ? "" : ` before ${unscanned}`}`;
var writeUnclosedGroupMessage = (missingChar) => `Missing ${missingChar}`;
var writeOpenRangeMessage = (min, comparator) => `Left bounds are only valid when paired with right bounds (try ...${comparator}${min})`;
var writeUnpairableComparatorMessage = (comparator) => `Left-bounded expressions must specify their limits using < or <= (was ${comparator})`;
var writeMultipleLeftBoundsMessage = (openLimit, openComparator, limit, comparator) => `An expression may have at most one left bound (parsed ${openLimit}${invertedComparators[openComparator]}, ${limit}${invertedComparators[comparator]})`;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operand/genericArgs.js
var parseGenericArgs = (name, params, s) => _parseGenericArgs(name, params, s, [], []);
var _parseGenericArgs = (name, params, s, argDefs, argNodes) => {
  const argState = s.parseUntilFinalizer();
  argDefs.push(argState.scanner.scanned.slice(0, -1));
  argNodes.push(argState.root);
  if (argState.finalizer === ">") {
    if (argNodes.length === params.length) {
      return {
        result: argNodes,
        unscanned: argState.scanner.unscanned
      };
    }
    return argState.error(writeInvalidGenericArgsMessage(name, params, argDefs));
  }
  if (argState.finalizer === ",")
    return _parseGenericArgs(name, params, s, argDefs, argNodes);
  return argState.error(writeUnclosedGroupMessage(">"));
};
var writeInvalidGenericArgsMessage = (name, params, argDefs) => `${name}<${params.join(", ")}> requires exactly ${params.length} args (got ${argDefs.length}${argDefs.length === 0 ? "" : `: ${argDefs.join(", ")}`})`;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operand/unenclosed.js
var parseUnenclosed = (s) => {
  const token = s.scanner.shiftUntilNextTerminator();
  if (token === "keyof")
    s.addPrefix("keyof");
  else
    s.root = unenclosedToNode(s, token);
};
var parseGenericInstantiation = (name, g, s) => {
  s.scanner.shiftUntilNonWhitespace();
  const lookahead = s.scanner.shift();
  if (lookahead !== "<")
    return s.error(writeInvalidGenericArgsMessage(name, g.params, []));
  const parsedArgs = parseGenericArgs(name, g.params, s);
  const remainingChars = parsedArgs.unscanned.length;
  s.scanner.jumpToIndex(remainingChars === 0 ? s.scanner.length : -remainingChars);
  return g(...parsedArgs.result);
};
var unenclosedToNode = (s, token) => maybeParseReference(s, token) ?? maybeParseUnenclosedLiteral(s, token) ?? s.error(token === "" ? writeMissingOperandMessage(s) : token[0] === "#" ? writePrefixedPrivateReferenceMessage(token) : writeUnresolvableMessage(token));
var maybeParseReference = (s, token) => {
  var _a8;
  if ((_a8 = s.ctx.args) == null ? void 0 : _a8[token])
    return s.ctx.args[token].raw;
  const resolution = s.ctx.$.maybeResolve(token);
  if (resolution instanceof BaseRoot)
    return resolution;
  if (resolution === void 0)
    return;
  if (hasArkKind(resolution, "generic"))
    return parseGenericInstantiation(token, resolution, s);
  return throwParseError(`Unexpected resolution ${printable(resolution)}`);
};
var maybeParseUnenclosedLiteral = (s, token) => {
  const maybeNumber = tryParseNumber(token, { strict: true });
  if (maybeNumber !== void 0)
    return s.ctx.$.node("unit", { unit: maybeNumber });
  const maybeBigint = tryParseWellFormedBigint(token);
  if (maybeBigint !== void 0)
    return s.ctx.$.node("unit", { unit: maybeBigint });
};
var writeMissingOperandMessage = (s) => {
  const operator = s.previousOperator();
  return operator ? writeMissingRightOperandMessage(operator, s.scanner.unscanned) : writeExpressionExpectedMessage(s.scanner.unscanned);
};
var writeMissingRightOperandMessage = (token, unscanned = "") => `Token '${token}' requires a right operand${unscanned ? ` before '${unscanned}'` : ""}`;
var writeExpressionExpectedMessage = (unscanned) => `Expected an expression${unscanned ? ` before '${unscanned}'` : ""}`;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/tuple.js
var parseTuple = (def, ctx) => maybeParseTupleExpression(def, ctx) ?? parseTupleLiteral(def, ctx);
var parseTupleLiteral = (def, ctx) => {
  let sequences = [{}];
  let i = 0;
  while (i < def.length) {
    let spread = false;
    let optional = false;
    if (def[i] === "..." && i < def.length - 1) {
      spread = true;
      i++;
    }
    const element = ctx.$.parse(def[i], ctx);
    i++;
    if (def[i] === "?") {
      if (spread)
        return throwParseError(spreadOptionalMessage);
      optional = true;
      i++;
    }
    if (spread) {
      if (!element.extends(jsObjects.Array))
        return throwParseError(writeNonArraySpreadMessage(element.expression));
      sequences = sequences.flatMap((base) => (
        // since appendElement mutates base, we have to shallow-ish clone it for each branch
        element.branches.map((branch) => appendSpreadBranch(makeRootAndArrayPropertiesMutable(base), branch))
      ));
    } else {
      sequences = sequences.map((base) => appendElement(base, optional ? "optional" : "required", element));
    }
  }
  return ctx.$.raw.schema(sequences.map((sequence) => ({
    proto: Array,
    sequence
  })));
};
var appendElement = (base, kind, element) => {
  switch (kind) {
    case "required":
      if (base.optionals)
        return throwParseError(requiredPostOptionalMessage);
      if (base.variadic) {
        base.postfix = append(base.postfix, element);
      } else {
        base.prefix = append(base.prefix, element);
      }
      return base;
    case "optional":
      if (base.variadic)
        return throwParseError(optionalPostVariadicMessage);
      base.optionals = append(base.optionals, element);
      return base;
    case "variadic":
      if (base.postfix)
        throwParseError(multipleVariadicMesage);
      if (base.variadic) {
        if (!base.variadic.equals(element)) {
          throwParseError(multipleVariadicMesage);
        }
      } else {
        base.variadic = element.raw;
      }
      return base;
  }
};
var appendSpreadBranch = (base, branch) => {
  const spread = branch.firstReferenceOfKind("sequence");
  if (!spread) {
    return appendElement(base, "variadic", tsKeywords.unknown);
  }
  spread.prefix.forEach((node2) => appendElement(base, "required", node2));
  spread.optionals.forEach((node2) => appendElement(base, "optional", node2));
  spread.variadic && appendElement(base, "variadic", spread.variadic);
  spread.postfix.forEach((node2) => appendElement(base, "required", node2));
  return base;
};
var maybeParseTupleExpression = (def, ctx) => {
  const tupleExpressionResult = isIndexZeroExpression(def) ? prefixParsers[def[0]](def, ctx) : isIndexOneExpression(def) ? indexOneParsers[def[1]](def, ctx) : void 0;
  return tupleExpressionResult;
};
var writeNonArraySpreadMessage = (operand) => `Spread element must be an array (was ${operand})`;
var multipleVariadicMesage = "A tuple may have at most one variadic element";
var requiredPostOptionalMessage = "A required element may not follow an optional element";
var optionalPostVariadicMessage = "An optional element may not follow a variadic element";
var spreadOptionalMessage = "A spread element cannot be optional";
var parseKeyOfTuple = (def, ctx) => ctx.$.parse(def[1], ctx).keyof();
var parseBranchTuple = (def, ctx) => {
  if (def[2] === void 0)
    return throwParseError(writeMissingRightOperandMessage(def[1], ""));
  const l = ctx.$.parse(def[0], ctx);
  const r = ctx.$.parse(def[2], ctx);
  return def[1] === "&" ? l.and(r) : l.or(r);
};
var parseArrayTuple = (def, ctx) => ctx.$.parse(def[0], ctx).array();
var isIndexOneExpression = (def) => indexOneParsers[def[1]] !== void 0;
var parseMorphTuple = (def, ctx) => {
  if (typeof def[2] !== "function") {
    return throwParseError(writeMalformedFunctionalExpressionMessage("=>", def[2]));
  }
  return ctx.$.parse(def[0], ctx).pipe(def[2]);
};
var writeMalformedFunctionalExpressionMessage = (operator, value) => `${operator === ":" ? "Narrow" : "Morph"} expression requires a function following '${operator}' (was ${typeof value})`;
var parseNarrowTuple = (def, ctx) => {
  if (typeof def[2] !== "function") {
    return throwParseError(writeMalformedFunctionalExpressionMessage(":", def[2]));
  }
  return ctx.$.parse(def[0], ctx).constrain("predicate", def[2]);
};
var parseAttributeTuple = (def, ctx) => ctx.$.parse(def[0], ctx).configureShallowDescendants(def[2]);
var indexOneParsers = {
  "|": parseBranchTuple,
  "&": parseBranchTuple,
  "[]": parseArrayTuple,
  ":": parseNarrowTuple,
  "=>": parseMorphTuple,
  "@": parseAttributeTuple
};
var prefixParsers = {
  keyof: parseKeyOfTuple,
  instanceof: (def, ctx) => {
    if (typeof def[1] !== "function") {
      return throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(def[1])));
    }
    const branches = def.slice(1).map((ctor) => typeof ctor === "function" ? ctx.$.node("proto", { proto: ctor }) : throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(ctor))));
    return branches.length === 1 ? branches[0] : ctx.$.node("union", { branches });
  },
  "===": (def, ctx) => ctx.$.units(def.slice(1))
};
var isIndexZeroExpression = (def) => prefixParsers[def[0]] !== void 0;
var writeInvalidConstructorMessage = (actual) => `Expected a constructor following 'instanceof' operator (was ${actual})`;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/definition.js
var parseObject = (def, ctx) => {
  const objectKind = objectKindOf(def);
  switch (objectKind) {
    case void 0:
      if (hasArkKind(def, "root"))
        return def;
      return parseObjectLiteral(def, ctx);
    case "Array":
      return parseTuple(def, ctx);
    case "RegExp":
      return ctx.$.node("intersection", {
        domain: "string",
        regex: def
      }, { prereduced: true });
    case "Function": {
      const resolvedDef = isThunk(def) ? def() : def;
      if (hasArkKind(resolvedDef, "root"))
        return resolvedDef;
      return throwParseError(writeBadDefinitionTypeMessage("Function"));
    }
    default:
      return throwParseError(writeBadDefinitionTypeMessage(objectKind ?? printable(def)));
  }
};
var writeBadDefinitionTypeMessage = (actual) => `Type definitions must be strings or objects (was ${actual})`;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operand/date.js
var isDateLiteral = (value) => typeof value === "string" && value[0] === "d" && (value[1] === "'" || value[1] === '"') && value.at(-1) === value[1];
var isValidDate = (d) => d.toString() !== "Invalid Date";
var extractDateLiteralSource = (literal) => literal.slice(2, -1);
var writeInvalidDateMessage = (source) => `'${source}' could not be parsed by the Date constructor`;
var tryParseDate = (source, errorOnFail) => maybeParseDate(source, errorOnFail);
var maybeParseDate = (source, errorOnFail) => {
  const stringParsedDate = new Date(source);
  if (isValidDate(stringParsedDate))
    return stringParsedDate;
  const epochMillis = tryParseNumber(source);
  if (epochMillis !== void 0) {
    const numberParsedDate = new Date(epochMillis);
    if (isValidDate(numberParsedDate))
      return numberParsedDate;
  }
  return errorOnFail ? throwParseError(errorOnFail === true ? writeInvalidDateMessage(source) : errorOnFail) : void 0;
};

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operator/bounds.js
var parseBound = (s, start) => {
  const comparator = shiftComparator(s, start);
  if (s.root.hasKind("unit")) {
    if (typeof s.root.unit === "number") {
      s.reduceLeftBound(s.root.unit, comparator);
      s.unsetRoot();
      return;
    }
    if (s.root.unit instanceof Date) {
      const literal = `d'${s.root.description ?? s.root.unit.toISOString()}'`;
      s.unsetRoot();
      s.reduceLeftBound(literal, comparator);
      return;
    }
  }
  return parseRightBound(s, comparator);
};
var oneCharComparators = {
  "<": true,
  ">": true
};
var comparatorStartChars = {
  "<": 1,
  ">": 1,
  "=": 1
};
var shiftComparator = (s, start) => s.scanner.lookaheadIs("=") ? `${start}${s.scanner.shift()}` : isKeyOf(start, oneCharComparators) ? start : s.error(singleEqualsMessage);
var getBoundKinds = (comparator, limit, root2, boundKind) => {
  if (root2.extends(tsKeywords.number)) {
    if (typeof limit !== "number") {
      return throwParseError(writeInvalidLimitMessage(comparator, limit, boundKind));
    }
    return comparator === "==" ? ["min", "max"] : comparator[0] === ">" ? ["min"] : ["max"];
  }
  if (root2.extends(internalKeywords.lengthBoundable)) {
    if (typeof limit !== "number") {
      return throwParseError(writeInvalidLimitMessage(comparator, limit, boundKind));
    }
    return comparator === "==" ? ["minLength", "maxLength"] : comparator[0] === ">" ? ["minLength"] : ["maxLength"];
  }
  if (root2.extends(jsObjects.Date)) {
    return comparator === "==" ? ["after", "before"] : comparator[0] === ">" ? ["after"] : ["before"];
  }
  return throwParseError(writeUnboundableMessage(root2.expression));
};
var singleEqualsMessage = "= is not a valid comparator. Use == to check for equality";
var openLeftBoundToRoot = (leftBound) => ({
  rule: isDateLiteral(leftBound.limit) ? extractDateLiteralSource(leftBound.limit) : leftBound.limit,
  exclusive: leftBound.comparator.length === 1
});
var parseRightBound = (s, comparator) => {
  const previousRoot = s.unsetRoot();
  const previousScannerIndex = s.scanner.location;
  s.parseOperand();
  const limitNode = s.unsetRoot();
  const limitToken = s.scanner.sliceChars(previousScannerIndex, s.scanner.location);
  s.root = previousRoot;
  if (!limitNode.hasKind("unit") || typeof limitNode.unit !== "number" && !(limitNode.unit instanceof Date))
    return s.error(writeInvalidLimitMessage(comparator, limitToken, "right"));
  const limit = limitNode.unit;
  const exclusive = comparator.length === 1;
  for (const kind of getBoundKinds(comparator, typeof limit === "number" ? limit : limitToken, previousRoot, "right"))
    s.constrainRoot(kind, { rule: limit, exclusive });
  if (!s.branches.leftBound)
    return;
  if (!isKeyOf(comparator, maxComparators))
    return s.error(writeUnpairableComparatorMessage(comparator));
  const lowerBoundKind = getBoundKinds(s.branches.leftBound.comparator, s.branches.leftBound.limit, previousRoot, "left");
  s.constrainRoot(lowerBoundKind[0], openLeftBoundToRoot(s.branches.leftBound));
  s.branches.leftBound = null;
};
var writeInvalidLimitMessage = (comparator, limit, boundKind) => `Comparator ${boundKind === "left" ? invertedComparators[comparator] : comparator} must be ${boundKind === "left" ? "preceded" : "followed"} by a corresponding literal (was ${limit})`;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operator/divisor.js
var parseDivisor = (s) => {
  const divisorToken = s.scanner.shiftUntilNextTerminator();
  const divisor = tryParseInteger(divisorToken, {
    errorOnFail: writeInvalidDivisorMessage(divisorToken)
  });
  if (divisor === 0)
    s.error(writeInvalidDivisorMessage(0));
  s.root = s.root.constrain("divisor", divisor);
};
var writeInvalidDivisorMessage = (divisor) => `% operator must be followed by a non-zero integer literal (was ${divisor})`;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operator/operator.js
var parseOperator = (s) => {
  const lookahead = s.scanner.shift();
  return lookahead === "" ? s.finalize("") : lookahead === "[" ? s.scanner.shift() === "]" ? s.setRoot(s.root.array()) : s.error(incompleteArrayTokenMessage) : lookahead === "|" || lookahead === "&" ? s.pushRootToBranch(lookahead) : lookahead === ")" ? s.finalizeGroup() : Scanner.lookaheadIsFinalizing(lookahead, s.scanner.unscanned) ? s.finalize(lookahead) : isKeyOf(lookahead, comparatorStartChars) ? parseBound(s, lookahead) : lookahead === "%" ? parseDivisor(s) : lookahead === " " ? parseOperator(s) : s.error(writeUnexpectedCharacterMessage(lookahead));
};
var writeUnexpectedCharacterMessage = (char, shouldBe = "") => `'${char}' is not allowed here${shouldBe && ` (should be ${shouldBe})`}`;
var incompleteArrayTokenMessage = `Missing expected ']'`;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/generic.js
var parseGenericParams = (def) => _parseGenericParams(new Scanner(def));
var emptyGenericParameterMessage = "An empty string is not a valid generic parameter name";
var _parseGenericParams = (scanner) => {
  const param = scanner.shiftUntilNextTerminator();
  if (param === "")
    throwParseError(emptyGenericParameterMessage);
  scanner.shiftUntilNonWhitespace();
  const nextNonWhitespace = scanner.shift();
  return nextNonWhitespace === "" ? [param] : nextNonWhitespace === "," ? [param, ..._parseGenericParams(scanner)] : throwParseError(writeUnexpectedCharacterMessage(nextNonWhitespace, ","));
};

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operand/enclosed.js
var parseEnclosed = (s, enclosing) => {
  const enclosed = s.scanner.shiftUntil(untilLookaheadIsClosing[enclosingTokens[enclosing]]);
  if (s.scanner.lookahead === "")
    return s.error(writeUnterminatedEnclosedMessage(enclosed, enclosing));
  s.scanner.shift();
  if (enclosing === "/") {
    new RegExp(enclosed);
    s.root = s.ctx.$.node("intersection", {
      domain: "string",
      regex: enclosed
    }, { prereduced: true });
  } else if (isKeyOf(enclosing, enclosingQuote))
    s.root = s.ctx.$.node("unit", { unit: enclosed });
  else {
    const date2 = tryParseDate(enclosed, writeInvalidDateMessage(enclosed));
    s.root = s.ctx.$.node("unit", { unit: date2, description: enclosed });
  }
};
var enclosingQuote = {
  "'": 1,
  '"': 1
};
var enclosingChar = {
  "/": 1,
  "'": 1,
  '"': 1
};
var enclosingTokens = {
  "d'": "'",
  'd"': '"',
  "'": "'",
  '"': '"',
  "/": "/"
};
var untilLookaheadIsClosing = {
  "'": (scanner) => scanner.lookahead === `'`,
  '"': (scanner) => scanner.lookahead === `"`,
  "/": (scanner) => scanner.lookahead === `/`
};
var enclosingCharDescriptions = {
  '"': "double-quote",
  "'": "single-quote",
  "/": "forward slash"
};
var writeUnterminatedEnclosedMessage = (fragment, enclosingStart) => `${enclosingStart}${fragment} requires a closing ${enclosingCharDescriptions[enclosingTokens[enclosingStart]]}`;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operand/operand.js
var parseOperand = (s) => s.scanner.lookahead === "" ? s.error(writeMissingOperandMessage(s)) : s.scanner.lookahead === "(" ? s.shiftedByOne().reduceGroupOpen() : s.scanner.lookaheadIsIn(enclosingChar) ? parseEnclosed(s, s.scanner.shift()) : s.scanner.lookaheadIsIn(Scanner.whiteSpaceTokens) ? parseOperand(s.shiftedByOne()) : s.scanner.lookahead === "d" ? s.scanner.nextLookahead in enclosingQuote ? parseEnclosed(s, `${s.scanner.shift()}${s.scanner.shift()}`) : parseUnenclosed(s) : parseUnenclosed(s);

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/string.js
var fullStringParse = (s) => {
  s.parseOperand();
  const result = parseUntilFinalizer(s).root;
  if (!result) {
    return throwInternalError(`Root was unexpectedly unset after parsing string '${s.scanner.scanned}'`);
  }
  s.scanner.shiftUntilNonWhitespace();
  if (s.scanner.lookahead) {
    throwParseError(writeUnexpectedCharacterMessage(s.scanner.lookahead));
  }
  return result;
};
var parseUntilFinalizer = (s) => {
  while (s.finalizer === void 0)
    next(s);
  return s;
};
var next = (s) => s.hasRoot() ? s.parseOperator() : s.parseOperand();

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/reduce/dynamic.js
var DynamicState = class _DynamicState {
  constructor(def, ctx) {
    __publicField(this, "ctx");
    __publicField(this, "scanner");
    // set root type to `any` so that all constraints can be applied
    __publicField(this, "root");
    __publicField(this, "branches", {
      prefixes: [],
      leftBound: null,
      intersection: null,
      union: null
    });
    __publicField(this, "finalizer");
    __publicField(this, "groups", []);
    this.ctx = ctx;
    this.scanner = new Scanner(def);
  }
  error(message) {
    return throwParseError(message);
  }
  hasRoot() {
    return this.root !== void 0;
  }
  setRoot(root2) {
    this.root = root2;
  }
  unsetRoot() {
    const value = this.root;
    this.root = void 0;
    return value;
  }
  constrainRoot(...args) {
    this.root = this.root.constrain(args[0], args[1]);
  }
  finalize(finalizer) {
    if (this.groups.length)
      return this.error(writeUnclosedGroupMessage(")"));
    this.finalizeBranches();
    this.finalizer = finalizer;
  }
  reduceLeftBound(limit, comparator) {
    const invertedComparator = invertedComparators[comparator];
    if (!isKeyOf(invertedComparator, minComparators))
      return this.error(writeUnpairableComparatorMessage(comparator));
    if (this.branches.leftBound) {
      return this.error(writeMultipleLeftBoundsMessage(this.branches.leftBound.limit, this.branches.leftBound.comparator, limit, invertedComparator));
    }
    this.branches.leftBound = {
      comparator: invertedComparator,
      limit
    };
  }
  finalizeBranches() {
    this.assertRangeUnset();
    if (this.branches.union) {
      this.pushRootToBranch("|");
      this.root = this.branches.union;
    } else if (this.branches.intersection) {
      this.pushRootToBranch("&");
      this.root = this.branches.intersection;
    } else
      this.applyPrefixes();
  }
  finalizeGroup() {
    this.finalizeBranches();
    const topBranchState = this.groups.pop();
    if (!topBranchState)
      return this.error(writeUnmatchedGroupCloseMessage(this.scanner.unscanned));
    this.branches = topBranchState;
  }
  addPrefix(prefix) {
    this.branches.prefixes.push(prefix);
  }
  applyPrefixes() {
    while (this.branches.prefixes.length) {
      const lastPrefix = this.branches.prefixes.pop();
      this.root = lastPrefix === "keyof" ? this.root.keyof() : throwInternalError(`Unexpected prefix '${lastPrefix}'`);
    }
  }
  pushRootToBranch(token) {
    var _a8, _b6;
    this.assertRangeUnset();
    this.applyPrefixes();
    const root2 = this.root;
    this.branches.intersection = ((_a8 = this.branches.intersection) == null ? void 0 : _a8.and(root2)) ?? root2;
    if (token === "|") {
      this.branches.union = ((_b6 = this.branches.union) == null ? void 0 : _b6.or(this.branches.intersection)) ?? this.branches.intersection;
      this.branches.intersection = null;
    }
    this.root = void 0;
  }
  parseUntilFinalizer() {
    return parseUntilFinalizer(new _DynamicState(this.scanner.unscanned, this.ctx));
  }
  parseOperator() {
    return parseOperator(this);
  }
  parseOperand() {
    return parseOperand(this);
  }
  assertRangeUnset() {
    if (this.branches.leftBound) {
      return this.error(writeOpenRangeMessage(this.branches.leftBound.limit, this.branches.leftBound.comparator));
    }
  }
  reduceGroupOpen() {
    this.groups.push(this.branches);
    this.branches = {
      prefixes: [],
      leftBound: null,
      union: null,
      intersection: null
    };
  }
  previousOperator() {
    var _a8;
    return ((_a8 = this.branches.leftBound) == null ? void 0 : _a8.comparator) ?? this.branches.prefixes.at(-1) ?? (this.branches.intersection ? "&" : this.branches.union ? "|" : void 0);
  }
  shiftedByOne() {
    this.scanner.shift();
    return this;
  }
};

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/type.js
var typeParserAttachments = Object.freeze({
  errors: ArkErrors
});
var RawTypeParser = class extends Callable {
  constructor($) {
    super((...args) => {
      if (args.length === 1) {
        return $.parseRoot(args[0]);
      }
      if (args.length === 2 && typeof args[0] === "string" && args[0][0] === "<" && args[0].at(-1) === ">") {
        const params = parseGenericParams(args[0].slice(1, -1));
        const def = args[1];
        return new Generic(params, def, $);
      }
      return $.parseRoot(args);
    }, { bind: $, attach: typeParserAttachments });
  }
};
var Type = BaseRoot;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/scope.js
var scope = (def, config = {}) => new RawScope(def, config);
var RawScope = class extends RawRootScope {
  constructor(def, config) {
    const aliases = {};
    for (const k in def) {
      const parsedKey = parseScopeKey(k);
      aliases[parsedKey.name] = parsedKey.params.length ? (
        // TODO: this
        new Generic(parsedKey.params, def[k], {})
      ) : def[k];
    }
    super(aliases, config);
    __publicField(this, "parseCache", {});
    __publicField(this, "type", new RawTypeParser(this));
    __publicField(this, "match", createMatchParser(this));
    __publicField(this, "declare", (() => ({
      type: this.type
    })).bind(this));
    __publicField(this, "define", ((def) => def).bind(this));
  }
  preparseRoot(def) {
    if (isThunk(def) && !hasArkKind(def, "generic"))
      return def();
    return def;
  }
  parseRoot(def) {
    return this.parse(def, {
      $: this,
      args: {}
      // type parsing can bypass nodes if it hits the cache,
      // so bind it directly (could be optimized)
    }).bindScope(this);
  }
  parse(def, ctx) {
    if (typeof def === "string") {
      if (ctx.args && Object.keys(ctx.args).every((k) => !def.includes(k))) {
        return this.parseString(def, ctx);
      }
      if (!this.parseCache[def])
        this.parseCache[def] = this.parseString(def, ctx);
      return this.parseCache[def];
    }
    return hasDomain(def, "object") ? parseObject(def, ctx) : throwParseError(writeBadDefinitionTypeMessage(domainOf(def)));
  }
  parseString(def, ctx) {
    var _a8;
    return this.maybeResolveRoot(def) ?? (def.endsWith("[]") && ((_a8 = this.maybeResolveRoot(def.slice(0, -2))) == null ? void 0 : _a8.array()) || fullStringParse(new DynamicState(def, ctx)));
  }
};
var parseScopeKey = (k) => {
  const firstParamIndex = k.indexOf("<");
  if (firstParamIndex === -1) {
    return {
      name: k,
      params: []
    };
  }
  if (k.at(-1) !== ">") {
    throwParseError(`'>' must be the last character of a generic declaration in a scope`);
  }
  return {
    name: k.slice(0, firstParamIndex),
    params: parseGenericParams(k.slice(firstParamIndex + 1, -1))
  };
};

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/ark.js
var ambient = scope(keywordNodes);
RawScope.ambient = ambient.raw;
var ark = ambient.export();
var type = ambient.type;
var match = ambient.match;
var define = ambient.define;
var declare = ambient.declare;

// node_modules/.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/module.js
var Module = RootModule;
export {
  ArkError,
  ArkErrors,
  Module,
  Type,
  ambient,
  ark,
  declare,
  define,
  match,
  scope,
  type
};
//# sourceMappingURL=api-Z6A3VNES.js.map
