{
  "version": 3,
  "sources": ["../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/arrays.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/clone.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/errors.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/flatMorph.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/records.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/functions.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/domain.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/objectKinds.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/primitive.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/registry.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/compilation.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/generics.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/hkt.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/numericLiterals.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/serialize.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/strings.js", "../../.pnpm/@arktype+util@0.0.48/node_modules/@arktype/util/out/traits.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/utils.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/implement.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/config.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/errors.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/traversal.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/node.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/disjoint.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/intersections.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/constraint.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/generic.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/predicate.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/divisor.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/range.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/after.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/before.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/exactLength.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/max.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/maxLength.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/min.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/minLength.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/kinds.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/refinements/regex.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/root.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/utils.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/alias.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/basis.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/domain.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/declare.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/intersection.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/morph.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/proto.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/union.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/roots/unit.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/index.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/prop.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/optional.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/required.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/sequence.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/shared.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/structure/structure.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/kinds.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/module.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/parse.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/shared/compile.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/scope.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/tsKeywords.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/internal.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/jsObjects.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/utils/date.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/utils/regex.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/parsing.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/utils/creditCard.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/utils/ip.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/validation.js", "../../.pnpm/@arktype+schema@0.1.13/node_modules/@arktype/schema/out/keywords/keywords.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/generic.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/match.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/scanner.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/objectLiteral.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/semantic/validate.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/reduce/shared.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operand/genericArgs.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operand/unenclosed.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/tuple.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/definition.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operand/date.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operator/bounds.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operator/divisor.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operator/operator.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/generic.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operand/enclosed.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/shift/operand/operand.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/string.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/parser/string/reduce/dynamic.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/type.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/scope.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/ark.js", "../../.pnpm/arktype@2.0.0-dev.21/node_modules/arktype/out/module.js"],
  "sourcesContent": ["export const getPath = (root, path) => {\n    let result = root;\n    for (const segment of path) {\n        if (typeof result !== \"object\" || result === null)\n            return undefined;\n        result = result[segment];\n    }\n    return result;\n};\nexport const intersectUniqueLists = (l, r) => {\n    const intersection = [...l];\n    for (const item of r)\n        if (!l.includes(item))\n            intersection.push(item);\n    return intersection;\n};\nexport const arrayFrom = (data) => (Array.isArray(data) ? data : [data]);\nexport const spliterate = (list, by) => {\n    const result = [[], []];\n    for (const item of list) {\n        if (by(item))\n            result[0].push(item);\n        else\n            result[1].push(item);\n    }\n    return result;\n};\nexport const ReadonlyArray = Array;\nexport const includes = (array, element) => array.includes(element);\nexport const range = (length, offset = 0) => [...new Array(length)].map((_, i) => i + offset);\n/**\n * Adds a value or array to an array, returning the concatenated result\n *\n * @param to The array to which `value` is to be added. If `to` is `undefined`, a new array\n * is created as `[value]` if value was not undefined, otherwise `[]`.\n * @param value The value to add to the array. If `value` is `undefined`, does nothing.\n * @param opts\n * \t\tprepend: If true, adds the element to the beginning of the array instead of the end\n */\nexport const append = (to, value, opts) => {\n    if (value === undefined)\n        return to ?? [];\n    if (to === undefined) {\n        return (value === undefined ? []\n            : Array.isArray(value) ? value\n                : [value]);\n    }\n    if (opts?.prepend)\n        Array.isArray(value) ? to.unshift(...value) : to.unshift(value);\n    else\n        Array.isArray(value) ? to.push(...value) : to.push(value);\n    return to;\n};\n/**\n * Concatenates an element or list with a readonly list\n *\n * @param {to} to - The base list.\n * @param {elementOrList} elementOrList - The element or list to concatenate.\n */\nexport const conflatenate = (to, elementOrList) => {\n    if (elementOrList === undefined || elementOrList === null)\n        return to ?? [];\n    if (to === undefined || to === null)\n        return arrayFrom(elementOrList);\n    return to.concat(elementOrList);\n};\n/**\n * Concatenates a variadic list of elements or lists with a readonly list\n *\n * @param {to} to - The base list.\n * @param {elementsOrLists} elementsOrLists - The elements or lists to concatenate.\n */\nexport const conflatenateAll = (...elementsOrLists) => elementsOrLists.reduce(conflatenate, []);\n/**\n * Appends a value to an array if it is not already included, returning the array\n *\n * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array\n * is created including only `value`.\n * @param value The value to append to the array. If `to` includes `value`, nothing is appended.\n */\nexport const appendUnique = (to, value) => {\n    if (to === undefined)\n        return [value];\n    if (!to.includes(value))\n        to.push(value);\n    return to;\n};\nexport const groupBy = (array, discriminant) => array.reduce((result, item) => {\n    const key = item[discriminant];\n    result[key] ??= [];\n    result[key].push(item);\n    return result;\n}, {});\n", "export const shallowClone = (input) => Object.create(Object.getPrototypeOf(input), Object.getOwnPropertyDescriptors(input));\nexport const deepClone = (input) => _deepClone(input, new Map());\nconst _deepClone = (input, seen) => {\n    if (typeof input !== \"object\" || input === null)\n        return input;\n    if (seen.has(input))\n        return seen.get(input);\n    const cloned = Array.isArray(input) ?\n        // ensure arrays are copied with their original class attached so they\n        // work with Array.isArray\n        input.slice()\n        : Object.create(Object.getPrototypeOf(input));\n    seen.set(input, cloned);\n    const propertyDescriptors = Object.getOwnPropertyDescriptors(input);\n    for (const key of Object.keys(propertyDescriptors)) {\n        propertyDescriptors[key].value = _deepClone(propertyDescriptors[key].value, seen);\n    }\n    Object.defineProperties(cloned, propertyDescriptors);\n    return cloned;\n};\n", "export class InternalArktypeError extends Error {\n}\nexport const throwInternalError = message => throwError(message, InternalArktypeError);\nexport const throwError = (message, ctor = Error) => {\n    throw new ctor(message);\n};\nexport class ParseError extends Error {\n    name = \"ParseError\";\n}\nexport const throwParseError = message => throwError(message, ParseError);\n", "// eslint-disable-next-line prefer-arrow-functions/prefer-arrow-functions\nexport function flatMorph(o, flatMapEntry) {\n    const inputIsArray = Array.isArray(o);\n    const entries = Object.entries(o).flatMap((entry, i) => {\n        const result = inputIsArray ? flatMapEntry(i, entry[1]) : flatMapEntry(...entry, i);\n        const entrySet = Array.isArray(result[0]) || result.length === 0 ?\n            // if we have an empty array (for filtering) or an array with\n            // another array as its first element, treat it as a list of\n            result\n            // otherwise, it should be a single entry, so nest it in a tuple\n            // so it doesn't get spread when the result is flattened\n            : [result];\n        return entrySet;\n    });\n    const objectResult = Object.fromEntries(entries);\n    return typeof entries[0]?.[0] === \"number\" ?\n        Object.values(objectResult)\n        : objectResult;\n}\n", "import { flatMorph } from \"./flatMorph.js\";\nexport const entriesOf = (o) => Object.entries(o);\nexport const fromEntries = (entries) => Object.fromEntries(entries);\nexport const keysOf = (o) => Object.keys(o);\nexport const isKeyOf = (k, o) => k in o;\nexport const hasKey = (o, k) => k in o;\n// must be defined this way to avoid https://github.com/microsoft/TypeScript/issues/55049\nexport const hasDefinedKey = (o, k) => o[k] !== undefined;\nexport const InnerDynamicBase = class {\n    constructor(properties) {\n        Object.assign(this, properties);\n    }\n};\n/** @ts-expect-error (needed to extend `t`, but safe given ShallowClone's implementation) **/\nexport class DynamicBase extends InnerDynamicBase {\n}\nexport const NoopBase = class {\n};\n/** @ts-expect-error (see DynamicBase) **/\nexport class CastableBase extends NoopBase {\n}\nexport const splitByKeys = (o, leftKeys) => {\n    const l = {};\n    const r = {};\n    let k;\n    for (k in o) {\n        if (k in leftKeys)\n            l[k] = o[k];\n        else\n            r[k] = o[k];\n    }\n    return [l, r];\n};\nexport const pick = (o, keys) => splitByKeys(o, keys)[0];\nexport const omit = (o, keys) => splitByKeys(o, keys)[1];\nexport const isEmptyObject = (o) => Object.keys(o).length === 0;\nexport const stringAndSymbolicEntriesOf = (o) => [\n    ...Object.entries(o),\n    ...Object.getOwnPropertySymbols(o).map(k => [k, o[k]])\n];\n/** Like Object.assign, but it will preserve getters instead of evaluating them. */\nexport const defineProperties = (base, merged) => \n// declared like this to avoid https://github.com/microsoft/TypeScript/issues/55049\nObject.defineProperties(base, Object.getOwnPropertyDescriptors(merged));\nexport const invert = (t) => flatMorph(t, (k, v) => [v, k]);\nexport const unset = Symbol(\"represents an uninitialized value\");\n", "import { throwInternalError } from \"./errors.js\";\nimport { NoopBase, unset } from \"./records.js\";\nexport const bound = (target, ctx) => {\n    ctx.addInitializer(function () {\n        this[ctx.name] = this[ctx.name].bind(this);\n    });\n};\nexport const cached = (target, context) => function () {\n    const value = target.call(this);\n    Object.defineProperty(this, context.name, context.kind === \"getter\" ?\n        { value }\n        : {\n            value: () => value,\n            enumerable: false\n        });\n    return value;\n};\nexport const cachedThunk = (thunk) => {\n    let result = unset;\n    return () => (result === unset ? (result = thunk()) : result);\n};\nexport const isThunk = (value) => typeof value === \"function\" && value.length === 0;\nexport const tryCatch = (fn, onError) => {\n    try {\n        return fn();\n    }\n    catch (e) {\n        return onError?.(e);\n    }\n};\nexport const DynamicFunction = class extends Function {\n    constructor(...args) {\n        const params = args.slice(0, -1);\n        const body = args.at(-1);\n        try {\n            super(...params, body);\n        }\n        catch (e) {\n            return throwInternalError(`Encountered an unexpected error while compiling your definition:\n                Message: ${e} \n                Source: (${args.slice(0, -1)}) => {\n                    ${args.at(-1)}\n                }`);\n        }\n    }\n};\n/** @ts-expect-error required to cast function type */\nexport class Callable extends NoopBase {\n    constructor(f, opts) {\n        super();\n        return Object.assign(Object.setPrototypeOf(f.bind(opts?.bind ?? this), this.constructor.prototype), opts?.attach);\n    }\n}\n/**\n * Checks if the environment has Content Security Policy (CSP) enabled,\n * preventing JIT-optimized code from being compiled via new Function().\n *\n * @returns `true` if a function created using new Function() can be\n * successfully invoked in the environment, `false` otherwise.\n *\n * The result is cached for subsequent invocations.\n */\nexport const envHasCsp = cachedThunk(() => {\n    try {\n        return new Function(\"return false\")();\n    }\n    catch (e) {\n        return true;\n    }\n});\n", "export const hasDomain = (data, kind) => domainOf(data) === kind;\nexport const domainOf = (data) => {\n    const builtinType = typeof data;\n    return (builtinType === \"object\" ?\n        data === null ?\n            \"null\"\n            : \"object\"\n        : builtinType === \"function\" ? \"object\"\n            : builtinType);\n};\nconst enumerableDomainDescriptions = {\n    boolean: \"boolean\",\n    null: \"null\",\n    undefined: \"undefined\"\n};\nconst nonEnumerableDomainDescriptions = {\n    bigint: \"a bigint\",\n    number: \"a number\",\n    object: \"an object\",\n    string: \"a string\",\n    symbol: \"a symbol\"\n};\n/** Each domain's completion for the phrase \"must be _____\" */\nexport const domainDescriptions = {\n    ...nonEnumerableDomainDescriptions,\n    ...enumerableDomainDescriptions\n};\n", "import { domainOf } from \"./domain.js\";\nimport { isKeyOf } from \"./records.js\";\n// Built-in object constructors based on a subset of:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\nexport const builtinConstructors = {\n    Array,\n    Date,\n    Error,\n    Function,\n    Map,\n    RegExp,\n    Set,\n    String,\n    Number,\n    Boolean,\n    WeakMap,\n    WeakSet,\n    Promise\n};\nexport const objectKindOf = (data) => {\n    let prototype = Object.getPrototypeOf(data);\n    while (prototype?.constructor &&\n        (!isKeyOf(prototype.constructor.name, builtinConstructors) ||\n            !(data instanceof builtinConstructors[prototype.constructor.name])))\n        prototype = Object.getPrototypeOf(prototype);\n    const name = prototype?.constructor?.name;\n    if (name === undefined || name === \"Object\")\n        return undefined;\n    return name;\n};\nexport const objectKindOrDomainOf = (data) => (typeof data === \"object\" && data !== null ?\n    objectKindOf(data) ?? \"object\"\n    : domainOf(data));\nexport const hasObjectKind = (data, kind) => objectKindOf(data) === kind;\nexport const isArray = (data) => Array.isArray(data);\n/** Each defaultObjectKind's completion for the phrase \"must be _____\" */\nexport const objectKindDescriptions = {\n    Array: \"an array\",\n    Function: \"a function\",\n    Date: \"a Date\",\n    RegExp: \"a RegExp\",\n    Error: \"an Error\",\n    Map: \"a Map\",\n    Set: \"a Set\",\n    String: \"a String object\",\n    Number: \"a Number object\",\n    Boolean: \"a Boolean object\",\n    Promise: \"a Promise\",\n    WeakMap: \"a WeakMap\",\n    WeakSet: \"a WeakSet\"\n};\n// this will only return an object kind if it's the root constructor\n// example TypeError would return undefined not 'Error'\nexport const getExactBuiltinConstructorName = (ctor) => {\n    const constructorName = Object(ctor).name ?? null;\n    return (constructorName &&\n        isKeyOf(constructorName, builtinConstructors) &&\n        builtinConstructors[constructorName] === ctor) ?\n        constructorName\n        : null;\n};\n/**\n * Returns an array of constructors for all ancestors (i.e., prototypes) of a given object.\n *\n * @param {object} o - The object to find the ancestors of.\n * @returns {Function[]} An array of constructors for all ancestors of the object.\n */\nexport const ancestorsOf = (o) => {\n    let proto = Object.getPrototypeOf(o);\n    const result = [];\n    while (proto !== null) {\n        result.push(proto.constructor);\n        proto = Object.getPrototypeOf(proto);\n    }\n    return result;\n};\n/** Mimics output of TS's keyof operator at runtime */\nexport const prototypeKeysOf = (value) => {\n    const result = [];\n    let curr = value;\n    while (curr !== Object.prototype && curr !== null && curr !== undefined) {\n        for (const k of Object.getOwnPropertyNames(curr))\n            if (k !== \"constructor\" && !result.includes(k))\n                result.push(k);\n        for (const symbol of Object.getOwnPropertySymbols(curr))\n            if (!result.includes(symbol))\n                result.push(symbol);\n        curr = Object.getPrototypeOf(curr);\n    }\n    return result;\n};\nconst baseKeysByDomain = {\n    bigint: prototypeKeysOf(0n),\n    boolean: prototypeKeysOf(false),\n    null: [],\n    number: prototypeKeysOf(0),\n    // TS doesn't include the Object prototype in keyof, so keyof object is never\n    object: [],\n    string: prototypeKeysOf(\"\"),\n    symbol: prototypeKeysOf(Symbol()),\n    undefined: []\n};\nexport const getBaseDomainKeys = (domain) => [...baseKeysByDomain[domain]];\nexport const constructorExtends = (ctor, base) => {\n    let current = ctor.prototype;\n    while (current !== null) {\n        if (current === base.prototype)\n            return true;\n        current = Object.getPrototypeOf(current);\n    }\n    return false;\n};\n", "export const serializePrimitive = (value) => (typeof value === \"string\" ? JSON.stringify(value)\n    : typeof value === \"bigint\" ? `${value}n`\n        : `${value}`);\n", "import { domainOf, hasDomain } from \"./domain.js\";\nimport { throwError, throwInternalError } from \"./errors.js\";\nimport { objectKindOf } from \"./objectKinds.js\";\nimport { serializePrimitive } from \"./primitive.js\";\nif (\"$ark\" in globalThis) {\n    throwError(`Tried to initialize an $ark registry but one already existed.\nThis probably means you are either depending on multiple versions of an arktype package,\nor importing the same package from both ESM and CJS.\nReview package.json versions across your repo to ensure consistency.`);\n}\nexport const registry = {};\nglobalThis.$ark = registry;\nconst namesByResolution = new WeakMap();\nconst nameCounts = {};\nexport const register = (value) => {\n    const existingName = namesByResolution.get(value);\n    if (existingName)\n        return existingName;\n    let name = baseNameFor(value);\n    if (nameCounts[name])\n        name = `${name}${nameCounts[name]++}`;\n    else\n        nameCounts[name] = 1;\n    registry[name] = value;\n    namesByResolution.set(value, name);\n    return name;\n};\nexport const reference = (name) => `$ark.${name}`;\nexport const registeredReference = (value) => reference(register(value));\nexport const isDotAccessible = (keyName) => /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(keyName);\nexport const compileSerializedValue = (value) => hasDomain(value, \"object\") || typeof value === \"symbol\" ?\n    registeredReference(value)\n    : serializePrimitive(value);\nconst baseNameFor = (value) => {\n    switch (typeof value) {\n        case \"object\": {\n            if (value === null)\n                break;\n            const prefix = objectKindOf(value) ?? \"object\";\n            // convert to camelCase\n            return prefix[0].toLowerCase() + prefix.slice(1);\n        }\n        case \"function\":\n            return isDotAccessible(value.name) ? value.name : \"fn\";\n        case \"symbol\":\n            return value.description && isDotAccessible(value.description) ?\n                value.description\n                : \"symbol\";\n    }\n    return throwInternalError(`Unexpected attempt to register serializable value of type ${domainOf(value)}`);\n};\n", "import { DynamicFunction } from \"./functions.js\";\nimport { CastableBase } from \"./records.js\";\nimport { isDotAccessible, registeredReference } from \"./registry.js\";\nexport class CompiledFunction extends CastableBase {\n    argNames;\n    body = \"\";\n    constructor(...args) {\n        super();\n        this.argNames = args;\n        for (const arg of args) {\n            if (arg in this) {\n                throw new Error(`Arg name '${arg}' would overwrite an existing property on FunctionBody`);\n            }\n            ;\n            this[arg] = arg;\n        }\n    }\n    indentation = 0;\n    indent() {\n        this.indentation += 4;\n        return this;\n    }\n    dedent() {\n        this.indentation -= 4;\n        return this;\n    }\n    prop(key, optional = false) {\n        return compileLiteralPropAccess(key, optional);\n    }\n    index(key, optional = false) {\n        return indexPropAccess(`${key}`, optional);\n    }\n    line(statement) {\n        ;\n        this.body += `${\" \".repeat(this.indentation)}${statement}\\n`;\n        return this;\n    }\n    const(identifier, expression) {\n        this.line(`const ${identifier} = ${expression}`);\n        return this;\n    }\n    let(identifier, expression) {\n        return this.line(`let ${identifier} = ${expression}`);\n    }\n    set(identifier, expression) {\n        return this.line(`${identifier} = ${expression}`);\n    }\n    if(condition, then) {\n        return this.block(`if (${condition})`, then);\n    }\n    elseIf(condition, then) {\n        return this.block(`else if (${condition})`, then);\n    }\n    else(then) {\n        return this.block(\"else\", then);\n    }\n    /** Current index is \"i\" */\n    for(until, body, initialValue = 0) {\n        return this.block(`for (let i = ${initialValue}; ${until}; i++)`, body);\n    }\n    /** Current key is \"k\" */\n    forIn(object, body) {\n        return this.block(`for (const k in ${object})`, body);\n    }\n    block(prefix, contents, suffix = \"\") {\n        this.line(`${prefix} {`);\n        this.indent();\n        contents(this);\n        this.dedent();\n        return this.line(`}${suffix}`);\n    }\n    return(expression = \"\") {\n        return this.line(`return ${expression}`);\n    }\n    compile() {\n        return new DynamicFunction(...this.argNames, this.body);\n    }\n}\nexport const compileLiteralPropAccess = (key, optional = false) => {\n    if (typeof key === \"string\" && isDotAccessible(key))\n        return `${optional ? \"?\" : \"\"}.${key}`;\n    return indexPropAccess(serializeLiteralKey(key), optional);\n};\nexport const serializeLiteralKey = (key) => typeof key === \"symbol\" ? registeredReference(key) : JSON.stringify(key);\nexport const indexPropAccess = (key, optional = false) => `${optional ? \"?.\" : \"\"}[${key}]`;\n", "export const id = Symbol(\"id\");\nexport const narrow = (t) => t;\n", "/** A small set of HKT utility types based on https://github.com/poteat/hkt-toolbelt */\nexport var Hkt;\n(function (Hkt) {\n    class Kind {\n    }\n    Hkt.Kind = Kind;\n    class Instantiable {\n    }\n    Hkt.Instantiable = Instantiable;\n    Hkt.reify = (def) => def.hkt;\n    class UnaryKind {\n    }\n    Hkt.UnaryKind = UnaryKind;\n    Hkt.pipe = (...kinds) => In => kinds.reduce((out, kind) => kind.hkt(out), In);\n})(Hkt || (Hkt = {}));\n", "import { throwParseError } from \"./errors.js\";\n/**\n * The goal of the number literal and bigint literal regular expressions is to:\n *\n *   1. Ensure definitions form a bijection with the values they represent.\n *   2. Attempt to mirror TypeScript's own format for stringification of numeric\n *      values such that the regex should match a given definition if any only if\n *      a precise literal type will be inferred (in TS4.8+).\n */\n/**\n *  Matches a well-formatted numeric expression according to the following rules:\n *    1. Must include an integer portion (i.e. '.321' must be written as '0.321')\n *    2. The first digit of the value must not be 0, unless the entire integer portion is 0\n *    3. If the value includes a decimal, its last digit may not be 0\n *    4. The value may not be \"-0\"\n */\nexport const wellFormedNumberMatcher = /^(?!^-0$)-?(?:0|[1-9]\\d*)(?:\\.\\d*[1-9])?$/;\nexport const isWellFormedNumber = wellFormedNumberMatcher.test.bind(wellFormedNumberMatcher);\nconst numberLikeMatcher = /^-?\\d*\\.?\\d*$/;\nconst isNumberLike = (s) => s.length !== 0 && numberLikeMatcher.test(s);\n/**\n *  Matches a well-formatted integer according to the following rules:\n *    1. must begin with an integer, the first digit of which cannot be 0 unless the entire value is 0\n *    2. The value may not be \"-0\"\n */\nexport const wellFormedIntegerMatcher = /^(?:0|(?:-?[1-9]\\d*))$/;\nexport const isWellFormedInteger = wellFormedIntegerMatcher.test.bind(wellFormedIntegerMatcher);\nconst integerLikeMatcher = /^-?\\d+$/;\nconst isIntegerLike = integerLikeMatcher.test.bind(integerLikeMatcher);\nconst numericLiteralDescriptions = {\n    number: \"a number\",\n    bigint: \"a bigint\",\n    integer: \"an integer\"\n};\nexport const writeMalformedNumericLiteralMessage = (def, kind) => `'${def}' was parsed as ${numericLiteralDescriptions[kind]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`;\nconst isWellFormed = (def, kind) => kind === \"number\" ? isWellFormedNumber(def) : isWellFormedInteger(def);\nconst parseKind = (def, kind) => kind === \"number\" ? Number(def) : Number.parseInt(def);\nconst isKindLike = (def, kind) => kind === \"number\" ? isNumberLike(def) : isIntegerLike(def);\nexport const tryParseNumber = (token, options) => parseNumeric(token, \"number\", options);\nexport const tryParseInteger = (token, options) => parseNumeric(token, \"integer\", options);\nconst parseNumeric = (token, kind, options) => {\n    const value = parseKind(token, kind);\n    if (!Number.isNaN(value)) {\n        if (isKindLike(token, kind)) {\n            if (options?.strict) {\n                return isWellFormed(token, kind) ? value : (throwParseError(writeMalformedNumericLiteralMessage(token, kind)));\n            }\n            return value;\n        }\n    }\n    return (options?.errorOnFail ?\n        throwParseError(options?.errorOnFail === true ?\n            `Failed to parse ${numericLiteralDescriptions[kind]} from '${token}'`\n            : options?.errorOnFail)\n        : undefined);\n};\nexport const tryParseWellFormedBigint = (def) => {\n    if (def[def.length - 1] !== \"n\")\n        return;\n    const maybeIntegerLiteral = def.slice(0, -1);\n    let value;\n    try {\n        value = BigInt(maybeIntegerLiteral);\n    }\n    catch {\n        return;\n    }\n    if (wellFormedIntegerMatcher.test(maybeIntegerLiteral))\n        return value;\n    if (integerLikeMatcher.test(maybeIntegerLiteral)) {\n        // If the definition looks like a bigint but is\n        // not well-formed, throw.\n        return throwParseError(writeMalformedNumericLiteralMessage(def, \"bigint\"));\n    }\n};\n", "import { domainOf } from \"./domain.js\";\nimport { serializePrimitive } from \"./primitive.js\";\nimport { register } from \"./registry.js\";\nexport const snapshot = (data, opts = { onUndefined: \"(undefined)\" }) => _serialize(data, opts, []);\nexport const print = (data, indent) => console.log(printable(data, indent));\nexport const printable = (data, indent) => {\n    switch (domainOf(data)) {\n        case \"object\":\n            return data instanceof Date ?\n                data.toDateString()\n                : JSON.stringify(_serialize(data, printableOpts, []), null, indent);\n        case \"symbol\":\n            return printableOpts.onSymbol(data);\n        default:\n            return serializePrimitive(data);\n    }\n};\nconst printableOpts = {\n    onCycle: () => \"(cycle)\",\n    onSymbol: v => `Symbol(${register(v)})`,\n    onFunction: v => `Function(${register(v)})`\n};\nconst _serialize = (data, opts, seen) => {\n    switch (domainOf(data)) {\n        case \"object\": {\n            if (typeof data === \"function\")\n                return printableOpts.onFunction(data);\n            if (seen.includes(data))\n                return \"(cycle)\";\n            const nextSeen = [...seen, data];\n            if (Array.isArray(data))\n                return data.map(item => _serialize(item, opts, nextSeen));\n            if (data instanceof Date)\n                return data.toDateString();\n            const result = {};\n            for (const k in data)\n                result[k] = _serialize(data[k], opts, nextSeen);\n            return result;\n        }\n        case \"symbol\":\n            return printableOpts.onSymbol(data);\n        case \"bigint\":\n            return `${data}n`;\n        case \"undefined\":\n            return opts.onUndefined ?? \"undefined\";\n        default:\n            return data;\n    }\n};\n", "export const capitalize = (s) => (s[0].toUpperCase() + s.slice(1));\n", "import { hasDomain } from \"./domain.js\";\nimport { ancestorsOf } from \"./objectKinds.js\";\nimport { NoopBase } from \"./records.js\";\n// even though the value we attach will be identical, we use this so classes\n// won't be treated as instanceof a Trait\nconst implementedTraits = Symbol(\"implementedTraits\");\nexport const hasTrait = (traitClass) => (o) => {\n    if (!hasDomain(o, \"object\"))\n        return false;\n    if (implementedTraits in o.constructor &&\n        o.constructor[implementedTraits].includes(traitClass))\n        return true;\n    // emulate standard instanceof behavior\n    return ancestorsOf(o).includes(traitClass);\n};\n/** @ts-expect-error required to extend NoopBase */\nexport class Trait extends NoopBase {\n    static get [Symbol.hasInstance]() {\n        return hasTrait(this);\n    }\n    traitsOf() {\n        return implementedTraits in this.constructor ?\n            this.constructor[implementedTraits]\n            : [];\n    }\n}\nconst collectPrototypeDescriptors = (trait) => {\n    let proto = trait.prototype;\n    let result = {};\n    do {\n        // ensure prototypes are sorted from lowest to highest precedence\n        result = Object.assign(Object.getOwnPropertyDescriptors(proto), result);\n        proto = Object.getPrototypeOf(proto);\n    } while (proto !== Object.prototype && proto !== null);\n    return result;\n};\nexport const compose = ((...traits) => {\n    const base = function (...args) {\n        for (const trait of traits) {\n            const instance = Reflect.construct(trait, args, this.constructor);\n            Object.assign(this, instance);\n        }\n    };\n    const flatImplementedTraits = [];\n    for (const trait of traits) {\n        // copy static properties\n        Object.assign(base, trait);\n        // flatten and copy prototype\n        Object.defineProperties(base.prototype, collectPrototypeDescriptors(trait));\n        if (implementedTraits in trait) {\n            // add any ancestor traits from which the current trait was composed\n            for (const innerTrait of trait[implementedTraits]) {\n                if (!flatImplementedTraits.includes(innerTrait))\n                    flatImplementedTraits.push(innerTrait);\n            }\n        }\n        if (!flatImplementedTraits.includes(trait))\n            flatImplementedTraits.push(trait);\n    }\n    Object.defineProperty(base, implementedTraits, {\n        value: flatImplementedTraits,\n        enumerable: false\n    });\n    return base;\n});\nexport const implement = (...args) => {\n    if (args.at(-1) instanceof Trait)\n        return compose(...args);\n    const implementation = args.at(-1);\n    const base = compose(...args.slice(0, -1));\n    // copy implementation last since it overrides traits\n    Object.defineProperties(base.prototype, Object.getOwnPropertyDescriptors(implementation));\n    return base;\n};\n", "import { flatMorph, isArray, isDotAccessible, printable } from \"@arktype/util\";\nexport const makeRootAndArrayPropertiesMutable = (o) => \n// TODO: this cast should not be required, but it seems TS is referencing\n// the wrong parameters here?\nflatMorph(o, (k, v) => [k, isArray(v) ? [...v] : v]);\nexport const pathToPropString = (path) => {\n    const propAccessChain = path.reduce((s, k) => typeof k === \"string\" && isDotAccessible(k) ?\n        `${s}.${k}`\n        : `${s}[${printable(k)}]`, \"\");\n    return propAccessChain[0] === \".\" ? propAccessChain.slice(1) : propAccessChain;\n};\nexport const arkKind = Symbol(\"ArkTypeInternalKind\");\nexport const hasArkKind = (value, kind) => value?.[arkKind] === kind;\nexport const isNode = (value) => hasArkKind(value, \"root\") || hasArkKind(value, \"constraint\");\n// ideally this could be just declared since it is not used at runtime,\n// but it doesn't play well with typescript-eslint: https://github.com/typescript-eslint/typescript-eslint/issues/4608\n// easiest solution seems to be just having it declared as a value so it doesn't break when we import at runtime\nexport const inferred = Symbol(\"inferred\");\n", "import { compileSerializedValue, flatMorph, printable, throwParseError } from \"@arktype/util\";\nimport { isNode } from \"./utils.js\";\nexport const basisKinds = [\"unit\", \"proto\", \"domain\"];\nexport const structuralKinds = [\n    \"required\",\n    \"optional\",\n    \"index\",\n    \"sequence\"\n];\nexport const refinementKinds = [\n    \"regex\",\n    \"divisor\",\n    \"exactLength\",\n    \"max\",\n    \"min\",\n    \"maxLength\",\n    \"minLength\",\n    \"before\",\n    \"after\"\n];\nexport const constraintKinds = [\n    ...refinementKinds,\n    ...structuralKinds,\n    \"structure\",\n    \"predicate\"\n];\nexport const rootKinds = [\n    \"alias\",\n    \"union\",\n    \"morph\",\n    \"unit\",\n    \"intersection\",\n    \"proto\",\n    \"domain\"\n];\nexport const nodeKinds = [...rootKinds, ...constraintKinds];\nexport const constraintKeys = flatMorph(constraintKinds, (i, kind) => [kind, 1]);\nexport const structureKeys = flatMorph([...structuralKinds, \"undeclared\"], (i, k) => [k, 1]);\nexport const precedenceByKind = flatMorph(nodeKinds, (i, kind) => [kind, i]);\nexport const isNodeKind = (value) => typeof value === \"string\" && value in precedenceByKind;\nexport function assertNodeKind(value, kind) {\n    const valueIsNode = isNode(value);\n    if (!valueIsNode || value.kind !== kind) {\n        throwParseError(`Expected node of kind ${kind} (was ${valueIsNode ? `${value.kind} node` : printable(value)})`);\n    }\n}\nexport const precedenceOfKind = (kind) => precedenceByKind[kind];\nexport const schemaKindsRightOf = (kind) => rootKinds.slice(precedenceOfKind(kind) + 1);\nexport const defaultValueSerializer = (v) => {\n    if (typeof v === \"string\" ||\n        typeof v === \"boolean\" ||\n        typeof v === \"number\" ||\n        v === null)\n        return v;\n    return compileSerializedValue(v);\n};\nexport const compileErrorContext = (ctx) => {\n    let result = \"{ \";\n    for (const [k, v] of Object.entries(ctx))\n        result += `${k}: ${compileSerializedValue(v)}, `;\n    return result + \" }\";\n};\nexport const baseKeys = {\n    description: { meta: true }\n};\nexport const implementNode = (_) => {\n    const implementation = _;\n    if (implementation.hasAssociatedError) {\n        implementation.defaults.expected ??= ctx => \"description\" in ctx ?\n            ctx.description\n            : implementation.defaults.description(ctx);\n        implementation.defaults.actual ??= data => printable(data);\n        implementation.defaults.problem ??= ctx => `must be ${ctx.expected}${ctx.actual ? ` (was ${ctx.actual})` : \"\"}`;\n        implementation.defaults.message ??= ctx => {\n            if (ctx.path.length === 0)\n                return ctx.problem;\n            const problemWithLocation = `${ctx.propString} ${ctx.problem}`;\n            if (problemWithLocation[0] === \"[\") {\n                // clarify paths like [1], [0][1], and [\"key!\"] that could be confusing\n                return `value at ${problemWithLocation}`;\n            }\n            return problemWithLocation;\n        };\n    }\n    Object.assign(implementation.keys, baseKeys);\n    return implementation;\n};\n", "import { isNodeKind } from \"./shared/implement.js\";\nexport const globalConfig = {};\nexport const mergeConfigs = (base, extensions) => {\n    const result = { ...base };\n    let k;\n    for (k in extensions) {\n        result[k] =\n            isNodeKind(k) ?\n                {\n                    ...base[k],\n                    ...extensions[k]\n                }\n                : extensions[k];\n    }\n    return result;\n};\nexport const configure = (config) => Object.assign(globalConfig, mergeConfigs(globalConfig, config));\n", "import { CastableBase, ReadonlyArray, defineProperties } from \"@arktype/util\";\nimport { arkKind, pathToPropString } from \"./utils.js\";\nexport class ArkError extends CastableBase {\n    input;\n    [arkKind] = \"error\";\n    path;\n    data;\n    nodeConfig;\n    constructor(input, ctx) {\n        super();\n        this.input = input;\n        defineProperties(this, input);\n        const data = ctx.data;\n        if (input.code === \"union\") {\n            // flatten union errors to avoid repeating context like \"foo must be foo must be\"...\n            input.errors = input.errors.flatMap(e => e.hasCode(\"union\") ? e.errors : e);\n        }\n        this.nodeConfig = ctx.config[this.code];\n        this.path = input.path ?? [...ctx.path];\n        if (input.relativePath)\n            this.path.push(...input.relativePath);\n        this.data = \"data\" in input ? input.data : data;\n    }\n    hasCode(code) {\n        return this.code === code;\n    }\n    get propString() {\n        return pathToPropString(this.path);\n    }\n    get expected() {\n        return (this.input.expected ?? this.nodeConfig.expected?.(this.input));\n    }\n    get actual() {\n        // null is a valid value of actual meaning it should be omitted, so\n        // check for undefined explicitly\n        return this.input.actual !== undefined ?\n            this.input.actual\n            : this.nodeConfig.actual?.(this.data);\n    }\n    get problem() {\n        return this.input.problem ?? this.nodeConfig.problem(this);\n    }\n    get message() {\n        return this.input.message ?? this.nodeConfig.message(this);\n    }\n    toString() {\n        return this.message;\n    }\n    throw() {\n        throw this;\n    }\n}\nexport class ArkErrors extends ReadonlyArray {\n    ctx;\n    constructor(ctx) {\n        super();\n        this.ctx = ctx;\n    }\n    byPath = {};\n    count = 0;\n    mutable = this;\n    add(error) {\n        const existing = this.byPath[error.propString];\n        if (existing) {\n            const errorIntersection = new ArkError({\n                code: \"intersection\",\n                errors: existing.hasCode(\"intersection\") ?\n                    [...existing.errors, error]\n                    : [existing, error]\n            }, this.ctx);\n            const existingIndex = this.indexOf(existing);\n            // If existing is found (which it always should be unless this was externally mutated),\n            // replace it with the new problem intersection. In case it isn't for whatever reason,\n            // just append the intersection.\n            this.mutable[existingIndex === -1 ? this.length : existingIndex] =\n                errorIntersection;\n            this.byPath[error.propString] = errorIntersection;\n        }\n        else {\n            this.byPath[error.propString] = error;\n            this.mutable.push(error);\n        }\n        this.count++;\n    }\n    get summary() {\n        return this.toString();\n    }\n    get message() {\n        return this.toString();\n    }\n    toString() {\n        return this.join(\"\\n\");\n    }\n    throw() {\n        throw new AggregateError(this, this.message);\n    }\n}\n", "import { ArkError, ArkErrors } from \"./errors.js\";\nexport class TraversalContext {\n    root;\n    config;\n    path = [];\n    queuedMorphs = [];\n    errors = new ArkErrors(this);\n    branches = [];\n    seen = {};\n    constructor(root, config) {\n        this.root = root;\n        this.config = config;\n    }\n    get currentBranch() {\n        return this.branches.at(-1);\n    }\n    queueMorphs(morphs) {\n        const input = {\n            path: [...this.path],\n            morphs\n        };\n        this.currentBranch?.queuedMorphs.push(input) ??\n            this.queuedMorphs.push(input);\n    }\n    finalize() {\n        if (this.hasError())\n            return this.errors;\n        // invoking morphs that are Nodes will reuse this context, potentially\n        // adding additional morphs, so we have to continue looping until\n        // queuedMorphs is empty rather than iterating over the list once\n        while (this.queuedMorphs.length) {\n            const { path, morphs } = this.queuedMorphs.shift();\n            const key = path.at(-1);\n            let parent;\n            if (key !== undefined) {\n                // find the object on which the key to be morphed exists\n                parent = this.root;\n                for (let pathIndex = 0; pathIndex < path.length - 1; pathIndex++)\n                    parent = parent[path[pathIndex]];\n            }\n            this.path = path;\n            for (const morph of morphs) {\n                const result = morph(parent === undefined ? this.root : parent[key], this);\n                if (result instanceof ArkErrors)\n                    return result;\n                if (this.hasError())\n                    return this.errors;\n                if (result instanceof ArkError) {\n                    // if an ArkError was returned but wasn't added to these\n                    // errors, add it then return\n                    this.error(result);\n                    return this.errors;\n                }\n                // apply the morph function and assign the result to the\n                // corresponding property, or to root if path is empty\n                if (parent === undefined)\n                    this.root = result;\n                else\n                    parent[key] = result;\n            }\n        }\n        return this.root;\n    }\n    get currentErrorCount() {\n        return (this.currentBranch ?\n            this.currentBranch.error ?\n                1\n                : 0\n            : this.errors.count);\n    }\n    hasError() {\n        return this.currentErrorCount !== 0;\n    }\n    get failFast() {\n        return this.branches.length !== 0;\n    }\n    error(input) {\n        const errCtx = typeof input === \"object\" ?\n            input.code ?\n                input\n                : { ...input, code: \"predicate\" }\n            : { code: \"predicate\", expected: input };\n        const error = new ArkError(errCtx, this);\n        if (this.currentBranch)\n            this.currentBranch.error = error;\n        else\n            this.errors.add(error);\n        return error;\n    }\n    get data() {\n        let result = this.root;\n        for (const segment of this.path)\n            result = result?.[segment];\n        return result;\n    }\n    invalid(input) {\n        this.error(input);\n        return false;\n    }\n    pushBranch() {\n        this.branches.push({\n            error: undefined,\n            queuedMorphs: []\n        });\n    }\n    popBranch() {\n        return this.branches.pop();\n    }\n}\n", "import { Callable, flatMorph, includes, isArray, isEmptyObject, shallowClone, throwError } from \"@arktype/util\";\nimport { basisKinds, constraintKinds, precedenceOfKind, refinementKinds, rootKinds } from \"./shared/implement.js\";\nimport { TraversalContext } from \"./shared/traversal.js\";\nexport class BaseNode extends Callable {\n    attachments;\n    constructor(attachments) {\n        super(\n        // pipedFromCtx allows us internally to reuse TraversalContext\n        // through pipes and keep track of piped paths. It is not exposed\n        (data, pipedFromCtx) => {\n            if (!this.includesMorph &&\n                !this.allowsRequiresContext &&\n                this.allows(data))\n                return data;\n            if (pipedFromCtx) {\n                this.traverseApply(data, pipedFromCtx);\n                return pipedFromCtx.data;\n            }\n            const ctx = new TraversalContext(data, this.$.resolvedConfig);\n            this.traverseApply(data, ctx);\n            return ctx.finalize();\n        }, { attach: attachments });\n        this.attachments = attachments;\n    }\n    qualifiedId = `${this.$.id}${this.id}`;\n    includesMorph = this.kind === \"morph\" ||\n        (this.hasKind(\"optional\") && this.hasDefault()) ||\n        (this.hasKind(\"structure\") && this.undeclared === \"delete\") ||\n        this.children.some(child => child.includesMorph);\n    allowsRequiresContext = \n    // if a predicate accepts exactly one arg, we can safely skip passing context\n    (this.hasKind(\"predicate\") && this.inner.predicate.length !== 1) ||\n        this.kind === \"alias\" ||\n        this.children.some(child => child.allowsRequiresContext);\n    referencesById = this.children.reduce((result, child) => Object.assign(result, child.referencesById), { [this.id]: this });\n    get references() {\n        return Object.values(this.referencesById);\n    }\n    precedence = precedenceOfKind(this.kind);\n    jit = false;\n    allows = (data) => {\n        if (this.allowsRequiresContext) {\n            return this.traverseAllows(data, new TraversalContext(data, this.$.resolvedConfig));\n        }\n        return this.traverseAllows(data);\n    };\n    traverse(data) {\n        return this(data);\n    }\n    // unfortunately we can't use the @cached\n    // decorator from @arktype/util on these for now\n    // as they cause a deopt in V8\n    _in;\n    get in() {\n        this._in ??= this.getIo(\"in\");\n        return this._in;\n    }\n    _out;\n    get out() {\n        this._out ??= this.getIo(\"out\");\n        return this._out;\n    }\n    _description;\n    get description() {\n        this._description ??=\n            this.inner.description ??\n                this.$.resolvedConfig[this.kind].description?.(this);\n        return this._description;\n    }\n    getIo(kind) {\n        if (!this.includesMorph)\n            return this;\n        const ioInner = {};\n        for (const [k, v] of this.entries) {\n            const keySchemaImplementation = this.impl.keys[k];\n            if (keySchemaImplementation.meta)\n                continue;\n            if (keySchemaImplementation.child) {\n                const childValue = v;\n                ioInner[k] =\n                    isArray(childValue) ?\n                        childValue.map(child => child[kind])\n                        : childValue[kind];\n            }\n            else\n                ioInner[k] = v;\n        }\n        return this.$.node(this.kind, ioInner);\n    }\n    toJSON() {\n        return this.json;\n    }\n    toString() {\n        return this.expression;\n    }\n    equals(other) {\n        return this.typeHash === other.typeHash;\n    }\n    assertHasKind(kind) {\n        if (!this.kind === kind)\n            throwError(`${this.kind} node was not of asserted kind ${kind}`);\n        return this;\n    }\n    hasKind(kind) {\n        return this.kind === kind;\n    }\n    isBasis() {\n        return includes(basisKinds, this.kind);\n    }\n    isConstraint() {\n        return includes(constraintKinds, this.kind);\n    }\n    isRefinement() {\n        return includes(refinementKinds, this.kind);\n    }\n    isRoot() {\n        return includes(rootKinds, this.kind);\n    }\n    hasUnit(value) {\n        return this.hasKind(\"unit\") && this.allows(value);\n    }\n    hasOpenIntersection() {\n        return this.impl.intersectionIsOpen;\n    }\n    get nestableExpression() {\n        return this.expression;\n    }\n    bindScope($) {\n        if (this.$ === $)\n            return this;\n        return new this.constructor(Object.assign(shallowClone(this.attachments), { $ }));\n    }\n    firstReference(filter) {\n        return this.references.find(n => n !== this && filter(n));\n    }\n    firstReferenceOrThrow(filter) {\n        return (this.firstReference(filter) ??\n            throwError(`${this.id} had no references matching predicate ${filter}`));\n    }\n    firstReferenceOfKind(kind) {\n        return this.firstReference((node) => node.kind === kind);\n    }\n    firstReferenceOfKindOrThrow(kind) {\n        return (this.firstReference(node => node.kind === kind) ??\n            throwError(`${this.id} had no ${kind} references`));\n    }\n    transform(mapper, opts) {\n        return this._transform(mapper, {\n            seen: {},\n            path: [],\n            shouldTransform: opts?.shouldTransform ?? (() => true)\n        });\n    }\n    _transform(mapper, ctx) {\n        if (ctx.seen[this.id])\n            // TODO: remove cast by making lazilyResolve more flexible\n            // TODO: if each transform has a unique base id, could ensure\n            // these don't create duplicates\n            return this.$.lazilyResolve(ctx.seen[this.id]);\n        if (!ctx.shouldTransform(this, ctx))\n            return this;\n        let transformedNode;\n        ctx.seen[this.id] = () => transformedNode;\n        const innerWithTransformedChildren = flatMorph(this.inner, (k, v) => {\n            if (!this.impl.keys[k].child)\n                return [k, v];\n            const children = v;\n            if (!isArray(children)) {\n                const transformed = children._transform(mapper, ctx);\n                return transformed ? [k, transformed] : [];\n            }\n            const transformed = children.flatMap(n => {\n                const transformedChild = n._transform(mapper, ctx);\n                return transformedChild ?? [];\n            });\n            return transformed.length ? [k, transformed] : [];\n        });\n        delete ctx.seen[this.id];\n        const transformedInner = mapper(this.kind, innerWithTransformedChildren, ctx);\n        if (transformedInner === null)\n            return null;\n        // TODO: more robust checks for pruned inner\n        if (isEmptyObject(transformedInner))\n            return null;\n        if ((this.kind === \"required\" ||\n            this.kind === \"optional\" ||\n            this.kind === \"index\") &&\n            !(\"value\" in transformedInner))\n            return null;\n        if (this.kind === \"morph\") {\n            ;\n            transformedInner.in ??= this.$.keywords\n                .unknown;\n        }\n        return (transformedNode = this.$.node(this.kind, transformedInner));\n    }\n    configureShallowDescendants(configOrDescription) {\n        const config = typeof configOrDescription === \"string\" ?\n            { description: configOrDescription }\n            : configOrDescription;\n        return this.transform((kind, inner) => ({ ...inner, ...config }), {\n            shouldTransform: node => node.kind !== \"structure\"\n        });\n    }\n}\n", "import { entriesOf, flatMorph, fromEntries, isArray, printable, register, throwInternalError, throwParseError } from \"@arktype/util\";\nimport { hasArkKind } from \"./utils.js\";\nexport class Disjoint {\n    sources;\n    constructor(sources) {\n        this.sources = sources;\n    }\n    clone() {\n        return new Disjoint(this.sources);\n    }\n    static from(kind, l, r) {\n        return new Disjoint({\n            \"[]\": {\n                [kind]: {\n                    l,\n                    r\n                }\n            }\n        });\n    }\n    static fromEntries(entries) {\n        if (!entries.length) {\n            return throwInternalError(\"Unexpected attempt to create a disjoint from no entries\");\n        }\n        return new Disjoint({ \"[]\": fromEntries(entries) });\n    }\n    get flat() {\n        return entriesOf(this.sources).flatMap(([path, disjointKinds]) => entriesOf(disjointKinds).map(([kind, disjoint]) => ({\n            path,\n            kind,\n            disjoint\n        })));\n    }\n    describeReasons() {\n        const reasons = this.flat;\n        if (reasons.length === 1) {\n            const { path, disjoint } = reasons[0];\n            const pathString = JSON.parse(path).join(\".\");\n            return `Intersection${pathString && ` at ${pathString}`} of ${describeReasons(disjoint)} results in an unsatisfiable type`;\n        }\n        return `The following intersections result in unsatisfiable types:\\n• ${reasons\n            .map(({ path, disjoint }) => `${path}: ${describeReasons(disjoint)}`)\n            .join(\"\\n• \")}`;\n    }\n    isEmpty() {\n        return this.flat.length === 0;\n    }\n    throw() {\n        return throwParseError(this.describeReasons());\n    }\n    invert() {\n        const invertedEntries = entriesOf(this.sources).map(([path, disjoints]) => [\n            path,\n            flatMorph(disjoints, (kind, disjoint) => [\n                kind,\n                { l: disjoint.r, r: disjoint.l }\n            ])\n        ]);\n        return new Disjoint(fromEntries(invertedEntries));\n    }\n    add(input) {\n        entriesOf(input.sources).forEach(([path, disjoints]) => Object.assign(this.sources[path] ?? {}, disjoints));\n    }\n    withPrefixKey(key) {\n        const entriesWithPrefix = entriesOf(this.sources).map(([path, disjoints]) => {\n            const segments = JSON.parse(path);\n            segments.unshift(typeof key === \"symbol\" ? register(key) : key);\n            const pathWithPrefix = JSON.stringify(segments);\n            return [pathWithPrefix, disjoints];\n        });\n        return new Disjoint(fromEntries(entriesWithPrefix));\n    }\n    toString() {\n        return printable(this.sources);\n    }\n}\nconst describeReasons = (source) => `${describeReason(source.l)} and ${describeReason(source.r)}`;\nconst describeReason = (value) => hasArkKind(value, \"root\") ? value.expression\n    : isArray(value) ? value.map(describeReason).join(\" | \")\n        : String(value);\n", "import { Hkt } from \"@arktype/util\";\nimport { Disjoint } from \"./disjoint.js\";\nimport { isNode } from \"./utils.js\";\nconst intersectionCache = {};\nexport const intersectNodesRoot = (l, r, $) => intersectNodes(l, r, { $, invert: false, pipe: false });\nexport const pipeNodesRoot = (l, r, $) => intersectNodes(l, r, { $, invert: false, pipe: true });\nexport const intersectNodes = (l, r, ctx) => {\n    const operator = ctx.pipe ? \"|>\" : \"&\";\n    const lrCacheKey = `${l.typeHash}${operator}${r.typeHash}`;\n    if (intersectionCache[lrCacheKey] !== undefined)\n        return intersectionCache[lrCacheKey];\n    if (!ctx.pipe) {\n        // we can only use this for the commutative & operator\n        const rlCacheKey = `${r.typeHash}${operator}${l.typeHash}`;\n        if (intersectionCache[rlCacheKey] !== undefined) {\n            // if the cached result was a Disjoint and the operands originally\n            // appeared in the opposite order, we need to invert it to match\n            const rlResult = intersectionCache[rlCacheKey];\n            const lrResult = rlResult instanceof Disjoint ? rlResult.invert() : rlResult;\n            // add the lr result to the cache directly to bypass this check in the future\n            intersectionCache[lrCacheKey] = lrResult;\n            return lrResult;\n        }\n    }\n    if (l.equals(r))\n        return l;\n    let result;\n    if (ctx.pipe && l.hasKind(\"morph\")) {\n        result =\n            ctx.invert ?\n                pipeToMorph(r, l, ctx)\n                : pipeFromMorph(l, r, ctx);\n    }\n    else if (ctx.pipe && r.hasKind(\"morph\")) {\n        result =\n            ctx.invert ?\n                pipeFromMorph(r, l, ctx)\n                : pipeToMorph(l, r, ctx);\n    }\n    else {\n        const leftmostKind = l.precedence < r.precedence ? l.kind : r.kind;\n        const implementation = l.impl.intersections[r.kind] ?? r.impl.intersections[l.kind];\n        if (implementation === undefined) {\n            // should be two ConstraintNodes that have no relation\n            // this could also happen if a user directly intersects a Type and a ConstraintNode,\n            // but that is not allowed by the external function signature\n            result = null;\n        }\n        else if (leftmostKind === l.kind)\n            result = implementation(l, r, ctx);\n        else {\n            result = implementation(r, l, { ...ctx, invert: !ctx.invert });\n            if (result instanceof Disjoint)\n                result = result.invert();\n        }\n    }\n    if (isNode(result)) {\n        // if the result equals one of the operands, preserve its metadata by\n        // returning the original reference\n        if (l.equals(result))\n            result = l;\n        else if (r.equals(result))\n            result = r;\n    }\n    intersectionCache[lrCacheKey] = result;\n    return result;\n};\n// TODO: double check pipes through chained morphs\nexport const pipeFromMorph = (from, to, ctx) => {\n    const morphs = [...from.morphs];\n    if (from.validatedOut) {\n        // still piped from context, so allows appending additional morphs\n        const outIntersection = intersectNodes(from.validatedOut, to, ctx);\n        if (outIntersection instanceof Disjoint)\n            return outIntersection;\n        morphs[morphs.length - 1] = outIntersection;\n    }\n    else\n        morphs.push(to);\n    return ctx.$.node(\"morph\", {\n        morphs,\n        in: from.in\n    });\n};\nexport const pipeToMorph = (from, to, ctx) => {\n    const result = intersectNodes(from, to.in, ctx);\n    if (result instanceof Disjoint)\n        return result;\n    return ctx.$.node(\"morph\", {\n        morphs: to.morphs,\n        in: result\n    });\n};\n", "import { append, appendUnique, capitalize, isArray, throwInternalError, throwParseError } from \"@arktype/util\";\nimport { BaseNode } from \"./node.js\";\nimport { Disjoint } from \"./shared/disjoint.js\";\nimport { compileErrorContext, constraintKeys } from \"./shared/implement.js\";\nimport { intersectNodes, intersectNodesRoot } from \"./shared/intersections.js\";\nimport { arkKind } from \"./shared/utils.js\";\nexport class BaseConstraint extends BaseNode {\n    [arkKind] = \"constraint\";\n    impliedSiblings;\n    intersect(r) {\n        return intersectNodesRoot(this, r, this.$);\n    }\n}\nexport class RawPrimitiveConstraint extends BaseConstraint {\n    traverseApply = (data, ctx) => {\n        if (!this.traverseAllows(data, ctx))\n            ctx.error(this.errorContext);\n    };\n    compile(js) {\n        if (js.traversalKind === \"Allows\")\n            js.return(this.compiledCondition);\n        else {\n            js.if(this.compiledNegation, () => js.line(`${js.ctx}.error(${this.compiledErrorContext})`));\n        }\n    }\n    get errorContext() {\n        return { code: this.kind, description: this.description, ...this.inner };\n    }\n    get compiledErrorContext() {\n        return compileErrorContext(this.errorContext);\n    }\n}\nexport const constraintKeyParser = (kind) => (schema, ctx) => {\n    if (isArray(schema)) {\n        if (schema.length === 0) {\n            // Omit empty lists as input\n            return;\n        }\n        return schema\n            .map(schema => ctx.$.node(kind, schema))\n            .sort((l, r) => (l.innerHash < r.innerHash ? -1 : 1));\n    }\n    const child = ctx.$.node(kind, schema);\n    return child.hasOpenIntersection() ? [child] : child;\n};\nexport const intersectConstraints = (s) => {\n    const head = s.r.shift();\n    if (!head) {\n        let result = s.l.length === 0 && s.kind === \"structure\" ?\n            s.ctx.$.keywords.unknown.raw\n            : s.ctx.$.node(s.kind, Object.assign(s.baseInner, unflattenConstraints(s.l)), { prereduced: true });\n        for (const root of s.roots) {\n            if (result instanceof Disjoint)\n                return result;\n            result = intersectNodes(root, result, s.ctx);\n        }\n        return result;\n    }\n    let matched = false;\n    for (let i = 0; i < s.l.length; i++) {\n        const result = intersectNodes(s.l[i], head, s.ctx);\n        if (result === null)\n            continue;\n        if (result instanceof Disjoint)\n            return result;\n        if (!matched) {\n            if (result.isRoot()) {\n                s.roots.push(result);\n                s.l.splice(i);\n                return intersectConstraints(s);\n            }\n            s.l[i] = result;\n            matched = true;\n        }\n        else if (!s.l.includes(result)) {\n            return throwInternalError(`Unexpectedly encountered multiple distinct intersection results for refinement ${result}`);\n        }\n    }\n    if (!matched)\n        s.l.push(head);\n    if (s.kind === \"intersection\")\n        head.impliedSiblings?.forEach(node => appendUnique(s.r, node));\n    return intersectConstraints(s);\n};\nexport const flattenConstraints = (inner) => {\n    const result = Object.entries(inner)\n        .flatMap(([k, v]) => k in constraintKeys ? v : [])\n        .sort((l, r) => l.precedence < r.precedence ? -1\n        : l.precedence > r.precedence ? 1\n            : l.innerHash < r.innerHash ? -1\n                : 1);\n    return result;\n};\n// TODO: Fix type\nexport const unflattenConstraints = (constraints) => {\n    const inner = {};\n    for (const constraint of constraints) {\n        if (constraint.hasOpenIntersection()) {\n            inner[constraint.kind] = append(inner[constraint.kind], constraint);\n        }\n        else {\n            if (inner[constraint.kind]) {\n                return throwInternalError(`Unexpected intersection of closed refinements of kind ${constraint.kind}`);\n            }\n            inner[constraint.kind] = constraint;\n        }\n    }\n    return inner;\n};\nexport const throwInvalidOperandError = (...args) => throwParseError(writeInvalidOperandMessage(...args));\nexport const writeInvalidOperandMessage = (kind, expected, actual) => `${capitalize(kind)} operand must be ${expected.description} (was ${actual.exclude(expected).description})`;\n", "import { Callable } from \"@arktype/util\";\nimport { arkKind } from \"./shared/utils.js\";\nexport const validateUninstantiatedGenericNode = (g) => {\n    g.$.schema(g.def, {\n    // // TODO: probably don't need raw once this is fixed.\n    // args: flatMorph(g.params, (_, name) => [name, g.$.raw.keywords.unknown])\n    });\n    return g;\n};\nexport class GenericRoot extends Callable {\n    params;\n    def;\n    $;\n    [arkKind] = \"generic\";\n    constructor(params, def, $) {\n        super((...args) => {\n            args;\n            // const argNodes: Record<string, RawRoot> = flatMorph(\n            // \tparams,\n            // \t(i, param) => [param, $.schema(args[i])]\n            // ) as never\n            // { args: argNodes }\n            return $.schema(def);\n        });\n        this.params = params;\n        this.def = def;\n        this.$ = $;\n    }\n}\n", "import { registeredReference } from \"@arktype/util\";\nimport { BaseConstraint } from \"./constraint.js\";\nimport { implementNode } from \"./shared/implement.js\";\nexport const predicateImplementation = implementNode({\n    kind: \"predicate\",\n    hasAssociatedError: true,\n    collapsibleKey: \"predicate\",\n    keys: {\n        predicate: {}\n    },\n    normalize: schema => typeof schema === \"function\" ? { predicate: schema } : schema,\n    defaults: {\n        description: node => `valid according to ${node.predicate.name || \"an anonymous predicate\"}`\n    },\n    intersectionIsOpen: true,\n    intersections: {\n        // TODO: allow changed order to be the same type\n        // as long as the narrows in l and r are individually safe to check\n        // in the order they're specified, checking them in the order\n        // resulting from this intersection should also be safe.\n        predicate: () => null\n    }\n});\nexport class PredicateNode extends BaseConstraint {\n    serializedPredicate = registeredReference(this.predicate);\n    compiledCondition = `${this.serializedPredicate}(data, ctx)`;\n    compiledNegation = `!${this.compiledCondition}`;\n    impliedBasis = null;\n    expression = this.serializedPredicate;\n    traverseAllows = this.predicate;\n    errorContext = {\n        code: \"predicate\",\n        description: this.description\n    };\n    compiledErrorContext = `{ code: \"predicate\", description: \"${this.description}\" }`;\n    traverseApply = (data, ctx) => {\n        if (!this.predicate(data, ctx) && !ctx.hasError())\n            ctx.error(this.errorContext);\n    };\n    compile(js) {\n        if (js.traversalKind === \"Allows\") {\n            js.return(this.compiledCondition);\n            return;\n        }\n        js.if(`${this.compiledNegation} && !ctx.hasError()`, () => js.line(`ctx.error(${this.compiledErrorContext})`));\n    }\n}\n", "import { RawPrimitiveConstraint, writeInvalidOperandMessage } from \"../constraint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nexport const divisorImplementation = implementNode({\n    kind: \"divisor\",\n    collapsibleKey: \"rule\",\n    keys: {\n        rule: {}\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    hasAssociatedError: true,\n    defaults: {\n        description: node => node.rule === 1 ? \"an integer\" : `a multiple of ${node.rule}`\n    },\n    intersections: {\n        divisor: (l, r, ctx) => ctx.$.node(\"divisor\", {\n            rule: Math.abs((l.rule * r.rule) / greatestCommonDivisor(l.rule, r.rule))\n        })\n    }\n});\nexport class DivisorNode extends RawPrimitiveConstraint {\n    traverseAllows = data => data % this.rule === 0;\n    compiledCondition = `data % ${this.rule} === 0`;\n    compiledNegation = `data % ${this.rule} !== 0`;\n    impliedBasis = this.$.keywords.number.raw;\n    expression = `% ${this.rule}`;\n}\nexport const writeIndivisibleMessage = (t) => writeInvalidOperandMessage(\"divisor\", t.$.raw.keywords.number, t);\n// https://en.wikipedia.org/wiki/Euclidean_algorithm\nconst greatestCommonDivisor = (l, r) => {\n    let previous;\n    let greatestCommonDivisor = l;\n    let current = r;\n    while (current !== 0) {\n        previous = current;\n        current = greatestCommonDivisor % current;\n        greatestCommonDivisor = previous;\n    }\n    return greatestCommonDivisor;\n};\n", "import { isKeyOf } from \"@arktype/util\";\nimport { RawPrimitiveConstraint } from \"../constraint.js\";\nexport class BaseRange extends RawPrimitiveConstraint {\n    boundOperandKind = operandKindsByBoundKind[this.kind];\n    compiledActual = this.boundOperandKind === \"value\" ? `data`\n        : this.boundOperandKind === \"length\" ? `data.length`\n            : `data.valueOf()`;\n    comparator = compileComparator(this.kind, this.exclusive);\n    numericLimit = this.rule.valueOf();\n    expression = `${this.comparator}${this.rule}`;\n    compiledCondition = `${this.compiledActual} ${this.comparator} ${this.numericLimit}`;\n    compiledNegation = `${this.compiledActual} ${negatedComparators[this.comparator]} ${this.numericLimit}`;\n    // we need to compute stringLimit before errorContext, which references it\n    // transitively through description for date bounds\n    stringLimit = this.boundOperandKind === \"date\" ?\n        dateLimitToString(this.numericLimit)\n        : `${this.numericLimit}`;\n    limitKind = this.comparator[\"0\"] === \"<\" ? \"upper\" : \"lower\";\n    isStricterThan(r) {\n        const thisLimitIsStricter = this.limitKind === \"upper\" ?\n            this.numericLimit < r.numericLimit\n            : this.numericLimit > r.numericLimit;\n        return (thisLimitIsStricter ||\n            (this.numericLimit === r.numericLimit &&\n                this.exclusive === true &&\n                !r.exclusive));\n    }\n    overlapsRange(r) {\n        if (this.isStricterThan(r))\n            return false;\n        if (this.numericLimit === r.numericLimit && (this.exclusive || r.exclusive))\n            return false;\n        return true;\n    }\n    overlapIsUnit(r) {\n        return (this.numericLimit === r.numericLimit && !this.exclusive && !r.exclusive);\n    }\n}\nconst negatedComparators = {\n    \"<\": \">=\",\n    \"<=\": \">\",\n    \">\": \"<=\",\n    \">=\": \"<\"\n};\nexport const boundKindPairsByLower = {\n    min: \"max\",\n    minLength: \"maxLength\",\n    after: \"before\"\n};\nexport const parseExclusiveKey = {\n    // omit key with value false since it is the default\n    parse: (flag) => flag || undefined\n};\nexport const parseDateLimit = (limit) => typeof limit === \"string\" || typeof limit === \"number\" ?\n    new Date(limit)\n    : limit;\nconst operandKindsByBoundKind = {\n    min: \"value\",\n    max: \"value\",\n    minLength: \"length\",\n    maxLength: \"length\",\n    after: \"date\",\n    before: \"date\"\n};\nexport const compileComparator = (kind, exclusive) => `${isKeyOf(kind, boundKindPairsByLower) ? \">\" : \"<\"}${exclusive ? \"\" : \"=\"}`;\nexport const dateLimitToString = (limit) => typeof limit === \"string\" ? limit : new Date(limit).toLocaleString();\nexport const writeUnboundableMessage = (root) => `Bounded expression ${root} must be a number, string, Array, or Date`;\n", "import { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseDateLimit, parseExclusiveKey } from \"./range.js\";\nexport const afterImplementation = implementNode({\n    kind: \"after\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {\n            parse: parseDateLimit,\n            serialize: schema => schema.toISOString()\n        },\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => (typeof schema === \"number\" ||\n        typeof schema === \"string\" ||\n        schema instanceof Date) ?\n        { rule: schema }\n        : schema,\n    defaults: {\n        description: node => node.exclusive ?\n            `after ${node.stringLimit}`\n            : `${node.stringLimit} or later`,\n        actual: data => data.toLocaleString()\n    },\n    intersections: {\n        after: (l, r) => (l.isStricterThan(r) ? l : r)\n    }\n});\nexport class AfterNode extends BaseRange {\n    impliedBasis = this.$.keywords.Date.raw;\n    traverseAllows = this.exclusive ? data => data > this.rule : data => data >= this.rule;\n}\n", "import { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseDateLimit, parseExclusiveKey } from \"./range.js\";\nexport const beforeImplementation = implementNode({\n    kind: \"before\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {\n            parse: parseDateLimit,\n            serialize: schema => schema.toISOString()\n        },\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => (typeof schema === \"number\" ||\n        typeof schema === \"string\" ||\n        schema instanceof Date) ?\n        { rule: schema }\n        : schema,\n    defaults: {\n        description: node => node.exclusive ?\n            `before ${node.stringLimit}`\n            : `${node.stringLimit} or earlier`,\n        actual: data => data.toLocaleString()\n    },\n    intersections: {\n        before: (l, r) => (l.isStricterThan(r) ? l : r),\n        after: (before, after, ctx) => before.overlapsRange(after) ?\n            before.overlapIsUnit(after) ?\n                ctx.$.node(\"unit\", { unit: before.rule })\n                : null\n            : Disjoint.from(\"range\", before, after)\n    }\n});\nexport class BeforeNode extends BaseRange {\n    traverseAllows = this.exclusive ? data => data < this.rule : data => data <= this.rule;\n    impliedBasis = this.$.keywords.Date.raw;\n}\n", "import { RawPrimitiveConstraint } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nexport const exactLengthImplementation = implementNode({\n    kind: \"exactLength\",\n    collapsibleKey: \"rule\",\n    keys: {\n        rule: {}\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    hasAssociatedError: true,\n    defaults: {\n        description: node => `exactly length ${node.rule}`,\n        actual: data => `${data.length}`\n    },\n    intersections: {\n        exactLength: (l, r, ctx) => new Disjoint({\n            '[\"length\"]': {\n                unit: {\n                    l: ctx.$.node(\"unit\", { unit: l.rule }),\n                    r: ctx.$.node(\"unit\", { unit: r.rule })\n                }\n            }\n        }),\n        minLength: (exactLength, minLength) => (minLength.exclusive ?\n            exactLength.rule > minLength.rule\n            : exactLength.rule >= minLength.rule) ?\n            exactLength\n            : Disjoint.from(\"range\", exactLength, minLength),\n        maxLength: (exactLength, maxLength) => (maxLength.exclusive ?\n            exactLength.rule < maxLength.rule\n            : exactLength.rule <= maxLength.rule) ?\n            exactLength\n            : Disjoint.from(\"range\", exactLength, maxLength)\n    }\n});\nexport class ExactLengthNode extends RawPrimitiveConstraint {\n    traverseAllows = data => data.length === this.rule;\n    compiledCondition = `data.length === ${this.rule}`;\n    compiledNegation = `data.length !== ${this.rule}`;\n    impliedBasis = this.$.keywords.lengthBoundable.raw;\n    expression = `{ length: ${this.rule} }`;\n}\n", "import { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nexport const maxImplementation = implementNode({\n    kind: \"max\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => `${node.exclusive ? \"less than\" : \"at most\"} ${node.rule}`\n    },\n    intersections: {\n        max: (l, r) => (l.isStricterThan(r) ? l : r),\n        min: (max, min, ctx) => max.overlapsRange(min) ?\n            max.overlapIsUnit(min) ?\n                ctx.$.node(\"unit\", { unit: max.rule })\n                : null\n            : Disjoint.from(\"range\", max, min)\n    }\n});\nexport class MaxNode extends BaseRange {\n    impliedBasis = this.$.keywords.number.raw;\n    traverseAllows = this.exclusive ? data => data < this.rule : data => data <= this.rule;\n}\n", "import { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nexport const maxLengthImplementation = implementNode({\n    kind: \"maxLength\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => node.exclusive ?\n            `less than length ${node.rule}`\n            : `at most length ${node.rule}`,\n        actual: data => `${data.length}`\n    },\n    intersections: {\n        maxLength: (l, r) => (l.isStricterThan(r) ? l : r),\n        minLength: (max, min, ctx) => max.overlapsRange(min) ?\n            max.overlapIsUnit(min) ?\n                ctx.$.node(\"exactLength\", { rule: max.rule })\n                : null\n            : Disjoint.from(\"range\", max, min)\n    }\n});\nexport class MaxLengthNode extends BaseRange {\n    impliedBasis = this.$.keywords.lengthBoundable.raw;\n    traverseAllows = this.exclusive ?\n        data => data.length < this.rule\n        : data => data.length <= this.rule;\n}\n", "import { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nexport const minImplementation = implementNode({\n    kind: \"min\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => `${node.exclusive ? \"more than\" : \"at least\"} ${node.rule}`\n    },\n    intersections: {\n        min: (l, r) => (l.isStricterThan(r) ? l : r)\n    }\n});\nexport class MinNode extends BaseRange {\n    impliedBasis = this.$.keywords.number.raw;\n    traverseAllows = this.exclusive ? data => data > this.rule : data => data >= this.rule;\n}\n", "import { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nexport const minLengthImplementation = implementNode({\n    kind: \"minLength\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => node.exclusive ?\n            node.rule === 0 ?\n                \"non-empty\"\n                : `more than length ${node.rule}`\n            : node.rule === 1 ? \"non-empty\"\n                : `at least length ${node.rule}`,\n        actual: data => `${data.length}`\n    },\n    intersections: {\n        minLength: (l, r) => (l.isStricterThan(r) ? l : r)\n    }\n});\nexport class MinLengthNode extends BaseRange {\n    impliedBasis = this.$.keywords.lengthBoundable.raw;\n    traverseAllows = this.exclusive ?\n        data => data.length > this.rule\n        : data => data.length >= this.rule;\n}\n", "import { AfterNode, afterImplementation } from \"./after.js\";\nimport { BeforeNode, beforeImplementation } from \"./before.js\";\nimport { ExactLengthNode, exactLengthImplementation } from \"./exactLength.js\";\nimport { MaxNode, maxImplementation } from \"./max.js\";\nimport { MaxLengthNode, maxLengthImplementation } from \"./maxLength.js\";\nimport { MinNode, minImplementation } from \"./min.js\";\nimport { MinLengthNode, minLengthImplementation } from \"./minLength.js\";\nexport const boundImplementationsByKind = {\n    min: minImplementation,\n    max: maxImplementation,\n    minLength: minLengthImplementation,\n    maxLength: maxLengthImplementation,\n    exactLength: exactLengthImplementation,\n    after: afterImplementation,\n    before: beforeImplementation\n};\nexport const boundClassesByKind = {\n    min: MinNode,\n    max: MaxNode,\n    minLength: MinLengthNode,\n    maxLength: MaxLengthNode,\n    exactLength: ExactLengthNode,\n    after: AfterNode,\n    before: BeforeNode\n};\n", "import { RawPrimitiveConstraint } from \"../constraint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nexport const regexImplementation = implementNode({\n    kind: \"regex\",\n    collapsibleKey: \"rule\",\n    keys: {\n        rule: {},\n        flags: {}\n    },\n    normalize: schema => typeof schema === \"string\" ? { rule: schema }\n        : schema instanceof RegExp ?\n            schema.flags ?\n                { rule: schema.source, flags: schema.flags }\n                : { rule: schema.source }\n            : schema,\n    hasAssociatedError: true,\n    intersectionIsOpen: true,\n    defaults: {\n        description: node => `matched by ${node.rule}`\n    },\n    intersections: {\n        // for now, non-equal regex are naively intersected:\n        // https://github.com/arktypeio/arktype/issues/853\n        regex: () => null\n    }\n});\nexport class RegexNode extends RawPrimitiveConstraint {\n    instance = new RegExp(this.rule, this.flags);\n    expression = `${this.instance}`;\n    traverseAllows = this.instance.test.bind(this.instance);\n    compiledCondition = `${this.expression}.test(data)`;\n    compiledNegation = `!${this.compiledCondition}`;\n    impliedBasis = this.$.keywords.string.raw;\n}\n", "import { includes, omit, throwParseError } from \"@arktype/util\";\nimport { throwInvalidOperandError } from \"../constraint.js\";\nimport { BaseNode } from \"../node.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { ArkErrors } from \"../shared/errors.js\";\nimport { structuralKinds } from \"../shared/implement.js\";\nimport { intersectNodesRoot, pipeNodesRoot } from \"../shared/intersections.js\";\nimport { arkKind, hasArkKind } from \"../shared/utils.js\";\nexport class BaseRoot extends BaseNode {\n    branches = this.hasKind(\"union\") ? this.inner.branches : [this];\n    [arkKind] = \"root\";\n    get raw() {\n        return this;\n    }\n    _keyof;\n    keyof() {\n        if (!this._keyof) {\n            this._keyof = this.rawKeyOf();\n            if (this._keyof.branches.length === 0) {\n                throwParseError(`keyof ${this.expression} results in an unsatisfiable type`);\n            }\n        }\n        return this._keyof;\n    }\n    intersect(r) {\n        const rNode = this.$.parseRoot(r);\n        return intersectNodesRoot(this, rNode, this.$);\n    }\n    and(r) {\n        const result = this.intersect(r);\n        return result instanceof Disjoint ? result.throw() : result;\n    }\n    or(r) {\n        const rNode = this.$.parseRoot(r);\n        const branches = [...this.branches, ...rNode.branches];\n        return this.$.schema(branches);\n    }\n    assert(data) {\n        const result = this.traverse(data);\n        return result instanceof ArkErrors ? result.throw() : result;\n    }\n    // get<key extends PropertyKey>(\n    // \t...path: readonly (key | Root<key>)[]\n    // ): this {\n    // \treturn this\n    // }\n    extract(r) {\n        const rNode = this.$.parseRoot(r);\n        return this.$.schema(this.branches.filter(branch => branch.extends(rNode)));\n    }\n    exclude(r) {\n        const rNode = this.$.parseRoot(r);\n        return this.$.schema(this.branches.filter(branch => !branch.extends(rNode)));\n    }\n    array() {\n        return this.$.schema({\n            proto: Array,\n            sequence: this\n        }, { prereduced: true });\n    }\n    overlaps(r) {\n        const intersection = this.intersect(r);\n        return !(intersection instanceof Disjoint);\n    }\n    extends(r) {\n        const intersection = this.intersect(r);\n        return (!(intersection instanceof Disjoint) && this.equals(intersection));\n    }\n    subsumes(r) {\n        return r.extends(this);\n    }\n    configure(configOrDescription) {\n        return this.configureShallowDescendants(configOrDescription);\n    }\n    describe(description) {\n        return this.configure(description);\n    }\n    from(input) {\n        // ideally we wouldn't validate here but for now we need to do determine\n        // which morphs to apply\n        return this.assert(input);\n    }\n    pipe(...morphs) {\n        return morphs.reduce((acc, morph) => acc.pipeOnce(morph), this);\n    }\n    pipeOnce(morph) {\n        if (hasArkKind(morph, \"root\")) {\n            const result = pipeNodesRoot(this, morph, this.$);\n            if (result instanceof Disjoint)\n                return result.throw();\n            return result;\n        }\n        if (this.hasKind(\"union\")) {\n            const branches = this.branches.map(node => node.pipe(morph));\n            return this.$.node(\"union\", { ...this.inner, branches });\n        }\n        if (this.hasKind(\"morph\")) {\n            return this.$.node(\"morph\", {\n                ...this.inner,\n                morphs: [...this.morphs, morph]\n            });\n        }\n        return this.$.node(\"morph\", {\n            in: this,\n            morphs: [morph]\n        });\n    }\n    narrow(predicate) {\n        return this.constrainOut(\"predicate\", predicate);\n    }\n    constrain(kind, schema) {\n        return this._constrain(\"in\", kind, schema);\n    }\n    constrainOut(kind, schema) {\n        return this._constrain(\"out\", kind, schema);\n    }\n    _constrain(io, kind, schema) {\n        const constraint = this.$.node(kind, schema);\n        if (constraint.impliedBasis && !this[io].extends(constraint.impliedBasis)) {\n            return throwInvalidOperandError(kind, constraint.impliedBasis, this);\n        }\n        const partialIntersection = this.$.node(\"intersection\", {\n            [kind]: constraint\n        });\n        const result = io === \"in\" ?\n            intersectNodesRoot(this, partialIntersection, this.$)\n            : pipeNodesRoot(this, partialIntersection, this.$);\n        if (result instanceof Disjoint)\n            result.throw();\n        return result;\n    }\n    onUndeclaredKey(undeclared) {\n        return this.transform((kind, inner) => kind === \"structure\" ?\n            undeclared === \"ignore\" ?\n                omit(inner, { undeclared: 1 })\n                : { ...inner, undeclared }\n            : inner, { shouldTransform: node => !includes(structuralKinds, node.kind) });\n    }\n    satisfying(predicate) {\n        return this.constrain(\"predicate\", predicate);\n    }\n    divisibleBy(schema) {\n        return this.constrain(\"divisor\", schema);\n    }\n    matching(schema) {\n        return this.constrain(\"regex\", schema);\n    }\n    atLeast(schema) {\n        return this.constrain(\"min\", schema);\n    }\n    atMost(schema) {\n        return this.constrain(\"max\", schema);\n    }\n    moreThan(schema) {\n        return this.constrain(\"min\", exclusivizeRangeSchema(schema));\n    }\n    lessThan(schema) {\n        return this.constrain(\"max\", exclusivizeRangeSchema(schema));\n    }\n    atLeastLength(schema) {\n        return this.constrain(\"minLength\", schema);\n    }\n    atMostLength(schema) {\n        return this.constrain(\"maxLength\", schema);\n    }\n    moreThanLength(schema) {\n        return this.constrain(\"minLength\", exclusivizeRangeSchema(schema));\n    }\n    lessThanLength(schema) {\n        return this.constrain(\"maxLength\", exclusivizeRangeSchema(schema));\n    }\n    exactlyLength(schema) {\n        return this.constrain(\"exactLength\", schema);\n    }\n    atOrAfter(schema) {\n        return this.constrain(\"after\", schema);\n    }\n    atOrBefore(schema) {\n        return this.constrain(\"before\", schema);\n    }\n    laterThan(schema) {\n        return this.constrain(\"after\", exclusivizeRangeSchema(schema));\n    }\n    earlierThan(schema) {\n        return this.constrain(\"before\", exclusivizeRangeSchema(schema));\n    }\n}\nexport const exclusivizeRangeSchema = (schema) => (typeof schema === \"object\" && !(schema instanceof Date) ?\n    { ...schema, exclusive: true }\n    : {\n        rule: schema,\n        exclusive: true\n    });\n", "import { flatMorph } from \"@arktype/util\";\nimport { schemaKindsRightOf } from \"../shared/implement.js\";\nexport const defineRightwardIntersections = (kind, implementation) => flatMorph(schemaKindsRightOf(kind), (i, kind) => [\n    kind,\n    implementation\n]);\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { append, cached } from \"@arktype/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nlet AliasNode = (() => {\n    let _classSuper = BaseRoot;\n    let _instanceExtraInitializers = [];\n    let _get_resolution_decorators;\n    return class AliasNode extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _get_resolution_decorators = [cached];\n            __esDecorate(this, null, _get_resolution_decorators, { kind: \"getter\", name: \"resolution\", static: false, private: false, access: { has: obj => \"resolution\" in obj, get: obj => obj.resolution }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        expression = (__runInitializers(this, _instanceExtraInitializers), this.alias);\n        get resolution() {\n            return this.resolve?.() ?? this.$.resolveRoot(this.alias);\n        }\n        rawKeyOf() {\n            return this.resolution.keyof();\n        }\n        traverseAllows = (data, ctx) => {\n            const seen = ctx.seen[this.id];\n            if (seen?.includes(data))\n                return true;\n            ctx.seen[this.id] = append(seen, data);\n            return this.resolution.traverseAllows(data, ctx);\n        };\n        traverseApply = (data, ctx) => {\n            const seen = ctx.seen[this.id];\n            if (seen?.includes(data))\n                return;\n            ctx.seen[this.id] = append(seen, data);\n            this.resolution.traverseApply(data, ctx);\n        };\n        compile(js) {\n            js.if(`ctx.seen.${this.id}?.includes(data)`, () => js.return(true));\n            js.line(`ctx.seen.${this.id} ??= []`).line(`ctx.seen.${this.id}.push(data)`);\n            js.return(js.invoke(this.resolution));\n        }\n    };\n})();\nexport { AliasNode };\nexport const normalizeAliasSchema = (schema) => typeof schema === \"string\" ? { alias: schema.slice(1) } : schema;\nexport const aliasImplementation = implementNode({\n    kind: \"alias\",\n    hasAssociatedError: false,\n    collapsibleKey: \"alias\",\n    keys: {\n        alias: {\n            serialize: schema => `$${schema}`\n        },\n        resolve: {}\n    },\n    normalize: normalizeAliasSchema,\n    defaults: {\n        description: node => node.alias\n    },\n    intersections: {\n        alias: (l, r, ctx) => ctx.$.lazilyResolve(() => neverIfDisjoint(intersectNodes(l.resolution, r.resolution, ctx), ctx.$), `${l.alias}${ctx.pipe ? \"|>\" : \"&\"}${r.alias}`),\n        ...defineRightwardIntersections(\"alias\", (l, r, ctx) => ctx.$.lazilyResolve(() => neverIfDisjoint(intersectNodes(l.resolution, r, ctx), ctx.$), `${l.alias}${ctx.pipe ? \"|>\" : \"&\"}${r.alias}`))\n    }\n});\nconst neverIfDisjoint = (result, $) => (result instanceof Disjoint ? $.keywords.never.raw : result);\n", "import { compileErrorContext } from \"../shared/implement.js\";\nimport { BaseRoot } from \"./root.js\";\nexport class RawBasis extends BaseRoot {\n    rawKeyOf() {\n        return this.$.units(this.literalKeys);\n    }\n    traverseApply = (data, ctx) => {\n        if (!this.traverseAllows(data, ctx))\n            ctx.error(this.errorContext);\n    };\n    get errorContext() {\n        return { code: this.kind, description: this.description, ...this.inner };\n    }\n    get compiledErrorContext() {\n        return compileErrorContext(this.errorContext);\n    }\n    compile(js) {\n        if (js.traversalKind === \"Allows\")\n            js.return(this.compiledCondition);\n        else {\n            js.if(this.compiledNegation, () => js.line(`${js.ctx}.error(${this.compiledErrorContext})`));\n        }\n    }\n}\n", "import { domainDescriptions, domainOf, getBaseDomainKeys } from \"@arktype/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { RawBasis } from \"./basis.js\";\nexport class DomainNode extends RawBasis {\n    traverseAllows = data => domainOf(data) === this.domain;\n    compiledCondition = this.domain === \"object\" ?\n        `((typeof data === \"object\" && data !== null) || typeof data === \"function\")`\n        : `typeof data === \"${this.domain}\"`;\n    compiledNegation = this.domain === \"object\" ?\n        `((typeof data !== \"object\" || data === null) && typeof data !== \"function\")`\n        : `typeof data !== \"${this.domain}\"`;\n    expression = this.domain;\n    literalKeys = getBaseDomainKeys(this.domain);\n}\nexport const domainImplementation = implementNode({\n    kind: \"domain\",\n    hasAssociatedError: true,\n    collapsibleKey: \"domain\",\n    keys: {\n        domain: {}\n    },\n    normalize: schema => typeof schema === \"string\" ? { domain: schema } : schema,\n    defaults: {\n        description: node => domainDescriptions[node.domain],\n        actual: data => (typeof data === \"boolean\" ? `${data}` : domainOf(data))\n    },\n    intersections: {\n        domain: (l, r) => Disjoint.from(\"domain\", l, r)\n    }\n});\n", "export const metaKeys = { description: 1 };\n", "import { flatMorph, hasDomain, isEmptyObject, isKeyOf, omit, pick, throwParseError } from \"@arktype/util\";\nimport { constraintKeyParser, flattenConstraints, intersectConstraints } from \"../constraint.js\";\nimport { metaKeys } from \"../shared/declare.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode, structureKeys } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nimport { hasArkKind, isNode } from \"../shared/utils.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nexport class IntersectionNode extends BaseRoot {\n    basis = this.domain ?? this.proto ?? null;\n    refinements = this.children.filter((node) => node.isRefinement());\n    expression = this.structure?.expression ||\n        this.children.map(node => node.nestableExpression).join(\" & \") ||\n        \"unknown\";\n    traverseAllows = (data, ctx) => this.children.every(child => child.traverseAllows(data, ctx));\n    traverseApply = (data, ctx) => {\n        const errorCount = ctx.currentErrorCount;\n        if (this.basis) {\n            this.basis.traverseApply(data, ctx);\n            if (ctx.currentErrorCount > errorCount)\n                return;\n        }\n        if (this.refinements.length) {\n            for (let i = 0; i < this.refinements.length - 1; i++) {\n                this.refinements[i].traverseApply(data, ctx);\n                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                    return;\n            }\n            this.refinements.at(-1).traverseApply(data, ctx);\n            if (ctx.currentErrorCount > errorCount)\n                return;\n        }\n        if (this.structure) {\n            this.structure.traverseApply(data, ctx);\n            if (ctx.currentErrorCount > errorCount)\n                return;\n        }\n        if (this.predicate) {\n            for (let i = 0; i < this.predicate.length - 1; i++) {\n                this.predicate[i].traverseApply(data, ctx);\n                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                    return;\n            }\n            this.predicate.at(-1).traverseApply(data, ctx);\n        }\n    };\n    compile(js) {\n        if (js.traversalKind === \"Allows\") {\n            this.children.forEach(child => js.check(child));\n            js.return(true);\n            return;\n        }\n        js.initializeErrorCount();\n        if (this.basis) {\n            js.check(this.basis);\n            // we only have to return conditionally if this is not the last check\n            if (this.children.length > 1)\n                js.returnIfFail();\n        }\n        if (this.refinements.length) {\n            for (let i = 0; i < this.refinements.length - 1; i++) {\n                js.check(this.refinements[i]);\n                js.returnIfFailFast();\n            }\n            js.check(this.refinements.at(-1));\n            if (this.structure || this.predicate)\n                js.returnIfFail();\n        }\n        if (this.structure) {\n            js.check(this.structure);\n            if (this.predicate)\n                js.returnIfFail();\n        }\n        if (this.predicate) {\n            for (let i = 0; i < this.predicate.length - 1; i++) {\n                js.check(this.predicate[i]);\n                // since predicates can be chained, we have to fail immediately\n                // if one fails\n                js.returnIfFail();\n            }\n            js.check(this.predicate.at(-1));\n        }\n    }\n    rawKeyOf() {\n        return (this.basis ?\n            this.structure ?\n                this.basis.rawKeyOf().or(this.structure.keyof())\n                : this.basis.rawKeyOf()\n            : this.structure?.keyof() ?? this.$.keywords.never.raw);\n    }\n}\nconst intersectIntersections = (l, r, ctx) => {\n    // avoid treating adding instance keys as keys of lRoot, rRoot\n    if (hasArkKind(l, \"root\") && l.hasKind(\"intersection\"))\n        return intersectIntersections(l.inner, r, ctx);\n    if (hasArkKind(r, \"root\") && r.hasKind(\"intersection\"))\n        return intersectIntersections(l, r.inner, ctx);\n    const baseInner = isEmptyObject(l) ? pick(r, metaKeys) : {};\n    const lBasis = l.proto ?? l.domain;\n    const rBasis = r.proto ?? r.domain;\n    const basisResult = lBasis ?\n        rBasis ?\n            intersectNodes(lBasis, rBasis, ctx)\n            : lBasis\n        : rBasis;\n    if (basisResult instanceof Disjoint)\n        return basisResult;\n    if (basisResult)\n        baseInner[basisResult.kind] = basisResult;\n    return intersectConstraints({\n        kind: \"intersection\",\n        baseInner,\n        l: flattenConstraints(l),\n        r: flattenConstraints(r),\n        roots: [],\n        ctx\n    });\n};\nexport const intersectionImplementation = implementNode({\n    kind: \"intersection\",\n    hasAssociatedError: true,\n    normalize: rawSchema => {\n        if (isNode(rawSchema))\n            return rawSchema;\n        const { structure, ...schema } = rawSchema;\n        const hasRootStructureKey = !!structure;\n        const normalizedStructure = structure ?? {};\n        const normalized = flatMorph(schema, (k, v) => {\n            if (isKeyOf(k, structureKeys)) {\n                if (hasRootStructureKey) {\n                    throwParseError(`Flattened structure key ${k} cannot be specified alongside a root 'structure' key.`);\n                }\n                normalizedStructure[k] = v;\n                return [];\n            }\n            return [k, v];\n        });\n        if (!isEmptyObject(normalizedStructure))\n            normalized.structure = normalizedStructure;\n        return normalized;\n    },\n    finalizeJson: ({ structure, ...rest }) => hasDomain(structure, \"object\") ? { ...structure, ...rest } : rest,\n    keys: {\n        domain: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(\"domain\", schema)\n        },\n        proto: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(\"proto\", schema)\n        },\n        structure: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(\"structure\", schema),\n            serialize: node => {\n                if (!node.sequence?.minLength)\n                    return node.collapsibleJson;\n                const { sequence, ...structureJson } = node.collapsibleJson;\n                const { minVariadicLength, ...sequenceJson } = sequence;\n                const collapsibleSequenceJson = sequenceJson.variadic && Object.keys(sequenceJson).length === 1 ?\n                    sequenceJson.variadic\n                    : sequenceJson;\n                return { ...structureJson, sequence: collapsibleSequenceJson };\n            }\n        },\n        divisor: {\n            child: true,\n            parse: constraintKeyParser(\"divisor\")\n        },\n        max: {\n            child: true,\n            parse: constraintKeyParser(\"max\")\n        },\n        min: {\n            child: true,\n            parse: constraintKeyParser(\"min\")\n        },\n        maxLength: {\n            child: true,\n            parse: constraintKeyParser(\"maxLength\")\n        },\n        minLength: {\n            child: true,\n            parse: constraintKeyParser(\"minLength\")\n        },\n        exactLength: {\n            child: true,\n            parse: constraintKeyParser(\"exactLength\")\n        },\n        before: {\n            child: true,\n            parse: constraintKeyParser(\"before\")\n        },\n        after: {\n            child: true,\n            parse: constraintKeyParser(\"after\")\n        },\n        regex: {\n            child: true,\n            parse: constraintKeyParser(\"regex\")\n        },\n        predicate: {\n            child: true,\n            parse: constraintKeyParser(\"predicate\")\n        }\n    },\n    // leverage reduction logic from intersection and identity to ensure initial\n    // parse result is reduced\n    reduce: (inner, $) => \n    // we cast union out of the result here since that only occurs when intersecting two sequences\n    // that cannot occur when reducing a single intersection schema using unknown\n    intersectIntersections({}, inner, {\n        $,\n        invert: false,\n        pipe: false\n    }),\n    defaults: {\n        description: node => node.children.length === 0 ?\n            \"unknown\"\n            : node.structure?.description ??\n                node.children.map(child => child.description).join(\" and \"),\n        expected: source => `  • ${source.errors.map(e => e.expected).join(\"\\n  • \")}`,\n        problem: ctx => `${ctx.actual} must be...\\n${ctx.expected}`\n    },\n    intersections: {\n        intersection: (l, r, ctx) => intersectIntersections(l, r, ctx),\n        ...defineRightwardIntersections(\"intersection\", (l, r, ctx) => {\n            // if l is unknown, return r\n            if (l.children.length === 0)\n                return r;\n            const basis = l.basis ? intersectNodes(l.basis, r, ctx) : r;\n            return (basis instanceof Disjoint ? basis\n                : l?.basis?.equals(basis) ?\n                    // if the basis doesn't change, return the original intesection\n                    l\n                    // given we've already precluded l being unknown, the result must\n                    // be an intersection with the new basis result integrated\n                    : l.$.node(\"intersection\", Object.assign(omit(l.inner, metaKeys), {\n                        [basis.kind]: basis\n                    }), { prereduced: true }));\n        })\n    }\n});\n", "import { arrayFrom, registeredReference, throwParseError } from \"@arktype/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nimport { hasArkKind } from \"../shared/utils.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nconst morphInputKinds = [\n    \"intersection\",\n    \"unit\",\n    \"domain\",\n    \"proto\"\n];\nexport const morphImplementation = implementNode({\n    kind: \"morph\",\n    hasAssociatedError: false,\n    keys: {\n        in: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(morphInputKinds, schema)\n        },\n        morphs: {\n            parse: arrayFrom,\n            serialize: morphs => morphs.map(m => hasArkKind(m, \"root\") ? m.json : registeredReference(m))\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `a morph from ${node.in.description} to ${node.out?.description ?? \"unknown\"}`\n    },\n    intersections: {\n        morph: (l, r, ctx) => {\n            if (l.morphs.some((morph, i) => morph !== r.morphs[i]))\n                // TODO: check in for union reduction\n                return throwParseError(\"Invalid intersection of morphs\");\n            const inTersection = intersectNodes(l.in, r.in, ctx);\n            if (inTersection instanceof Disjoint)\n                return inTersection;\n            // in case from is a union, we need to distribute the branches\n            // to can be a union as any schema is allowed\n            return ctx.$.schema(inTersection.branches.map(inBranch => ctx.$.node(\"morph\", {\n                morphs: l.morphs,\n                in: inBranch\n            })));\n        },\n        ...defineRightwardIntersections(\"morph\", (l, r, ctx) => {\n            const inTersection = intersectNodes(l.in, r, ctx);\n            return (inTersection instanceof Disjoint ? inTersection\n                : inTersection.kind === \"union\" ?\n                    ctx.$.node(\"union\", inTersection.branches.map(branch => ({\n                        ...l.inner,\n                        in: branch\n                    })))\n                    : ctx.$.node(\"morph\", {\n                        ...l.inner,\n                        in: inTersection\n                    }));\n        })\n    }\n});\nexport class MorphNode extends BaseRoot {\n    serializedMorphs = this.morphs.map(registeredReference);\n    compiledMorphs = `[${this.serializedMorphs}]`;\n    traverseAllows = (data, ctx) => this.in.traverseAllows(data, ctx);\n    traverseApply = (data, ctx) => {\n        this.in.traverseApply(data, ctx);\n        ctx.queueMorphs(this.morphs);\n    };\n    expression = `(In: ${this.in.expression}) => Out<${this.out?.expression ?? \"unknown\"}>`;\n    compile(js) {\n        if (js.traversalKind === \"Allows\") {\n            js.return(js.invoke(this.in));\n            return;\n        }\n        js.line(js.invoke(this.in));\n        js.line(`ctx.queueMorphs(${this.compiledMorphs})`);\n    }\n    get in() {\n        return this.inner.in;\n    }\n    lastMorph = this.inner.morphs.at(-1);\n    validatedOut = hasArkKind(this.lastMorph, \"root\") ?\n        Object.assign(this.referencesById, this.lastMorph.out.referencesById) &&\n            this.lastMorph.out\n        : undefined;\n    get out() {\n        return this.validatedOut ?? this.$.keywords.unknown.raw;\n    }\n    rawKeyOf() {\n        return this.in.rawKeyOf();\n    }\n}\n", "import { builtinConstructors, constructorExtends, getExactBuiltinConstructorName, objectKindDescriptions, objectKindOrDomainOf, prototypeKeysOf } from \"@arktype/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { defaultValueSerializer, implementNode } from \"../shared/implement.js\";\nimport { RawBasis } from \"./basis.js\";\nexport const protoImplementation = implementNode({\n    kind: \"proto\",\n    hasAssociatedError: true,\n    collapsibleKey: \"proto\",\n    keys: {\n        proto: {\n            serialize: ctor => getExactBuiltinConstructorName(ctor) ?? defaultValueSerializer(ctor)\n        }\n    },\n    normalize: schema => typeof schema === \"string\" ? { proto: builtinConstructors[schema] }\n        : typeof schema === \"function\" ? { proto: schema }\n            : typeof schema.proto === \"string\" ?\n                { ...schema, proto: builtinConstructors[schema.proto] }\n                : schema,\n    defaults: {\n        description: node => node.builtinName ?\n            objectKindDescriptions[node.builtinName]\n            : `an instance of ${node.proto.name}`,\n        actual: data => objectKindOrDomainOf(data)\n    },\n    intersections: {\n        proto: (l, r) => constructorExtends(l.proto, r.proto) ? l\n            : constructorExtends(r.proto, l.proto) ? r\n                : Disjoint.from(\"proto\", l, r),\n        domain: (proto, domain, ctx) => domain.domain === \"object\" ?\n            proto\n            : Disjoint.from(\"domain\", ctx.$.keywords.object.raw, domain)\n    }\n});\nexport class ProtoNode extends RawBasis {\n    builtinName = getExactBuiltinConstructorName(this.proto);\n    serializedConstructor = this.json.proto;\n    compiledCondition = `data instanceof ${this.serializedConstructor}`;\n    compiledNegation = `!(${this.compiledCondition})`;\n    literalKeys = prototypeKeysOf(this.proto.prototype);\n    traverseAllows = data => data instanceof this.proto;\n    expression = this.proto.name;\n    domain = \"object\";\n}\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { appendUnique, cached, compileLiteralPropAccess, domainDescriptions, entriesOf, flatMorph, groupBy, isArray, isKeyOf, printable, throwInternalError } from \"@arktype/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode, schemaKindsRightOf } from \"../shared/implement.js\";\nimport { intersectNodes, intersectNodesRoot } from \"../shared/intersections.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nconst unionChildKinds = [\n    ...schemaKindsRightOf(\"union\"),\n    \"alias\"\n];\nexport const unionImplementation = implementNode({\n    kind: \"union\",\n    hasAssociatedError: true,\n    collapsibleKey: \"branches\",\n    keys: {\n        ordered: {},\n        branches: {\n            child: true,\n            parse: (schema, ctx) => {\n                const branches = schema.map(branch => ctx.$.node(unionChildKinds, branch));\n                if (!ctx.schema.ordered)\n                    branches.sort((l, r) => (l.innerHash < r.innerHash ? -1 : 1));\n                return branches;\n            }\n        }\n    },\n    normalize: schema => (isArray(schema) ? { branches: schema } : schema),\n    reduce: (inner, $) => {\n        const reducedBranches = reduceBranches(inner);\n        if (reducedBranches.length === 1)\n            return reducedBranches[0];\n        if (reducedBranches.length === inner.branches.length)\n            return;\n        return $.node(\"union\", {\n            ...inner,\n            branches: reducedBranches\n        }, { prereduced: true });\n    },\n    defaults: {\n        description: node => describeBranches(node.branches.map(branch => branch.description)),\n        expected: ctx => {\n            const byPath = groupBy(ctx.errors, \"propString\");\n            const pathDescriptions = Object.entries(byPath).map(([path, errors]) => {\n                const branchesAtPath = [];\n                errors.forEach(errorAtPath => \n                // avoid duplicate messages when multiple branches\n                // are invalid due to the same error\n                appendUnique(branchesAtPath, errorAtPath.expected));\n                const expected = describeBranches(branchesAtPath);\n                // if there are multiple actual descriptions that differ,\n                // just fall back to printable, which is the most specific\n                const actual = errors.every(e => e.actual === errors[0].actual) ?\n                    errors[0].actual\n                    : printable(errors[0].data);\n                return `${path && `${path} `}must be ${expected}${actual && ` (was ${actual})`}`;\n            });\n            return describeBranches(pathDescriptions);\n        },\n        problem: ctx => ctx.expected,\n        message: ctx => ctx.problem\n    },\n    intersections: {\n        union: (l, r, ctx) => {\n            if (l.isNever !== r.isNever) {\n                // if exactly one operand is never, we can use it to discriminate based on presence\n                return Disjoint.from(\"presence\", l, r);\n            }\n            let resultBranches;\n            if (l.ordered) {\n                if (r.ordered)\n                    return Disjoint.from(\"indiscriminableMorphs\", l, r);\n                resultBranches = intersectBranches(r.branches, l.branches, ctx);\n                if (resultBranches instanceof Disjoint)\n                    resultBranches.invert();\n            }\n            else\n                resultBranches = intersectBranches(l.branches, r.branches, ctx);\n            if (resultBranches instanceof Disjoint)\n                return resultBranches;\n            return ctx.$.schema(l.ordered || r.ordered ?\n                {\n                    branches: resultBranches,\n                    ordered: true\n                }\n                : { branches: resultBranches });\n        },\n        ...defineRightwardIntersections(\"union\", (l, r, ctx) => {\n            const branches = intersectBranches(l.branches, [r], ctx);\n            if (branches instanceof Disjoint)\n                return branches;\n            if (branches.length === 1)\n                return branches[0];\n            return ctx.$.schema(l.ordered ? { branches, ordered: true } : { branches });\n        })\n    }\n});\nlet UnionNode = (() => {\n    let _classSuper = BaseRoot;\n    let _instanceExtraInitializers = [];\n    let _discriminate_decorators;\n    return class UnionNode extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _discriminate_decorators = [cached];\n            __esDecorate(this, null, _discriminate_decorators, { kind: \"method\", name: \"discriminate\", static: false, private: false, access: { has: obj => \"discriminate\" in obj, get: obj => obj.discriminate }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        isNever = (__runInitializers(this, _instanceExtraInitializers), this.branches.length === 0);\n        isBoolean = this.branches.length === 2 &&\n            this.branches[0].hasUnit(false) &&\n            this.branches[1].hasUnit(true);\n        unitBranches = this.branches.filter((n) => n.hasKind(\"unit\"));\n        discriminant = this.discriminate();\n        discriminantJson = this.discriminant ? discriminantToJson(this.discriminant) : null;\n        expression = this.isNever ? \"never\"\n            : this.isBoolean ? \"boolean\"\n                : this.branches.map(branch => branch.nestableExpression).join(\" | \");\n        traverseAllows = (data, ctx) => this.branches.some(b => b.traverseAllows(data, ctx));\n        traverseApply = (data, ctx) => {\n            const errors = [];\n            for (let i = 0; i < this.branches.length; i++) {\n                ctx.pushBranch();\n                this.branches[i].traverseApply(data, ctx);\n                if (!ctx.hasError())\n                    return ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs);\n                errors.push(ctx.popBranch().error);\n            }\n            ctx.error({ code: \"union\", errors });\n        };\n        compile(js) {\n            if (!this.discriminant ||\n                // if we have a union of two units like `boolean`, the\n                // undiscriminated compilation will be just as fast\n                (this.unitBranches.length === this.branches.length &&\n                    this.branches.length === 2))\n                return this.compileIndiscriminable(js);\n            // we need to access the path as optional so we don't throw if it isn't present\n            const condition = this.discriminant.path.reduce((acc, segment) => acc + compileLiteralPropAccess(segment, true), this.discriminant.kind === \"domain\" ? \"typeof data\" : \"data\");\n            const cases = this.discriminant.cases;\n            const caseKeys = Object.keys(cases);\n            js.block(`switch(${condition})`, () => {\n                for (const k in cases) {\n                    const v = cases[k];\n                    const caseCondition = k === \"default\" ? \"default\" : `case ${k}`;\n                    js.line(`${caseCondition}: return ${v === true ? v : js.invoke(v)}`);\n                }\n                return js;\n            });\n            if (js.traversalKind === \"Allows\") {\n                js.return(false);\n                return;\n            }\n            const expected = describeBranches(this.discriminant.kind === \"domain\" ?\n                caseKeys.map(k => domainDescriptions[k.slice(1, -1)])\n                : caseKeys);\n            js.line(`ctx.error({\n\texpected: ${JSON.stringify(expected)},\n\tactual: ${condition},\n\trelativePath: ${JSON.stringify(this.discriminant.path)}\n})`);\n        }\n        compileIndiscriminable(js) {\n            if (js.traversalKind === \"Apply\") {\n                js.const(\"errors\", \"[]\");\n                this.branches.forEach(branch => js\n                    .line(\"ctx.pushBranch()\")\n                    .line(js.invoke(branch))\n                    .if(\"!ctx.hasError()\", () => js.return(\"ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs)\"))\n                    .line(\"errors.push(ctx.popBranch().error)\"));\n                js.line(`ctx.error({ code: \"union\", errors })`);\n            }\n            else {\n                this.branches.forEach(branch => js.if(`${js.invoke(branch)}`, () => js.return(true)));\n                js.return(false);\n            }\n        }\n        rawKeyOf() {\n            return this.branches.reduce((result, branch) => result.and(branch.rawKeyOf()), this.$.keywords.unknown.raw);\n        }\n        get nestableExpression() {\n            // avoid adding unnecessary parentheses around boolean since it's\n            // already collapsed to a single keyword\n            return this.isBoolean ? \"boolean\" : super.nestableExpression;\n        }\n        discriminate() {\n            if (this.branches.length < 2)\n                return null;\n            if (this.unitBranches.length === this.branches.length) {\n                const cases = flatMorph(this.unitBranches, (i, unit) => [\n                    `${unit.serializedValue}`,\n                    true\n                ]);\n                return {\n                    path: [],\n                    kind: \"unit\",\n                    cases\n                };\n            }\n            const casesBySpecifier = {};\n            for (let lIndex = 0; lIndex < this.branches.length - 1; lIndex++) {\n                const l = this.branches[lIndex];\n                for (let rIndex = lIndex + 1; rIndex < this.branches.length; rIndex++) {\n                    const r = this.branches[rIndex];\n                    const result = intersectNodesRoot(l.in, r.in, l.$);\n                    if (!(result instanceof Disjoint))\n                        continue;\n                    for (const { path, kind, disjoint } of result.flat) {\n                        if (!isKeyOf(kind, discriminantKinds))\n                            continue;\n                        const qualifiedDiscriminant = `${path}${kind}`;\n                        let lSerialized;\n                        let rSerialized;\n                        if (kind === \"domain\") {\n                            lSerialized = `\"${disjoint.l.domain}\"`;\n                            rSerialized = `\"${disjoint.r.domain}\"`;\n                        }\n                        else if (kind === \"unit\") {\n                            lSerialized = disjoint.l.serializedValue;\n                            rSerialized = disjoint.r.serializedValue;\n                        }\n                        else {\n                            return throwInternalError(`Unexpected attempt to discriminate disjoint kind '${kind}'`);\n                        }\n                        if (!casesBySpecifier[qualifiedDiscriminant]) {\n                            casesBySpecifier[qualifiedDiscriminant] = {\n                                [lSerialized]: [l],\n                                [rSerialized]: [r]\n                            };\n                            continue;\n                        }\n                        const cases = casesBySpecifier[qualifiedDiscriminant];\n                        if (!isKeyOf(lSerialized, cases))\n                            cases[lSerialized] = [l];\n                        else if (!cases[lSerialized].includes(l))\n                            cases[lSerialized].push(l);\n                        if (!isKeyOf(rSerialized, cases))\n                            cases[rSerialized] = [r];\n                        else if (!cases[rSerialized].includes(r))\n                            cases[rSerialized].push(r);\n                    }\n                }\n            }\n            const bestDiscriminantEntry = entriesOf(casesBySpecifier)\n                .sort((a, b) => Object.keys(a[1]).length - Object.keys(b[1]).length)\n                .at(-1);\n            if (!bestDiscriminantEntry)\n                return null;\n            const [specifier, bestCases] = bestDiscriminantEntry;\n            const [path, kind] = parseDiscriminantKey(specifier);\n            let defaultBranches = [...this.branches];\n            const cases = flatMorph(bestCases, (k, caseBranches) => {\n                const prunedBranches = [];\n                defaultBranches = defaultBranches.filter(n => !caseBranches.includes(n));\n                for (const branch of caseBranches) {\n                    const pruned = pruneDiscriminant(kind, path, branch);\n                    // if any branch of the union has no constraints (i.e. is unknown)\n                    // return it right away\n                    if (pruned === null)\n                        return [k, true];\n                    prunedBranches.push(pruned);\n                }\n                const caseNode = prunedBranches.length === 1 ?\n                    prunedBranches[0]\n                    : this.$.node(\"union\", prunedBranches);\n                Object.assign(this.referencesById, caseNode.referencesById);\n                return [k, caseNode];\n            });\n            if (defaultBranches.length) {\n                cases.default = this.$.node(\"union\", defaultBranches, {\n                    prereduced: true\n                });\n                Object.assign(this.referencesById, cases.default.referencesById);\n            }\n            return {\n                kind,\n                path,\n                cases\n            };\n        }\n    };\n})();\nexport { UnionNode };\nconst discriminantToJson = (discriminant) => ({\n    kind: discriminant.kind,\n    path: discriminant.path,\n    cases: flatMorph(discriminant.cases, (k, node) => [\n        k,\n        node === true ? node\n            : node.hasKind(\"union\") && node.discriminantJson ? node.discriminantJson\n                : node.json\n    ])\n});\nconst describeBranches = (descriptions) => {\n    if (descriptions.length === 0)\n        return \"never\";\n    if (descriptions.length === 1)\n        return descriptions[0];\n    if ((descriptions.length === 2 &&\n        descriptions[0] === \"false\" &&\n        descriptions[1] === \"true\") ||\n        (descriptions[0] === \"true\" && descriptions[1] === \"false\"))\n        return \"boolean\";\n    let description = \"\";\n    for (let i = 0; i < descriptions.length - 1; i++) {\n        description += descriptions[i];\n        if (i < descriptions.length - 2)\n            description += \", \";\n    }\n    description += ` or ${descriptions[descriptions.length - 1]}`;\n    return description;\n};\nexport const intersectBranches = (l, r, ctx) => {\n    // If the corresponding r branch is identified as a subtype of an l branch, the\n    // value at rIndex is set to null so we can avoid including previous/future\n    // inersections in the reduced result.\n    const batchesByR = r.map(() => []);\n    for (let lIndex = 0; lIndex < l.length; lIndex++) {\n        let candidatesByR = {};\n        for (let rIndex = 0; rIndex < r.length; rIndex++) {\n            if (batchesByR[rIndex] === null) {\n                // rBranch is a subtype of an lBranch and\n                // will not yield any distinct intersection\n                continue;\n            }\n            if (l[lIndex].equals(r[rIndex])) {\n                // Combination of subtype and supertype cases\n                batchesByR[rIndex] = null;\n                candidatesByR = {};\n                break;\n            }\n            const branchIntersection = intersectNodes(l[lIndex], r[rIndex], ctx);\n            if (branchIntersection instanceof Disjoint) {\n                // Doesn't tell us anything useful about their relationships\n                // with other branches\n                continue;\n            }\n            if (branchIntersection.equals(l[lIndex])) {\n                // If the current l branch is a subtype of r, intersections\n                // with previous and remaining branches of r won't lead to\n                // distinct intersections.\n                batchesByR[rIndex].push(l[lIndex]);\n                candidatesByR = {};\n                break;\n            }\n            if (branchIntersection.equals(r[rIndex])) {\n                // If the current r branch is a subtype of l, set its batch to\n                // null, removing any previous intersections and preventing any\n                // of its remaining intersections from being computed.\n                batchesByR[rIndex] = null;\n            }\n            else {\n                // If neither l nor r is a subtype of the other, add their\n                // intersection as a candidate (could still be removed if it is\n                // determined l or r is a subtype of a remaining branch).\n                candidatesByR[rIndex] = branchIntersection;\n            }\n        }\n        for (const rIndex in candidatesByR) {\n            // batchesByR at rIndex should never be null if it is in candidatesByR\n            batchesByR[rIndex][lIndex] = candidatesByR[rIndex];\n        }\n    }\n    // Compile the reduced intersection result, including:\n    // \t\t1. Remaining candidates resulting from distinct intersections or strict subtypes of r\n    // \t\t2. Original r branches corresponding to indices with a null batch (subtypes of l)\n    const resultBranches = batchesByR.flatMap(\n    // ensure unions returned from branchable intersections like sequence are flattened\n    (batch, i) => batch?.flatMap(branch => branch.branches) ?? r[i]);\n    return resultBranches.length === 0 ?\n        Disjoint.from(\"union\", l, r)\n        : resultBranches;\n};\nexport const reduceBranches = ({ branches, ordered }) => {\n    if (branches.length < 2)\n        return branches;\n    const uniquenessByIndex = branches.map(() => true);\n    for (let i = 0; i < branches.length; i++) {\n        for (let j = i + 1; j < branches.length && uniquenessByIndex[i] && uniquenessByIndex[j]; j++) {\n            if (branches[i].equals(branches[j])) {\n                // if the two branches are equal, only \"j\" is marked as\n                // redundant so at least one copy could still be included in\n                // the final set of branches.\n                uniquenessByIndex[j] = false;\n                continue;\n            }\n            const intersection = intersectNodesRoot(branches[i].in, branches[j].in, branches[0].$);\n            if (intersection instanceof Disjoint)\n                continue;\n            if (intersection.equals(branches[i].in)) {\n                // preserve ordered branches that are a subtype of a subsequent branch\n                uniquenessByIndex[i] = !!ordered;\n            }\n            else if (intersection.equals(branches[j].in))\n                uniquenessByIndex[j] = false;\n        }\n    }\n    return branches.filter((_, i) => uniquenessByIndex[i]);\n};\nconst discriminantKinds = {\n    domain: 1,\n    unit: 1\n};\nconst parseDiscriminantKey = (key) => {\n    const lastPathIndex = key.lastIndexOf(\"]\");\n    const parsedPath = JSON.parse(key.slice(0, lastPathIndex + 1));\n    const parsedKind = key.slice(lastPathIndex + 1);\n    return [parsedPath, parsedKind];\n};\nexport const pruneDiscriminant = (discriminantKind, path, branch) => branch.transform((nodeKind, inner, ctx) => {\n    // if we've already checked a path at least as long as the current one,\n    // we don't need to revalidate that we're in an object\n    if (nodeKind === \"domain\" &&\n        inner.domain === \"object\" &&\n        path.length > ctx.path.length)\n        return null;\n    // if the discriminant has already checked the domain at the current path\n    // (or an exact value, implying a domain), we don't need to recheck it\n    if ((discriminantKind === nodeKind ||\n        (nodeKind === \"domain\" && ctx.path.length === path.length)) &&\n        ctx.path.length === path.length &&\n        ctx.path.every((segment, i) => segment === path[i]))\n        return null;\n    return inner;\n}, {\n    shouldTransform: node => node.children.length !== 0 ||\n        node.kind === \"domain\" ||\n        node.kind === \"unit\"\n});\n// // TODO: if deeply includes morphs?\n// const writeUndiscriminableMorphUnionMessage = <path extends string>(\n// \tpath: path\n// ) =>\n// \t`${\n// \t\tpath === \"/\" ? \"A\" : `At ${path}, a`\n// \t} union including one or more morphs must be discriminable` as const\n", "import { domainOf, printable, prototypeKeysOf } from \"@arktype/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { defaultValueSerializer, implementNode } from \"../shared/implement.js\";\nimport { RawBasis } from \"./basis.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nexport const unitImplementation = implementNode({\n    kind: \"unit\",\n    hasAssociatedError: true,\n    keys: {\n        unit: {\n            preserveUndefined: true,\n            serialize: schema => schema instanceof Date ?\n                schema.toISOString()\n                : defaultValueSerializer(schema)\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => printable(node.unit),\n        problem: ({ expected, actual }) => `${expected === actual ? `must be reference equal to ${expected} (serialized to the same value)` : `must be ${expected} (was ${actual})`}`\n    },\n    intersections: {\n        unit: (l, r) => Disjoint.from(\"unit\", l, r),\n        ...defineRightwardIntersections(\"unit\", (l, r) => r.allows(l.unit) ? l : (Disjoint.from(\"assignability\", l, r.hasKind(\"intersection\") ?\n            r.children.find(rConstraint => !rConstraint.allows(l.unit))\n            : r)))\n    }\n});\nexport class UnitNode extends RawBasis {\n    compiledValue = this.json.unit;\n    serializedValue = typeof this.unit === \"string\" || this.unit instanceof Date ?\n        JSON.stringify(this.compiledValue)\n        : this.compiledValue;\n    literalKeys = prototypeKeysOf(this.unit);\n    compiledCondition = compileEqualityCheck(this.unit, this.serializedValue);\n    compiledNegation = compileEqualityCheck(this.unit, this.serializedValue, \"negated\");\n    expression = printable(this.unit);\n    domain = domainOf(this.unit);\n    traverseAllows = this.unit instanceof Date ?\n        data => data instanceof Date && data.toISOString() === this.compiledValue\n        : data => data === this.unit;\n}\nconst compileEqualityCheck = (unit, serializedValue, negated) => {\n    if (unit instanceof Date) {\n        const condition = `data instanceof Date && data.toISOString() === ${serializedValue}`;\n        return negated ? `!(${condition})` : condition;\n    }\n    return `data ${negated ? \"!\" : \"=\"}== ${serializedValue}`;\n};\n", "import { printable, stringAndSymbolicEntriesOf, throwParseError } from \"@arktype/util\";\nimport { BaseConstraint } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nexport const indexImplementation = implementNode({\n    kind: \"index\",\n    hasAssociatedError: false,\n    intersectionIsOpen: true,\n    keys: {\n        signature: {\n            child: true,\n            parse: (schema, ctx) => {\n                const key = ctx.$.schema(schema);\n                if (!key.extends(ctx.$.keywords.propertyKey)) {\n                    return throwParseError(writeInvalidPropertyKeyMessage(key.expression));\n                }\n                const enumerableBranches = key.branches.filter((b) => b.hasKind(\"unit\"));\n                if (enumerableBranches.length) {\n                    return throwParseError(writeEnumerableIndexBranches(enumerableBranches.map(b => printable(b.unit))));\n                }\n                return key;\n            }\n        },\n        value: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.schema(schema)\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `[${node.signature.expression}]: ${node.value.description}`\n    },\n    intersections: {\n        index: (l, r, ctx) => {\n            if (l.signature.equals(r.signature)) {\n                const valueIntersection = intersectNodes(l.value, r.value, ctx);\n                const value = valueIntersection instanceof Disjoint ?\n                    ctx.$.keywords.never.raw\n                    : valueIntersection;\n                return ctx.$.node(\"index\", { signature: l.signature, value });\n            }\n            // if r constrains all of l's keys to a subtype of l's value, r is a subtype of l\n            if (l.signature.extends(r.signature) && l.value.subsumes(r.value))\n                return r;\n            // if l constrains all of r's keys to a subtype of r's value, l is a subtype of r\n            if (r.signature.extends(l.signature) && r.value.subsumes(l.value))\n                return l;\n            // other relationships between index signatures can't be generally reduced\n            return null;\n        }\n    }\n});\nexport class IndexNode extends BaseConstraint {\n    impliedBasis = this.$.keywords.object.raw;\n    expression = `[${this.signature.expression}]: ${this.value.expression}`;\n    traverseAllows = (data, ctx) => stringAndSymbolicEntriesOf(data).every(entry => {\n        if (this.signature.traverseAllows(entry[0], ctx)) {\n            // ctx will be undefined if this node isn't context-dependent\n            ctx?.path.push(entry[0]);\n            const allowed = this.value.traverseAllows(entry[1], ctx);\n            ctx?.path.pop();\n            return allowed;\n        }\n        return true;\n    });\n    traverseApply = (data, ctx) => stringAndSymbolicEntriesOf(data).forEach(entry => {\n        if (this.signature.traverseAllows(entry[0], ctx)) {\n            ctx.path.push(entry[0]);\n            this.value.traverseApply(entry[1], ctx);\n            ctx.path.pop();\n        }\n    });\n    _transform(mapper, ctx) {\n        ctx.path.push(this.signature);\n        const result = super._transform(mapper, ctx);\n        ctx.path.pop();\n        return result;\n    }\n    compile() {\n        // this is currently handled by StructureNode\n    }\n}\nexport const writeEnumerableIndexBranches = (keys) => `Index keys ${keys.join(\", \")} should be specified as named props.`;\nexport const writeInvalidPropertyKeyMessage = (indexSchema) => `Indexed key definition '${indexSchema}' must be a string, number or symbol`;\n", "import { compileSerializedValue, printable, registeredReference, throwParseError, unset } from \"@arktype/util\";\nimport { BaseConstraint } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nexport const intersectProps = (l, r, ctx) => {\n    if (l.key !== r.key)\n        return null;\n    const key = l.key;\n    let value = intersectNodes(l.value, r.value, ctx);\n    const kind = l.required || r.required ? \"required\" : \"optional\";\n    if (value instanceof Disjoint) {\n        if (kind === \"optional\")\n            value = ctx.$.keywords.never.raw;\n        else\n            return value.withPrefixKey(l.compiledKey);\n    }\n    if (kind === \"required\") {\n        return ctx.$.node(\"required\", {\n            key,\n            value\n        });\n    }\n    const defaultIntersection = l.hasDefault() ?\n        r.hasDefault() ?\n            l.default === r.default ?\n                l.default\n                : throwParseError(`Invalid intersection of default values ${printable(l.default)} & ${printable(r.default)}`)\n            : l.default\n        : r.hasDefault() ? r.default\n            : unset;\n    return ctx.$.node(\"optional\", {\n        key,\n        value,\n        // unset is stripped during parsing\n        default: defaultIntersection\n    });\n};\nexport class BaseProp extends BaseConstraint {\n    required = this.kind === \"required\";\n    impliedBasis = this.$.keywords.object.raw;\n    serializedKey = compileSerializedValue(this.key);\n    compiledKey = typeof this.key === \"string\" ? this.key : this.serializedKey;\n    _transform(mapper, ctx) {\n        ctx.path.push(this.key);\n        const result = super._transform(mapper, ctx);\n        ctx.path.pop();\n        return result;\n    }\n    defaultValueMorphs = [\n        data => {\n            data[this.key] = this.default;\n            return data;\n        }\n    ];\n    defaultValueMorphsReference = registeredReference(this.defaultValueMorphs);\n    hasDefault() {\n        return \"default\" in this;\n    }\n    traverseAllows = (data, ctx) => {\n        if (this.key in data) {\n            // ctx will be undefined if this node isn't context-dependent\n            ctx?.path.push(this.key);\n            const allowed = this.value.traverseAllows(data[this.key], ctx);\n            ctx?.path.pop();\n            return allowed;\n        }\n        return !this.required;\n    };\n    traverseApply = (data, ctx) => {\n        if (this.key in data) {\n            ctx.path.push(this.key);\n            this.value.traverseApply(data[this.key], ctx);\n            ctx.path.pop();\n        }\n        else if (this.hasKind(\"required\"))\n            ctx.error(this.errorContext);\n        else if (this.hasKind(\"optional\") && this.hasDefault())\n            ctx.queueMorphs(this.defaultValueMorphs);\n    };\n    compile(js) {\n        js.if(`${this.serializedKey} in data`, () => js.traverseKey(this.serializedKey, `data${js.prop(this.key)}`, this.value));\n        if (this.hasKind(\"required\")) {\n            js.else(() => {\n                if (js.traversalKind === \"Apply\")\n                    return js.line(`ctx.error(${this.compiledErrorContext})`);\n                else\n                    return js.return(false);\n            });\n        }\n        else if (js.traversalKind === \"Apply\" && \"default\" in this) {\n            js.else(() => js.line(`ctx.queueMorphs(${this.defaultValueMorphsReference})`));\n        }\n        if (js.traversalKind === \"Allows\")\n            js.return(true);\n    }\n}\n", "import { implementNode } from \"../shared/implement.js\";\nimport { BaseProp, intersectProps } from \"./prop.js\";\nexport const optionalImplementation = implementNode({\n    kind: \"optional\",\n    hasAssociatedError: false,\n    intersectionIsOpen: true,\n    keys: {\n        key: {},\n        value: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.schema(schema)\n        },\n        default: {\n            preserveUndefined: true\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `${node.compiledKey}?: ${node.value.description}`\n    },\n    intersections: {\n        optional: intersectProps\n    }\n});\nexport class OptionalNode extends BaseProp {\n    expression = `${this.compiledKey}?: ${this.value.expression}`;\n}\n", "import { compileErrorContext, implementNode } from \"../shared/implement.js\";\nimport { BaseProp, intersectProps } from \"./prop.js\";\nexport class RequiredNode extends BaseProp {\n    expression = `${this.compiledKey}: ${this.value.expression}`;\n    errorContext = Object.freeze({\n        code: \"required\",\n        missingValueDescription: this.value.description,\n        relativePath: [this.key]\n    });\n    compiledErrorContext = compileErrorContext(this.errorContext);\n}\nexport const requiredImplementation = implementNode({\n    kind: \"required\",\n    hasAssociatedError: true,\n    intersectionIsOpen: true,\n    keys: {\n        key: {},\n        value: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.schema(schema)\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `${node.compiledKey}: ${node.value.description}`,\n        expected: ctx => ctx.missingValueDescription,\n        actual: () => \"missing\"\n    },\n    intersections: {\n        required: intersectProps,\n        optional: intersectProps\n    }\n});\n", "import { append, throwInternalError, throwParseError } from \"@arktype/util\";\nimport { BaseConstraint } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nconst fixedSequenceKeySchemaDefinition = {\n    child: true,\n    parse: (schema, ctx) => schema.length === 0 ?\n        // empty affixes are omitted. an empty array should therefore\n        // be specified as `{ proto: Array, length: 0 }`\n        undefined\n        : schema.map(element => ctx.$.schema(element))\n};\nexport const sequenceImplementation = implementNode({\n    kind: \"sequence\",\n    hasAssociatedError: false,\n    collapsibleKey: \"variadic\",\n    keys: {\n        prefix: fixedSequenceKeySchemaDefinition,\n        optionals: fixedSequenceKeySchemaDefinition,\n        variadic: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.schema(schema, ctx)\n        },\n        minVariadicLength: {\n            // minVariadicLength is reflected in the id of this node,\n            // but not its IntersectionNode parent since it is superceded by the minLength\n            // node it implies\n            parse: min => (min === 0 ? undefined : min)\n        },\n        postfix: fixedSequenceKeySchemaDefinition\n    },\n    normalize: schema => {\n        if (typeof schema === \"string\")\n            return { variadic: schema };\n        if (\"variadic\" in schema ||\n            \"prefix\" in schema ||\n            \"optionals\" in schema ||\n            \"postfix\" in schema ||\n            \"minVariadicLength\" in schema) {\n            if (schema.postfix?.length) {\n                if (!schema.variadic)\n                    return throwParseError(postfixWithoutVariadicMessage);\n                if (schema.optionals?.length)\n                    return throwParseError(postfixFollowingOptionalMessage);\n            }\n            if (schema.minVariadicLength && !schema.variadic) {\n                return throwParseError(\"minVariadicLength may not be specified without a variadic element\");\n            }\n            return schema;\n        }\n        return { variadic: schema };\n    },\n    reduce: (raw, $) => {\n        let minVariadicLength = raw.minVariadicLength ?? 0;\n        const prefix = raw.prefix?.slice() ?? [];\n        const optional = raw.optionals?.slice() ?? [];\n        const postfix = raw.postfix?.slice() ?? [];\n        if (raw.variadic) {\n            // optional elements equivalent to the variadic parameter are redundant\n            while (optional.at(-1)?.equals(raw.variadic))\n                optional.pop();\n            if (optional.length === 0) {\n                // If there are no optional, normalize prefix\n                // elements adjacent and equivalent to variadic:\n                // \t\t{ variadic: number, prefix: [string, number] }\n                // reduces to:\n                // \t\t{ variadic: number, prefix: [string], minVariadicLength: 1 }\n                while (prefix.at(-1)?.equals(raw.variadic)) {\n                    prefix.pop();\n                    minVariadicLength++;\n                }\n            }\n            // Normalize postfix elements adjacent and equivalent to variadic:\n            // \t\t{ variadic: number, postfix: [number, number, 5] }\n            // reduces to:\n            // \t\t{ variadic: number, postfix: [5], minVariadicLength: 2 }\n            while (postfix[0]?.equals(raw.variadic)) {\n                postfix.shift();\n                minVariadicLength++;\n            }\n        }\n        else if (optional.length === 0) {\n            // if there's no variadic or optional parameters,\n            // postfix can just be appended to prefix\n            prefix.push(...postfix.splice(0));\n        }\n        if (\n        // if any variadic adjacent elements were moved to minVariadicLength\n        minVariadicLength !== raw.minVariadicLength ||\n            // or any postfix elements were moved to prefix\n            (raw.prefix && raw.prefix.length !== prefix.length)) {\n            // reparse the reduced def\n            return $.node(\"sequence\", {\n                ...raw,\n                // empty lists will be omitted during parsing\n                prefix,\n                postfix,\n                optionals: optional,\n                minVariadicLength\n            }, { prereduced: true });\n        }\n    },\n    defaults: {\n        description: node => {\n            if (node.isVariadicOnly)\n                return `${node.variadic.nestableExpression}[]`;\n            const innerDescription = node.tuple\n                .map(element => element.kind === \"optionals\" ? `${element.node.nestableExpression}?`\n                : element.kind === \"variadic\" ?\n                    `...${element.node.nestableExpression}[]`\n                    : element.node.expression)\n                .join(\", \");\n            return `[${innerDescription}]`;\n        }\n    },\n    intersections: {\n        sequence: (l, r, ctx) => {\n            const rootState = _intersectSequences({\n                l: l.tuple,\n                r: r.tuple,\n                disjoint: new Disjoint({}),\n                result: [],\n                fixedVariants: [],\n                ctx\n            });\n            const viableBranches = rootState.disjoint.isEmpty() ?\n                [rootState, ...rootState.fixedVariants]\n                : rootState.fixedVariants;\n            return (viableBranches.length === 0 ? rootState.disjoint\n                : viableBranches.length === 1 ?\n                    ctx.$.node(\"sequence\", sequenceTupleToInner(viableBranches[0].result))\n                    : ctx.$.node(\"union\", viableBranches.map(state => ({\n                        proto: Array,\n                        sequence: sequenceTupleToInner(state.result)\n                    }))));\n        }\n        // exactLength, minLength, and maxLength don't need to be defined\n        // here since impliedSiblings guarantees they will be added\n        // directly to the IntersectionNode parent of the SequenceNode\n        // they exist on\n    }\n});\nexport class SequenceNode extends BaseConstraint {\n    impliedBasis = this.$.keywords.Array.raw;\n    prefix = this.inner.prefix ?? [];\n    optionals = this.inner.optionals ?? [];\n    prevariadic = [...this.prefix, ...this.optionals];\n    postfix = this.inner.postfix ?? [];\n    isVariadicOnly = this.prevariadic.length + this.postfix.length === 0;\n    minVariadicLength = this.inner.minVariadicLength ?? 0;\n    minLength = this.prefix.length + this.minVariadicLength + this.postfix.length;\n    minLengthNode = this.minLength === 0 ? null : this.$.node(\"minLength\", this.minLength);\n    maxLength = this.variadic ? null : this.minLength + this.optionals.length;\n    maxLengthNode = this.maxLength === null ? null : this.$.node(\"maxLength\", this.maxLength);\n    impliedSiblings = this.minLengthNode ?\n        this.maxLengthNode ?\n            [this.minLengthNode, this.maxLengthNode]\n            : [this.minLengthNode]\n        : this.maxLengthNode ? [this.maxLengthNode]\n            : [];\n    childAtIndex(data, index) {\n        if (index < this.prevariadic.length)\n            return this.prevariadic[index];\n        const firstPostfixIndex = data.length - this.postfix.length;\n        if (index >= firstPostfixIndex)\n            return this.postfix[index - firstPostfixIndex];\n        return (this.variadic ??\n            throwInternalError(`Unexpected attempt to access index ${index} on ${this}`));\n    }\n    // minLength/maxLength should be checked by Intersection before either traversal\n    traverseAllows = (data, ctx) => {\n        for (let i = 0; i < data.length; i++)\n            if (!this.childAtIndex(data, i).traverseAllows(data[i], ctx))\n                return false;\n        return true;\n    };\n    traverseApply = (data, ctx) => {\n        for (let i = 0; i < data.length; i++) {\n            ctx.path.push(i);\n            this.childAtIndex(data, i).traverseApply(data[i], ctx);\n            ctx.path.pop();\n        }\n    };\n    // minLength/maxLength compilation should be handled by Intersection\n    compile(js) {\n        this.prefix.forEach((node, i) => js.traverseKey(`${i}`, `data[${i}]`, node));\n        this.optionals.forEach((node, i) => {\n            const dataIndex = `${i + this.prefix.length}`;\n            js.if(`${dataIndex} >= ${js.data}.length`, () => js.traversalKind === \"Allows\" ? js.return(true) : js.return());\n            js.traverseKey(dataIndex, `data[${dataIndex}]`, node);\n        });\n        if (this.variadic) {\n            if (this.postfix.length) {\n                js.const(\"firstPostfixIndex\", `${js.data}.length${this.postfix.length ? `- ${this.postfix.length}` : \"\"}`);\n            }\n            js.for(`i < ${this.postfix.length ? \"firstPostfixIndex\" : \"data.length\"}`, () => js.traverseKey(\"i\", \"data[i]\", this.variadic), this.prevariadic.length);\n            this.postfix.forEach((node, i) => {\n                const keyExpression = `firstPostfixIndex + ${i}`;\n                js.traverseKey(keyExpression, `data[${keyExpression}]`, node);\n            });\n        }\n        if (js.traversalKind === \"Allows\")\n            js.return(true);\n    }\n    _transform(mapper, ctx) {\n        ctx.path.push(this.$.keywords.nonNegativeIntegerString.raw);\n        const result = super._transform(mapper, ctx);\n        ctx.path.pop();\n        return result;\n    }\n    tuple = sequenceInnerToTuple(this.inner);\n    // this depends on tuple so needs to come after it\n    expression = this.description;\n}\nconst sequenceInnerToTuple = (inner) => {\n    const tuple = [];\n    inner.prefix?.forEach(node => tuple.push({ kind: \"prefix\", node }));\n    inner.optionals?.forEach(node => tuple.push({ kind: \"optionals\", node }));\n    if (inner.variadic)\n        tuple.push({ kind: \"variadic\", node: inner.variadic });\n    inner.postfix?.forEach(node => tuple.push({ kind: \"postfix\", node }));\n    return tuple;\n};\nconst sequenceTupleToInner = (tuple) => tuple.reduce((result, node) => {\n    if (node.kind === \"variadic\")\n        result.variadic = node.node;\n    else\n        result[node.kind] = append(result[node.kind], node.node);\n    return result;\n}, {});\nexport const postfixFollowingOptionalMessage = \"A postfix required element cannot follow an optional element\";\nexport const postfixWithoutVariadicMessage = \"A postfix element requires a variadic element\";\nconst _intersectSequences = (s) => {\n    const [lHead, ...lTail] = s.l;\n    const [rHead, ...rTail] = s.r;\n    if (!lHead || !rHead)\n        return s;\n    const lHasPostfix = lTail.at(-1)?.kind === \"postfix\";\n    const rHasPostfix = rTail.at(-1)?.kind === \"postfix\";\n    const kind = lHead.kind === \"prefix\" || rHead.kind === \"prefix\" ? \"prefix\"\n        : lHead.kind === \"optionals\" || rHead.kind === \"optionals\" ?\n            // if either operand has postfix elements, the full-length\n            // intersection can't include optional elements (though they may\n            // exist in some of the fixed length variants)\n            lHasPostfix || rHasPostfix ?\n                \"prefix\"\n                : \"optionals\"\n            : lHead.kind === \"postfix\" || rHead.kind === \"postfix\" ? \"postfix\"\n                : \"variadic\";\n    if (lHead.kind === \"prefix\" && rHead.kind === \"variadic\" && rHasPostfix) {\n        const postfixBranchResult = _intersectSequences({\n            ...s,\n            fixedVariants: [],\n            r: rTail.map(element => ({ ...element, kind: \"prefix\" }))\n        });\n        if (postfixBranchResult.disjoint.isEmpty())\n            s.fixedVariants.push(postfixBranchResult);\n    }\n    else if (rHead.kind === \"prefix\" &&\n        lHead.kind === \"variadic\" &&\n        lHasPostfix) {\n        const postfixBranchResult = _intersectSequences({\n            ...s,\n            fixedVariants: [],\n            l: lTail.map(element => ({ ...element, kind: \"prefix\" }))\n        });\n        if (postfixBranchResult.disjoint.isEmpty())\n            s.fixedVariants.push(postfixBranchResult);\n    }\n    const result = intersectNodes(lHead.node, rHead.node, s.ctx);\n    if (result instanceof Disjoint) {\n        if (kind === \"prefix\" || kind === \"postfix\") {\n            s.disjoint.add(result.withPrefixKey(\n            // TODO: more precise path handling for Disjoints\n            kind === \"prefix\" ? `${s.result.length}` : `-${lTail.length + 1}`));\n            s.result = [...s.result, { kind, node: s.ctx.$.keywords.never.raw }];\n        }\n        else if (kind === \"optionals\") {\n            // if the element result is optional and unsatisfiable, the\n            // intersection can still be satisfied as long as the tuple\n            // ends before the disjoint element would occur\n            return s;\n        }\n        else {\n            // if the element is variadic and unsatisfiable, the intersection\n            // can be satisfied with a fixed length variant including zero\n            // variadic elements\n            return _intersectSequences({\n                ...s,\n                fixedVariants: [],\n                // if there were any optional elements, there will be no postfix elements\n                // so this mapping will never occur (which would be illegal otherwise)\n                l: lTail.map(element => ({ ...element, kind: \"prefix\" })),\n                r: lTail.map(element => ({ ...element, kind: \"prefix\" }))\n            });\n        }\n    }\n    else\n        s.result = [...s.result, { kind, node: result }];\n    const lRemaining = s.l.length;\n    const rRemaining = s.r.length;\n    if (lHead.kind !== \"variadic\" ||\n        (lRemaining >= rRemaining &&\n            (rHead.kind === \"variadic\" || rRemaining === 1)))\n        s.l = lTail;\n    if (rHead.kind !== \"variadic\" ||\n        (rRemaining >= lRemaining &&\n            (lHead.kind === \"variadic\" || lRemaining === 1)))\n        s.r = rTail;\n    return _intersectSequences(s);\n};\n", "import { registeredReference } from \"@arktype/util\";\nexport const arrayIndexMatcher = /(?:0|(?:[1-9]\\\\d*))$/;\nexport const arrayIndexMatcherReference = registeredReference(arrayIndexMatcher);\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { append, cached, flatMorph, registeredReference, spliterate } from \"@arktype/util\";\nimport { BaseConstraint, constraintKeyParser, flattenConstraints, intersectConstraints } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodesRoot } from \"../shared/intersections.js\";\nimport { makeRootAndArrayPropertiesMutable } from \"../shared/utils.js\";\nimport { arrayIndexMatcher, arrayIndexMatcherReference } from \"./shared.js\";\nlet StructureNode = (() => {\n    let _classSuper = BaseConstraint;\n    let _instanceExtraInitializers = [];\n    let _keyof_decorators;\n    return class StructureNode extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _keyof_decorators = [cached];\n            __esDecorate(this, null, _keyof_decorators, { kind: \"method\", name: \"keyof\", static: false, private: false, access: { has: obj => \"keyof\" in obj, get: obj => obj.keyof }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        impliedBasis = (__runInitializers(this, _instanceExtraInitializers), this.$.keywords.object.raw);\n        impliedSiblings = this.children.flatMap(n => n.impliedSiblings ?? []);\n        props = this.required ?\n            this.optional ?\n                [...this.required, ...this.optional]\n                : this.required\n            : this.optional ?? [];\n        propsByKey = flatMorph(this.props, (i, node) => [node.key, node]);\n        propsByKeyReference = registeredReference(this.propsByKey);\n        expression = structuralExpression(this);\n        requiredLiteralKeys = this.required?.map(node => node.key) ?? [];\n        optionalLiteralKeys = this.optional?.map(node => node.key) ?? [];\n        literalKeys = [\n            ...this.requiredLiteralKeys,\n            ...this.optionalLiteralKeys\n        ];\n        keyof() {\n            let branches = this.$.units(this.literalKeys).branches;\n            this.index?.forEach(({ signature: index }) => {\n                branches = branches.concat(index.branches);\n            });\n            return this.$.node(\"union\", branches);\n        }\n        exhaustive = this.undeclared !== undefined || this.index !== undefined;\n        omit(...keys) {\n            return this.$.node(\"structure\", omitFromInner(this.inner, keys));\n        }\n        merge(r) {\n            const inner = makeRootAndArrayPropertiesMutable(omitFromInner(this.inner, [r.keyof()]));\n            if (r.required)\n                inner.required = append(inner.required, r.required);\n            if (r.optional)\n                inner.optional = append(inner.optional, r.optional);\n            if (r.index)\n                inner.index = append(inner.index, r.index);\n            if (r.sequence)\n                inner.sequence = r.sequence;\n            if (r.undeclared)\n                inner.undeclared = r.undeclared;\n            else\n                delete inner.undeclared;\n            return this.$.node(\"structure\", inner);\n        }\n        traverseAllows = (data, ctx) => this._traverse(\"Allows\", data, ctx);\n        traverseApply = (data, ctx) => this._traverse(\"Apply\", data, ctx);\n        _traverse = (traversalKind, data, ctx) => {\n            const errorCount = ctx?.currentErrorCount ?? 0;\n            for (let i = 0; i < this.props.length; i++) {\n                if (traversalKind === \"Allows\") {\n                    if (!this.props[i].traverseAllows(data, ctx))\n                        return false;\n                }\n                else {\n                    this.props[i].traverseApply(data, ctx);\n                    if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                        return false;\n                }\n            }\n            if (this.sequence) {\n                if (traversalKind === \"Allows\") {\n                    if (!this.sequence.traverseAllows(data, ctx))\n                        return false;\n                }\n                else {\n                    this.sequence.traverseApply(data, ctx);\n                    if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                        return false;\n                }\n            }\n            if (!this.exhaustive)\n                return true;\n            const keys = Object.keys(data);\n            keys.push(...Object.getOwnPropertySymbols(data));\n            for (let i = 0; i < keys.length; i++) {\n                const k = keys[i];\n                let matched = false;\n                if (this.index) {\n                    for (const node of this.index) {\n                        if (node.signature.traverseAllows(k, ctx)) {\n                            if (traversalKind === \"Allows\") {\n                                ctx?.path.push(k);\n                                const result = node.value.traverseAllows(data[k], ctx);\n                                ctx?.path.pop();\n                                if (!result)\n                                    return false;\n                            }\n                            else {\n                                ctx.path.push(k);\n                                node.value.traverseApply(data[k], ctx);\n                                ctx.path.pop();\n                                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                                    return false;\n                            }\n                            matched = true;\n                        }\n                    }\n                }\n                if (this.undeclared) {\n                    matched ||= k in this.propsByKey;\n                    matched ||=\n                        this.sequence !== undefined &&\n                            typeof k === \"string\" &&\n                            arrayIndexMatcher.test(k);\n                    if (!matched) {\n                        if (traversalKind === \"Allows\")\n                            return false;\n                        if (this.undeclared === \"reject\")\n                            ctx.error({ expected: \"removed\", actual: null, relativePath: [k] });\n                        else {\n                            ctx.queueMorphs([\n                                data => {\n                                    delete data[k];\n                                    return data;\n                                }\n                            ]);\n                        }\n                        if (ctx.failFast)\n                            return false;\n                    }\n                }\n                ctx?.path.pop();\n            }\n            return true;\n        };\n        compile(js) {\n            if (js.traversalKind === \"Apply\")\n                js.initializeErrorCount();\n            this.props.forEach(prop => {\n                js.check(prop);\n                if (js.traversalKind === \"Apply\")\n                    js.returnIfFailFast();\n            });\n            if (this.sequence) {\n                js.check(this.sequence);\n                if (js.traversalKind === \"Apply\")\n                    js.returnIfFailFast();\n            }\n            if (this.exhaustive) {\n                js.const(\"keys\", \"Object.keys(data)\");\n                js.line(\"keys.push(...Object.getOwnPropertySymbols(data))\");\n                js.for(\"i < keys.length\", () => this.compileExhaustiveEntry(js));\n            }\n            if (js.traversalKind === \"Allows\")\n                js.return(true);\n        }\n        compileExhaustiveEntry(js) {\n            js.const(\"k\", \"keys[i]\");\n            if (this.undeclared)\n                js.let(\"matched\", false);\n            this.index?.forEach(node => {\n                js.if(`${js.invoke(node.signature, { arg: \"k\", kind: \"Allows\" })}`, () => {\n                    js.traverseKey(\"k\", \"data[k]\", node.value);\n                    if (this.undeclared)\n                        js.set(\"matched\", true);\n                    return js;\n                });\n            });\n            if (this.undeclared) {\n                if (this.props?.length !== 0)\n                    js.line(`matched ||= k in ${this.propsByKeyReference}`);\n                if (this.sequence) {\n                    js.line(`matched ||= typeof k === \"string\" && ${arrayIndexMatcherReference}.test(k)`);\n                }\n                js.if(\"!matched\", () => {\n                    if (js.traversalKind === \"Allows\")\n                        return js.return(false);\n                    return this.undeclared === \"reject\" ?\n                        js\n                            .line(`ctx.error({ expected: \"removed\", actual: null, relativePath: [k] })`)\n                            .if(\"ctx.failFast\", () => js.return())\n                        : js.line(`ctx.queueMorphs([data => { delete data[k]; return data }])`);\n                });\n            }\n            return js;\n        }\n    };\n})();\nexport { StructureNode };\nconst omitFromInner = (inner, keys) => {\n    const result = { ...inner };\n    keys.forEach(k => {\n        if (result.required) {\n            result.required = result.required.filter(b => typeof k === \"function\" ? !k.allows(b.key) : k !== b.key);\n        }\n        if (result.optional) {\n            result.optional = result.optional.filter(b => typeof k === \"function\" ? !k.allows(b.key) : k !== b.key);\n        }\n        if (result.index && typeof k === \"function\") {\n            // we only have to filter index nodes if the input was a node, as\n            // literal keys should never subsume an index\n            result.index = result.index.filter(n => !n.signature.extends(k));\n        }\n    });\n    return result;\n};\nconst createStructuralWriter = (childStringProp) => (node) => {\n    if (node.props.length || node.index) {\n        const parts = node.index?.map(String) ?? [];\n        node.props.forEach(node => parts.push(node[childStringProp]));\n        if (node.undeclared)\n            parts.push(`+ (undeclared): ${node.undeclared}`);\n        const objectLiteralDescription = `{ ${parts.join(\", \")} }`;\n        return node.sequence ?\n            `${objectLiteralDescription} & ${node.sequence.description}`\n            : objectLiteralDescription;\n    }\n    return node.sequence?.description ?? \"{}\";\n};\nconst structuralDescription = createStructuralWriter(\"description\");\nconst structuralExpression = createStructuralWriter(\"expression\");\nexport const structureImplementation = implementNode({\n    kind: \"structure\",\n    hasAssociatedError: false,\n    normalize: schema => schema,\n    keys: {\n        required: {\n            child: true,\n            parse: constraintKeyParser(\"required\")\n        },\n        optional: {\n            child: true,\n            parse: constraintKeyParser(\"optional\")\n        },\n        index: {\n            child: true,\n            parse: constraintKeyParser(\"index\")\n        },\n        sequence: {\n            child: true,\n            parse: constraintKeyParser(\"sequence\")\n        },\n        undeclared: {\n            parse: behavior => (behavior === \"ignore\" ? undefined : behavior)\n        }\n    },\n    defaults: {\n        description: structuralDescription\n    },\n    intersections: {\n        structure: (l, r, ctx) => {\n            const lInner = { ...l.inner };\n            const rInner = { ...r.inner };\n            if (l.undeclared) {\n                const lKey = l.keyof();\n                const disjointRKeys = r.requiredLiteralKeys.filter(k => !lKey.allows(k));\n                if (disjointRKeys.length) {\n                    return Disjoint.from(\"presence\", ctx.$.keywords.never.raw, r.propsByKey[disjointRKeys[0]].value).withPrefixKey(disjointRKeys[0]);\n                }\n                if (rInner.optional)\n                    rInner.optional = rInner.optional.filter(n => lKey.allows(n.key));\n                if (rInner.index) {\n                    rInner.index = rInner.index.flatMap(n => {\n                        if (n.signature.extends(lKey))\n                            return n;\n                        const indexOverlap = intersectNodesRoot(lKey, n.signature, ctx.$);\n                        if (indexOverlap instanceof Disjoint)\n                            return [];\n                        const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);\n                        if (normalized.required) {\n                            rInner.required =\n                                rInner.required ?\n                                    [...rInner.required, ...normalized.required]\n                                    : normalized.required;\n                        }\n                        return normalized.index ?? [];\n                    });\n                }\n            }\n            if (r.undeclared) {\n                const rKey = r.keyof();\n                const disjointLKeys = l.requiredLiteralKeys.filter(k => !rKey.allows(k));\n                if (disjointLKeys.length) {\n                    return Disjoint.from(\"presence\", l.propsByKey[disjointLKeys[0]].value, ctx.$.keywords.never.raw).withPrefixKey(disjointLKeys[0]);\n                }\n                if (lInner.optional)\n                    lInner.optional = lInner.optional.filter(n => rKey.allows(n.key));\n                if (lInner.index) {\n                    lInner.index = lInner.index.flatMap(n => {\n                        if (n.signature.extends(rKey))\n                            return n;\n                        const indexOverlap = intersectNodesRoot(rKey, n.signature, ctx.$);\n                        if (indexOverlap instanceof Disjoint)\n                            return [];\n                        const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);\n                        if (normalized.required) {\n                            lInner.required =\n                                lInner.required ?\n                                    [...lInner.required, ...normalized.required]\n                                    : normalized.required;\n                        }\n                        return normalized.index ?? [];\n                    });\n                }\n            }\n            const baseInner = {};\n            if (l.undeclared || r.undeclared) {\n                baseInner.undeclared =\n                    l.undeclared === \"reject\" || r.undeclared === \"reject\" ?\n                        \"reject\"\n                        : \"delete\";\n            }\n            return intersectConstraints({\n                kind: \"structure\",\n                baseInner,\n                l: flattenConstraints(lInner),\n                r: flattenConstraints(rInner),\n                roots: [],\n                ctx\n            });\n        }\n    }\n});\n/** extract enumerable named props from an index signature */\nexport const normalizeIndex = (signature, value, $) => {\n    const [enumerableBranches, nonEnumerableBranches] = spliterate(signature.branches, (k) => k.hasKind(\"unit\"));\n    if (!enumerableBranches.length)\n        return { index: $.node(\"index\", { signature, value }) };\n    const normalized = {};\n    normalized.required = enumerableBranches.map(n => $.node(\"required\", { key: n.unit, value }));\n    if (nonEnumerableBranches.length) {\n        normalized.index = $.node(\"index\", {\n            signature: nonEnumerableBranches,\n            value\n        });\n    }\n    return normalized;\n};\n", "import { PredicateNode, predicateImplementation } from \"./predicate.js\";\nimport { DivisorNode, divisorImplementation } from \"./refinements/divisor.js\";\nimport { boundClassesByKind, boundImplementationsByKind } from \"./refinements/kinds.js\";\nimport { RegexNode, regexImplementation } from \"./refinements/regex.js\";\nimport { AliasNode, aliasImplementation } from \"./roots/alias.js\";\nimport { DomainNode, domainImplementation } from \"./roots/domain.js\";\nimport { IntersectionNode, intersectionImplementation } from \"./roots/intersection.js\";\nimport { MorphNode, morphImplementation } from \"./roots/morph.js\";\nimport { ProtoNode, protoImplementation } from \"./roots/proto.js\";\nimport { UnionNode, unionImplementation } from \"./roots/union.js\";\nimport { UnitNode, unitImplementation } from \"./roots/unit.js\";\nimport { IndexNode, indexImplementation } from \"./structure/index.js\";\nimport { OptionalNode, optionalImplementation } from \"./structure/optional.js\";\nimport { RequiredNode, requiredImplementation } from \"./structure/required.js\";\nimport { SequenceNode, sequenceImplementation } from \"./structure/sequence.js\";\nimport { StructureNode, structureImplementation } from \"./structure/structure.js\";\nexport const nodeImplementationsByKind = {\n    ...boundImplementationsByKind,\n    alias: aliasImplementation,\n    domain: domainImplementation,\n    unit: unitImplementation,\n    proto: protoImplementation,\n    union: unionImplementation,\n    morph: morphImplementation,\n    intersection: intersectionImplementation,\n    divisor: divisorImplementation,\n    regex: regexImplementation,\n    predicate: predicateImplementation,\n    required: requiredImplementation,\n    optional: optionalImplementation,\n    index: indexImplementation,\n    sequence: sequenceImplementation,\n    structure: structureImplementation\n};\nexport const nodeClassesByKind = {\n    ...boundClassesByKind,\n    alias: AliasNode,\n    domain: DomainNode,\n    unit: UnitNode,\n    proto: ProtoNode,\n    union: UnionNode,\n    morph: MorphNode,\n    intersection: IntersectionNode,\n    divisor: DivisorNode,\n    regex: RegexNode,\n    predicate: PredicateNode,\n    required: RequiredNode,\n    optional: OptionalNode,\n    index: IndexNode,\n    sequence: SequenceNode,\n    structure: StructureNode\n};\n", "import { DynamicBase } from \"@arktype/util\";\nimport { arkKind } from \"./shared/utils.js\";\nexport class RootModule extends DynamicBase {\n    // ensure `[arkKind]` is non-enumerable so it doesn't get spread on import/export\n    get [arkKind]() {\n        return \"module\";\n    }\n}\nexport const SchemaModule = RootModule;\n", "import { entriesOf, hasDomain, isArray, printable, throwParseError, unset } from \"@arktype/util\";\nimport { nodeClassesByKind, nodeImplementationsByKind } from \"./kinds.js\";\nimport { Disjoint } from \"./shared/disjoint.js\";\nimport { constraintKeys, defaultValueSerializer, isNodeKind, precedenceOfKind } from \"./shared/implement.js\";\nimport { hasArkKind } from \"./shared/utils.js\";\nexport const schemaKindOf = (schema, allowedKinds) => {\n    const kind = discriminateRootKind(schema);\n    if (allowedKinds && !allowedKinds.includes(kind)) {\n        return throwParseError(`Root of kind ${kind} should be one of ${allowedKinds}`);\n    }\n    return kind;\n};\nconst discriminateRootKind = (schema) => {\n    switch (typeof schema) {\n        case \"string\":\n            return schema[0] === \"$\" ? \"alias\" : \"domain\";\n        case \"function\":\n            return hasArkKind(schema, \"root\") ? schema.kind : \"proto\";\n        case \"object\": {\n            // throw at end of function\n            if (schema === null)\n                break;\n            if (\"morphs\" in schema)\n                return \"morph\";\n            if (\"branches\" in schema || isArray(schema))\n                return \"union\";\n            if (\"unit\" in schema)\n                return \"unit\";\n            if (\"alias\" in schema)\n                return \"alias\";\n            const schemaKeys = Object.keys(schema);\n            if (schemaKeys.length === 0 || schemaKeys.some(k => k in constraintKeys))\n                return \"intersection\";\n            if (\"proto\" in schema)\n                return \"proto\";\n            if (\"domain\" in schema)\n                return \"domain\";\n        }\n    }\n    return throwParseError(`${printable(schema)} is not a valid type schema`);\n};\nconst nodeCache = {};\nconst serializeListableChild = (listableNode) => isArray(listableNode) ?\n    listableNode.map(node => node.collapsibleJson)\n    : listableNode.collapsibleJson;\nexport const parseNode = (kind, ctx) => {\n    const impl = nodeImplementationsByKind[kind];\n    const inner = {};\n    // ensure node entries are parsed in order of precedence, with non-children\n    // parsed first\n    const schemaEntries = entriesOf(ctx.schema).sort(([lKey], [rKey]) => isNodeKind(lKey) ?\n        isNodeKind(rKey) ? precedenceOfKind(lKey) - precedenceOfKind(rKey)\n            : 1\n        : isNodeKind(rKey) ? -1\n            : lKey < rKey ? -1\n                : 1);\n    const children = [];\n    for (const entry of schemaEntries) {\n        const k = entry[0];\n        const keyImpl = impl.keys[k];\n        if (!keyImpl)\n            return throwParseError(`Key ${k} is not valid on ${kind} schema`);\n        const v = keyImpl.parse ? keyImpl.parse(entry[1], ctx) : entry[1];\n        if (v !== unset && (v !== undefined || keyImpl.preserveUndefined))\n            inner[k] = v;\n    }\n    const entries = entriesOf(inner);\n    let json = {};\n    let typeJson = {};\n    entries.forEach(([k, v]) => {\n        const listableNode = v;\n        const keyImpl = impl.keys[k];\n        const serialize = keyImpl.serialize ??\n            (keyImpl.child ? serializeListableChild : defaultValueSerializer);\n        json[k] = serialize(listableNode);\n        if (keyImpl.child) {\n            if (isArray(listableNode))\n                children.push(...listableNode);\n            else\n                children.push(listableNode);\n        }\n        if (!keyImpl.meta)\n            typeJson[k] = json[k];\n    });\n    if (impl.finalizeJson) {\n        json = impl.finalizeJson(json);\n        typeJson = impl.finalizeJson(typeJson);\n    }\n    let collapsibleJson = json;\n    const collapsibleKeys = Object.keys(collapsibleJson);\n    if (collapsibleKeys.length === 1 &&\n        collapsibleKeys[0] === impl.collapsibleKey) {\n        collapsibleJson = collapsibleJson[impl.collapsibleKey];\n        if (\n        // if the collapsibleJson is still an object\n        hasDomain(collapsibleJson, \"object\") &&\n            // and the JSON did not include any implied keys\n            Object.keys(json).length === 1) {\n            // we can replace it with its collapsed value\n            json = collapsibleJson;\n            typeJson = collapsibleJson;\n        }\n    }\n    const innerHash = JSON.stringify({ kind, ...json });\n    if (ctx.reduceTo) {\n        nodeCache[innerHash] = ctx.reduceTo;\n        return ctx.reduceTo;\n    }\n    const typeHash = JSON.stringify({ kind, ...typeJson });\n    if (impl.reduce && !ctx.prereduced) {\n        const reduced = impl.reduce(inner, ctx.$);\n        if (reduced) {\n            if (reduced instanceof Disjoint)\n                return reduced.throw();\n            // if we're defining the resolution of an alias and the result is\n            // reduced to another node, add the alias to that node if it doesn't\n            // already have one.\n            if (ctx.alias)\n                reduced.alias ??= ctx.alias;\n            // we can't cache this reduction for now in case the reduction involved\n            // impliedSiblings\n            return reduced;\n        }\n    }\n    // we have to wait until after reduction to return a cached entry,\n    // since reduction can add impliedSiblings\n    if (nodeCache[innerHash])\n        return nodeCache[innerHash];\n    const attachments = {\n        id: ctx.id,\n        kind,\n        impl,\n        inner,\n        entries,\n        json: json,\n        typeJson: typeJson,\n        collapsibleJson: collapsibleJson,\n        children,\n        innerHash,\n        typeHash,\n        $: ctx.$\n    };\n    if (ctx.alias)\n        attachments.alias = ctx.alias;\n    for (const k in inner) {\n        if (k !== \"description\" && k !== \"in\" && k !== \"out\")\n            attachments[k] = inner[k];\n    }\n    const node = new nodeClassesByKind[kind](attachments);\n    nodeCache[innerHash] = node;\n    return node;\n};\n", "import { CompiledFunction } from \"@arktype/util\";\nexport class NodeCompiler extends CompiledFunction {\n    traversalKind;\n    path = [];\n    discriminants = [];\n    constructor(traversalKind) {\n        super(\"data\", \"ctx\");\n        this.traversalKind = traversalKind;\n    }\n    invoke(node, opts) {\n        const arg = opts?.arg ?? this.data;\n        if (this.requiresContextFor(node))\n            return `${this.reference(node, opts)}(${arg}, ${this.ctx})`;\n        return `${this.reference(node, opts)}(${arg})`;\n    }\n    reference(node, opts) {\n        const invokedKind = opts?.kind ?? this.traversalKind;\n        const base = `this.${node.id}${invokedKind}`;\n        return opts?.bind ? `${base}.bind(${opts?.bind})` : base;\n    }\n    requiresContextFor(node) {\n        return this.traversalKind === \"Apply\" || node.allowsRequiresContext;\n    }\n    initializeErrorCount() {\n        return this.const(\"errorCount\", \"ctx.currentErrorCount\");\n    }\n    returnIfFail() {\n        return this.if(\"ctx.currentErrorCount > errorCount\", () => this.return());\n    }\n    returnIfFailFast() {\n        return this.if(\"ctx.failFast && ctx.currentErrorCount > errorCount\", () => this.return());\n    }\n    traverseKey(keyExpression, accessExpression, node) {\n        const requiresContext = this.requiresContextFor(node);\n        if (requiresContext)\n            this.line(`${this.ctx}.path.push(${keyExpression})`);\n        this.check(node, {\n            arg: accessExpression\n        });\n        if (requiresContext)\n            this.line(`${this.ctx}.path.pop()`);\n        return this;\n    }\n    check(node, opts) {\n        return this.traversalKind === \"Allows\" ?\n            this.if(`!${this.invoke(node, opts)}`, () => this.return(false))\n            : this.line(this.invoke(node, opts));\n    }\n    writeMethod(name) {\n        return `${name}(${this.argNames.join(\", \")}){\\n${this.body}    }\\n`;\n    }\n}\n", "var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { CompiledFunction, DynamicBase, ParseError, bound, envHasCsp, flatMorph, hasDomain, isArray, printable, throwInternalError, throwParseError } from \"@arktype/util\";\nimport { globalConfig, mergeConfigs } from \"./config.js\";\nimport { validateUninstantiatedGenericNode } from \"./generic.js\";\nimport { nodeImplementationsByKind } from \"./kinds.js\";\nimport { RootModule } from \"./module.js\";\nimport { parseNode, schemaKindOf } from \"./parse.js\";\nimport { normalizeAliasSchema } from \"./roots/alias.js\";\nimport { NodeCompiler } from \"./shared/compile.js\";\nimport { arkKind, hasArkKind, isNode } from \"./shared/utils.js\";\nexport const defaultConfig = Object.assign(flatMorph(nodeImplementationsByKind, (kind, implementation) => [\n    kind,\n    implementation.defaults\n]), {\n    jitless: envHasCsp(),\n    registerKeywords: false,\n    prereducedAliases: false\n});\nconst nonInheritedKeys = [\n    \"registerKeywords\",\n    \"prereducedAliases\"\n];\nexport const extendConfig = (base, extension) => {\n    if (!extension)\n        return base;\n    const result = mergeConfigs(base, extension);\n    nonInheritedKeys.forEach(k => {\n        if (!(k in extension))\n            delete result[k];\n    });\n    return result;\n};\nexport const resolveConfig = (config) => extendConfig(extendConfig(defaultConfig, globalConfig), config);\nconst schemaBranchesOf = (schema) => isArray(schema) ? schema\n    : \"branches\" in schema && isArray(schema.branches) ? schema.branches\n        : undefined;\nconst throwMismatchedNodeRootError = (expected, actual) => throwParseError(`Node of kind ${actual} is not valid as a ${expected} definition`);\nexport const writeDuplicateAliasError = (alias) => `#${alias} duplicates public alias ${alias}`;\nconst nodeCountsByPrefix = {};\nconst nodesById = {};\nlet scopeCount = 0;\nconst scopesById = {};\nlet RawRootScope = (() => {\n    let _instanceExtraInitializers = [];\n    let _schema_decorators;\n    let _defineRoot_decorators;\n    let _units_decorators;\n    return class RawRootScope {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(null) : void 0;\n            _schema_decorators = [bound];\n            _defineRoot_decorators = [bound];\n            _units_decorators = [bound];\n            __esDecorate(this, null, _schema_decorators, { kind: \"method\", name: \"schema\", static: false, private: false, access: { has: obj => \"schema\" in obj, get: obj => obj.schema }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _defineRoot_decorators, { kind: \"method\", name: \"defineRoot\", static: false, private: false, access: { has: obj => \"defineRoot\" in obj, get: obj => obj.defineRoot }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _units_decorators, { kind: \"method\", name: \"units\", static: false, private: false, access: { has: obj => \"units\" in obj, get: obj => obj.units }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        config = __runInitializers(this, _instanceExtraInitializers);\n        resolvedConfig;\n        id = `$${++scopeCount}`;\n        [arkKind] = \"scope\";\n        referencesById = {};\n        references = [];\n        resolutions = {};\n        json = {};\n        exportedNames;\n        aliases = {};\n        resolved = false;\n        // these allow builtin types to be accessed during parsing without cyclic imports\n        // they are populated as each scope is parsed with `registerKeywords` in its config\n        /** @internal */\n        static keywords = {};\n        /** @internal */\n        get keywords() {\n            return RawRootScope.keywords;\n        }\n        static ambient;\n        get ambient() {\n            return this.constructor.ambient;\n        }\n        constructor(\n        /** The set of names defined at the root-level of the scope mapped to their\n         * corresponding definitions.**/\n        def, config) {\n            this.config = config ?? {};\n            this.resolvedConfig = resolveConfig(config);\n            this.exportedNames = Object.keys(def).filter(k => {\n                if (k[0] === \"#\") {\n                    const name = k.slice(1);\n                    if (name in this.aliases)\n                        throwParseError(writeDuplicateAliasError(name));\n                    this.aliases[name] = def[k];\n                    return false;\n                }\n                if (k in this.aliases)\n                    throwParseError(writeDuplicateAliasError(k));\n                this.aliases[k] = def[k];\n                return true;\n            });\n            if (this.ambient) {\n                // ensure exportedResolutions is populated\n                this.ambient.export();\n                // TODO: generics and modules\n                this.resolutions = flatMorph(this.ambient.resolutions, (alias, resolution) => [\n                    alias,\n                    hasArkKind(resolution, \"root\") ?\n                        resolution.bindScope(this)\n                        : resolution\n                ]);\n            }\n            scopesById[this.id] = this;\n        }\n        get raw() {\n            return this;\n        }\n        schema(def, opts) {\n            return this.node(schemaKindOf(def), def, opts);\n        }\n        defineRoot(def) {\n            return def;\n        }\n        units(values, opts) {\n            const uniqueValues = [];\n            for (const value of values)\n                if (!uniqueValues.includes(value))\n                    uniqueValues.push(value);\n            const branches = uniqueValues.map(unit => this.node(\"unit\", { unit }, opts));\n            return this.node(\"union\", branches, {\n                ...opts,\n                prereduced: true\n            });\n        }\n        lazyResolutions = [];\n        lazilyResolve(resolve, syntheticAlias) {\n            if (!syntheticAlias) {\n                nodeCountsByPrefix.synthetic ??= 0;\n                syntheticAlias = `synthetic${++nodeCountsByPrefix.synthetic}`;\n            }\n            const node = this.node(\"alias\", {\n                alias: syntheticAlias,\n                resolve\n            }, { prereduced: true });\n            this.lazyResolutions.push(node);\n            return node;\n        }\n        node = (((kinds, nodeSchema, opts) => {\n            let kind = typeof kinds === \"string\" ? kinds : schemaKindOf(nodeSchema, kinds);\n            let schema = nodeSchema;\n            if (isNode(schema) && schema.kind === kind)\n                return schema.bindScope(this);\n            if (kind === \"alias\" && !opts?.prereduced) {\n                const resolution = this.resolveRoot(normalizeAliasSchema(schema).alias);\n                schema = resolution;\n                kind = resolution.kind;\n            }\n            else if (kind === \"union\" && hasDomain(schema, \"object\")) {\n                const branches = schemaBranchesOf(schema);\n                if (branches?.length === 1) {\n                    schema = branches[0];\n                    kind = schemaKindOf(schema);\n                }\n            }\n            const impl = nodeImplementationsByKind[kind];\n            const normalizedSchema = impl.normalize?.(schema) ?? schema;\n            // check again after normalization in case a node is a valid collapsed\n            // schema for the kind (e.g. sequence can collapse to element accepting a Node)\n            if (isNode(normalizedSchema)) {\n                return normalizedSchema.kind === kind ?\n                    normalizedSchema.bindScope(this)\n                    : throwMismatchedNodeRootError(kind, normalizedSchema.kind);\n            }\n            const prefix = opts?.alias ?? kind;\n            nodeCountsByPrefix[prefix] ??= 0;\n            const id = `${prefix}${++nodeCountsByPrefix[prefix]}`;\n            const node = parseNode(kind, {\n                ...opts,\n                id,\n                $: this,\n                schema: normalizedSchema\n            }).bindScope(this);\n            nodesById[id] = node;\n            if (this.resolved) {\n                // this node was not part of the original scope, so compile an anonymous scope\n                // including only its references\n                if (!this.resolvedConfig.jitless)\n                    bindCompiledScope(node.references);\n            }\n            else {\n                // we're still parsing the scope itself, so defer compilation but\n                // add the node as a reference\n                Object.assign(this.referencesById, node.referencesById);\n            }\n            return node;\n        })).bind(this);\n        parseRoot(def, opts) {\n            return this.schema(def, opts);\n        }\n        resolveRoot(name) {\n            return (this.maybeResolveRoot(name) ??\n                throwParseError(writeUnresolvableMessage(name)));\n        }\n        maybeResolveRoot(name) {\n            const result = this.maybeResolveGenericOrRoot(name);\n            if (hasArkKind(result, \"generic\"))\n                return;\n            return result;\n        }\n        maybeResolveGenericOrRoot(name) {\n            const resolution = this.maybeResolve(name);\n            if (hasArkKind(resolution, \"module\"))\n                return throwParseError(writeMissingSubmoduleAccessMessage(name));\n            return resolution;\n        }\n        preparseRoot(def) {\n            return def;\n        }\n        maybeResolve(name) {\n            const resolution = this.maybeShallowResolve(name);\n            return typeof resolution === \"string\" ?\n                this.node(\"alias\", { alias: resolution }, { prereduced: true })\n                : resolution;\n        }\n        maybeShallowResolve(name) {\n            const cached = this.resolutions[name];\n            if (cached)\n                return cached;\n            let def = this.aliases[name];\n            if (!def)\n                return this.maybeResolveSubalias(name);\n            def = this.preparseRoot(def);\n            if (hasArkKind(def, \"generic\"))\n                return (this.resolutions[name] = validateUninstantiatedGenericNode(def));\n            if (hasArkKind(def, \"module\"))\n                return (this.resolutions[name] = def);\n            this.resolutions[name] = name;\n            return (this.resolutions[name] = this.parseRoot(def));\n        }\n        /** If name is a valid reference to a submodule alias, return its resolution  */\n        maybeResolveSubalias(name) {\n            return resolveSubalias(this.aliases, name);\n        }\n        import(...names) {\n            return new RootModule(flatMorph(this.export(...names), (alias, value) => [\n                `#${alias}`,\n                value\n            ]));\n        }\n        _exportedResolutions;\n        _exports;\n        export(...names) {\n            if (!this._exports) {\n                this._exports = {};\n                for (const name of this.exportedNames) {\n                    const resolution = this.maybeResolve(name);\n                    if (hasArkKind(resolution, \"root\")) {\n                        resolution.references\n                            .filter((node) => node.hasKind(\"alias\"))\n                            .forEach(aliasNode => {\n                            Object.assign(aliasNode.referencesById, aliasNode.resolution.referencesById);\n                            resolution.references.forEach(ref => {\n                                if (aliasNode.id in ref.referencesById)\n                                    Object.assign(ref.referencesById, aliasNode.referencesById);\n                            });\n                        });\n                    }\n                    this._exports[name] = resolution;\n                }\n                this.lazyResolutions.forEach(node => node.resolution);\n                this._exportedResolutions = resolutionsOfModule(this, this._exports);\n                // TODO: add generic json\n                Object.assign(this.json, flatMorph(this._exportedResolutions, (k, v) => hasArkKind(v, \"root\") ? [k, v.json] : []));\n                Object.assign(this.resolutions, this._exportedResolutions);\n                if (this.config.registerKeywords)\n                    Object.assign(RawRootScope.keywords, this._exportedResolutions);\n                this.references = Object.values(this.referencesById);\n                if (!this.resolvedConfig.jitless)\n                    bindCompiledScope(this.references);\n                this.resolved = true;\n            }\n            const namesToExport = names.length ? names : this.exportedNames;\n            return new RootModule(flatMorph(namesToExport, (_, name) => [\n                name,\n                this._exports[name]\n            ]));\n        }\n        resolve(name) {\n            return this.export()[name];\n        }\n    };\n})();\nexport { RawRootScope };\nconst resolveSubalias = (base, name) => {\n    const dotIndex = name.indexOf(\".\");\n    if (dotIndex === -1)\n        return;\n    const dotPrefix = name.slice(0, dotIndex);\n    const prefixSchema = base[dotPrefix];\n    // if the name includes \".\", but the prefix is not an alias, it\n    // might be something like a decimal literal, so just fall through to return\n    if (prefixSchema === undefined)\n        return;\n    if (!hasArkKind(prefixSchema, \"module\"))\n        return throwParseError(writeNonSubmoduleDotMessage(dotPrefix));\n    const subalias = name.slice(dotIndex + 1);\n    const resolution = prefixSchema[subalias];\n    // if the first part of name is a submodule but the suffix is\n    // unresolvable, we can throw immediately\n    if (resolution === undefined) {\n        if (hasArkKind(resolution, \"module\"))\n            return resolveSubalias(resolution, subalias);\n        return throwParseError(writeUnresolvableMessage(name));\n    }\n    if (hasArkKind(resolution, \"root\") || hasArkKind(resolution, \"generic\"))\n        return resolution;\n    throwInternalError(`Unexpected resolution for alias '${name}': ${printable(resolution)}`);\n};\nexport const schemaScope = (aliases, config) => new RootScope(aliases, config);\nexport const RootScope = RawRootScope;\nexport const root = new RootScope({});\nexport const schema = root.schema;\nexport const node = root.node;\nexport const defineRoot = root.defineRoot;\nexport const units = root.units;\nexport const rawSchema = root.raw.schema;\nexport const rawNode = root.raw.node;\nexport const defineRawRoot = root.raw.defineRoot;\nexport const rawUnits = root.raw.units;\nexport const parseAsSchema = (def, opts) => {\n    try {\n        return schema(def, opts);\n    }\n    catch (e) {\n        if (e instanceof ParseError)\n            return e;\n        throw e;\n    }\n};\nexport class RawRootModule extends DynamicBase {\n}\nconst resolutionsOfModule = ($, typeSet) => {\n    const result = {};\n    for (const k in typeSet) {\n        const v = typeSet[k];\n        if (hasArkKind(v, \"module\")) {\n            const innerResolutions = resolutionsOfModule($, v);\n            const prefixedResolutions = flatMorph(innerResolutions, (innerK, innerV) => [`${k}.${innerK}`, innerV]);\n            Object.assign(result, prefixedResolutions);\n        }\n        else if (hasArkKind(v, \"generic\"))\n            result[k] = v;\n        else if (hasArkKind(v, \"root\"))\n            result[k] = v;\n        else\n            throwInternalError(`Unexpected scope resolution ${printable(v)}`);\n    }\n    return result;\n};\nexport const writeUnresolvableMessage = (token) => `'${token}' is unresolvable`;\nexport const writeNonSubmoduleDotMessage = (name) => `'${name}' must reference a module to be accessed using dot syntax`;\nexport const writeMissingSubmoduleAccessMessage = (name) => `Reference to submodule '${name}' must specify an alias`;\nexport const bindCompiledScope = (references) => {\n    const compiledTraversals = compileScope(references);\n    for (const node of references) {\n        if (node.jit) {\n            // if node has already been bound to another scope or anonymous type, don't rebind it\n            continue;\n        }\n        node.jit = true;\n        node.traverseAllows =\n            compiledTraversals[`${node.id}Allows`].bind(compiledTraversals);\n        if (node.isRoot() && !node.allowsRequiresContext) {\n            // if the reference doesn't require context, we can assign over\n            // it directly to avoid having to initialize it\n            node.allows = node.traverseAllows;\n        }\n        node.traverseApply =\n            compiledTraversals[`${node.id}Apply`].bind(compiledTraversals);\n    }\n};\nconst compileScope = (references) => new CompiledFunction()\n    .block(\"return\", js => {\n    references.forEach(node => {\n        const allowsCompiler = new NodeCompiler(\"Allows\").indent();\n        node.compile(allowsCompiler);\n        const applyCompiler = new NodeCompiler(\"Apply\").indent();\n        node.compile(applyCompiler);\n        js.line(`${allowsCompiler.writeMethod(`${node.id}Allows`)},`).line(`${applyCompiler.writeMethod(`${node.id}Apply`)},`);\n    });\n    return js;\n})\n    .compile()();\n", "import { schemaScope } from \"../scope.js\";\nexport const tsKeywords = schemaScope({\n    any: {},\n    bigint: \"bigint\",\n    // since we know this won't be reduced, it can be safely cast to a union\n    boolean: [{ unit: false }, { unit: true }],\n    false: { unit: false },\n    never: [],\n    null: { unit: null },\n    number: \"number\",\n    object: \"object\",\n    string: \"string\",\n    symbol: \"symbol\",\n    true: { unit: true },\n    unknown: {},\n    void: { unit: undefined },\n    undefined: { unit: undefined }\n}, { prereducedAliases: true, registerKeywords: true }).export();\n", "import { root, schemaScope } from \"../scope.js\";\n// these are needed to create some internal types\nimport { arrayIndexMatcher } from \"../structure/shared.js\";\nimport \"./tsKeywords.js\";\nexport const internalKeywords = schemaScope({\n    lengthBoundable: [\"string\", Array],\n    propertyKey: [\"string\", \"symbol\"],\n    nonNegativeIntegerString: { domain: \"string\", regex: arrayIndexMatcher }\n}, {\n    prereducedAliases: true,\n    registerKeywords: true\n}).export();\n// reduce union of all possible values reduces to unknown\nroot.node(\"union\", {\n    branches: [\n        \"string\",\n        \"number\",\n        \"object\",\n        \"bigint\",\n        \"symbol\",\n        { unit: true },\n        { unit: false },\n        { unit: null },\n        { unit: undefined }\n    ]\n}, { reduceTo: root.node(\"intersection\", {}, { prereduced: true }) });\n", "import { schemaScope } from \"../scope.js\";\nexport const jsObjects = schemaScope({\n    Array,\n    Function,\n    Date,\n    Error,\n    Map,\n    RegExp,\n    Set,\n    WeakMap,\n    WeakSet,\n    Promise\n}, { prereducedAliases: true, registerKeywords: true }).export();\n", "const dayDelimiterMatcher = /^[./-]$/;\n// ISO 8601 date/time modernized from https://github.com/validatorjs/validator.js/blob/master/src/lib/isISO8601.js\n// Based on https://tc39.es/ecma262/#sec-date-time-string-format, the T\n// delimiter for date/time is mandatory. Regex from validator.js strict matcher:\nconst iso8601Matcher = /^([+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([.,]\\d+(?!:))?)?(\\17[0-5]\\d([.,]\\d+)?)?([zZ]|([+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\nconst isValidDateInstance = (date) => !Number.isNaN(+date);\nconst writeFormattedExpected = (format) => `a ${format}-formatted date`;\nexport const tryParseDatePattern = (data, opts) => {\n    if (!opts?.format) {\n        const result = new Date(data);\n        return isValidDateInstance(result) ? result : \"a valid date\";\n    }\n    if (opts.format === \"iso8601\") {\n        return iso8601Matcher.test(data) ?\n            new Date(data)\n            : writeFormattedExpected(\"iso8601\");\n    }\n    const dataParts = data.split(dayDelimiterMatcher);\n    // will be the first delimiter matched, if there is one\n    const delimiter = data[dataParts[0].length];\n    const formatParts = delimiter ? opts.format.split(delimiter) : [opts.format];\n    if (dataParts.length !== formatParts.length)\n        return writeFormattedExpected(opts.format);\n    const parsedParts = {};\n    for (let i = 0; i < formatParts.length; i++) {\n        if (dataParts[i].length !== formatParts[i].length &&\n            // if format is \"m\" or \"d\", data is allowed to be 1 or 2 characters\n            !(formatParts[i].length === 1 && dataParts[i].length === 2))\n            return writeFormattedExpected(opts.format);\n        parsedParts[formatParts[i][0]] = dataParts[i];\n    }\n    const date = new Date(`${parsedParts.m}/${parsedParts.d}/${parsedParts.y}`);\n    if (`${date.getDate()}` === parsedParts.d)\n        return date;\n    return writeFormattedExpected(opts.format);\n};\n", "import { root } from \"../../scope.js\";\nexport const defineRegex = (regex, description) => root.defineRoot({\n    domain: \"string\",\n    regex: {\n        rule: regex.source,\n        flags: regex.flags,\n        description\n    }\n});\n", "import { isWellFormedInteger, wellFormedIntegerMatcher, wellFormedNumberMatcher } from \"@arktype/util\";\nimport { root, schemaScope } from \"../scope.js\";\nimport { tryParseDatePattern } from \"./utils/date.js\";\nimport { defineRegex } from \"./utils/regex.js\";\nconst number = root.defineRoot({\n    in: defineRegex(wellFormedNumberMatcher, \"a well-formed numeric string\"),\n    morphs: (s) => Number.parseFloat(s)\n});\nconst integer = root.defineRoot({\n    in: defineRegex(wellFormedIntegerMatcher, \"a well-formed integer string\"),\n    morphs: (s, ctx) => {\n        if (!isWellFormedInteger(s))\n            return ctx.error(\"a well-formed integer string\");\n        const parsed = Number.parseInt(s);\n        return Number.isSafeInteger(parsed) ? parsed : (ctx.error(\"an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER\"));\n    }\n});\nconst url = root.defineRoot({\n    in: \"string\",\n    morphs: (s, ctx) => {\n        try {\n            return new URL(s);\n        }\n        catch {\n            return ctx.error(\"a valid URL\");\n        }\n    }\n});\nconst json = root.defineRoot({\n    in: \"string\",\n    morphs: (s, ctx) => {\n        try {\n            return JSON.parse(s);\n        }\n        catch {\n            return ctx.error(\"a valid JSON string\");\n        }\n    }\n});\nconst date = root.defineRoot({\n    in: \"string\",\n    morphs: (s, ctx) => {\n        const result = tryParseDatePattern(s);\n        return typeof result === \"string\" ? ctx.error(result) : result;\n    }\n});\nexport const parsing = schemaScope({\n    url,\n    number,\n    integer,\n    date,\n    json\n}).export();\n", "// https://github.com/validatorjs/validator.js/blob/master/src/lib/isLuhnNumber.js\nexport const isLuhnValid = (creditCardInput) => {\n    const sanitized = creditCardInput.replace(/[- ]+/g, \"\");\n    let sum = 0;\n    let digit;\n    let tmpNum;\n    let shouldDouble = false;\n    for (let i = sanitized.length - 1; i >= 0; i--) {\n        digit = sanitized.substring(i, i + 1);\n        tmpNum = Number.parseInt(digit, 10);\n        if (shouldDouble) {\n            tmpNum *= 2;\n            if (tmpNum >= 10)\n                sum += (tmpNum % 10) + 1;\n            else\n                sum += tmpNum;\n        }\n        else\n            sum += tmpNum;\n        shouldDouble = !shouldDouble;\n    }\n    return !!(sum % 10 === 0 ? sanitized : false);\n};\n// https://github.com/validatorjs/validator.js/blob/master/src/lib/isCreditCard.js\nexport const creditCardMatcher = /^(?:4[0-9]{12}(?:[0-9]{3,6})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12,15}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11}|6[27][0-9]{14}|^(81[0-9]{14,17}))$/;\n", "import { root } from \"../../scope.js\";\nimport { defineRegex } from \"./regex.js\";\n// Based on https://github.com/validatorjs/validator.js/blob/master/src/lib/isIP.js\nconst ipv4Segment = \"(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\";\nconst ipv4Address = `(${ipv4Segment}[.]){3}${ipv4Segment}`;\nconst ipv4Matcher = new RegExp(`^${ipv4Address}$`);\nexport const ipv4 = defineRegex(ipv4Matcher, \"a valid IPv4 address\");\nconst ipv6Segment = \"(?:[0-9a-fA-F]{1,4})\";\nconst ipv6Matcher = new RegExp(\"^(\" +\n    `(?:${ipv6Segment}:){7}(?:${ipv6Segment}|:)|` +\n    `(?:${ipv6Segment}:){6}(?:${ipv4Address}|:${ipv6Segment}|:)|` +\n    `(?:${ipv6Segment}:){5}(?::${ipv4Address}|(:${ipv6Segment}){1,2}|:)|` +\n    `(?:${ipv6Segment}:){4}(?:(:${ipv6Segment}){0,1}:${ipv4Address}|(:${ipv6Segment}){1,3}|:)|` +\n    `(?:${ipv6Segment}:){3}(?:(:${ipv6Segment}){0,2}:${ipv4Address}|(:${ipv6Segment}){1,4}|:)|` +\n    `(?:${ipv6Segment}:){2}(?:(:${ipv6Segment}){0,3}:${ipv4Address}|(:${ipv6Segment}){1,5}|:)|` +\n    `(?:${ipv6Segment}:){1}(?:(:${ipv6Segment}){0,4}:${ipv4Address}|(:${ipv6Segment}){1,6}|:)|` +\n    `(?::((?::${ipv6Segment}){0,5}:${ipv4Address}|(?::${ipv6Segment}){1,7}|:))` +\n    \")(%[0-9a-zA-Z-.:]{1,})?$\");\nexport const ipv6 = defineRegex(ipv6Matcher, \"a valid IPv6 address\");\nexport const ip = root.defineRoot([ipv4, ipv6]);\n", "import { root, schemaScope } from \"../scope.js\";\nimport { creditCardMatcher, isLuhnValid } from \"./utils/creditCard.js\";\nimport { ip } from \"./utils/ip.js\";\nimport { defineRegex } from \"./utils/regex.js\";\n// Non-trivial expressions should have an explanation or attribution\nconst url = root.defineRoot({\n    domain: \"string\",\n    predicate: {\n        predicate: (s) => {\n            try {\n                new URL(s);\n            }\n            catch {\n                return false;\n            }\n            return true;\n        },\n        description: \"a valid URL\"\n    }\n});\n// https://www.regular-expressions.info/email.html\nconst emailMatcher = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$/;\nconst email = defineRegex(emailMatcher, \"a valid email\");\nconst uuidMatcher = /^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$/;\n// https://github.com/validatorjs/validator.js/blob/master/src/lib/isUUID.js\nconst uuid = defineRegex(uuidMatcher, \"a valid UUID\");\nconst semverMatcher = /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n// https://semver.org/\nconst semver = defineRegex(semverMatcher, \"a valid semantic version (see https://semver.org/)\");\nconst creditCard = root.defineRoot({\n    domain: \"string\",\n    regex: {\n        rule: creditCardMatcher.source,\n        description: \"a valid credit card number\"\n    },\n    predicate: {\n        predicate: isLuhnValid,\n        description: \"a valid credit card number\"\n    }\n});\nexport const validation = schemaScope({\n    alpha: defineRegex(/^[A-Za-z]*$/, \"only letters\"),\n    alphanumeric: defineRegex(/^[A-Za-z\\d]*$/, \"only letters and digits 0-9\"),\n    digits: defineRegex(/^\\d*$/, \"only digits 0-9\"),\n    lowercase: defineRegex(/^[a-z]*$/, \"only lowercase letters\"),\n    uppercase: defineRegex(/^[A-Z]*$/, \"only uppercase letters\"),\n    creditCard,\n    email,\n    uuid,\n    url,\n    semver,\n    ip,\n    integer: {\n        domain: \"number\",\n        divisor: 1\n    }\n}, { prereducedAliases: true }).export();\n", "import { RawRootScope, schemaScope } from \"../scope.js\";\n// the import ordering here is important so builtin keywords can be resolved\n// and used to bootstrap nodes with constraints\nimport { tsKeywords } from \"./tsKeywords.js\";\nimport { jsObjects } from \"./jsObjects.js\";\nimport { parsing } from \"./parsing.js\";\nimport { validation } from \"./validation.js\";\nexport const ambientRootScope = schemaScope({\n    ...tsKeywords,\n    ...jsObjects,\n    ...validation,\n    parse: parsing\n    // TODO: remove cast\n});\nRawRootScope.ambient = ambientRootScope.raw;\nexport const keywordNodes = ambientRootScope.export();\n", "import { arkKind } from \"@arktype/schema\";\nimport { Callable } from \"@arktype/util\";\nexport class Generic extends Callable {\n    params;\n    def;\n    $;\n    [arkKind] = \"generic\";\n    constructor(params, def, \n    // TODO: should be Scope<$>, but breaks inference\n    $) {\n        super((...args) => {\n            // const argNodes = flatMorph(params, (i, param: string) => [\n            // \tparam,\n            // \t$.parseRoot(args[i])\n            // ])\n            // { args: argNodes }\n            args;\n            return $.parseRoot(def);\n        });\n        this.params = params;\n        this.def = def;\n        this.$ = $;\n    }\n}\n", "export const createMatchParser = ($) => (() => { }).bind($);\n// const matchParser = (isRestricted: boolean) => {\n// \tconst handledCases: { when: RawRoot; then: Morph }[] = []\n// \tlet defaultCase: ((x: unknown) => unknown) | null = null\n// \tconst parser = {\n// \t\twhen: (when: unknown, then: Morph) => {\n// \t\t\thandledCases.push({ when: $.parseRoot(when, {}), then })\n// \t\t\treturn parser\n// \t\t},\n// \t\tfinalize: () => {\n// \t\t\t// TODO: exhaustiveness checking\n// \t\t\tconst branches = handledCases.flatMap(({ when, then }) => {\n// \t\t\t\tif (when.kind === \"union\") {\n// \t\t\t\t\treturn when.branches.map((branch) => ({\n// \t\t\t\t\t\tin: branch,\n// \t\t\t\t\t\tmorph: then\n// \t\t\t\t\t}))\n// \t\t\t\t}\n// \t\t\t\tif (when.kind === \"morph\") {\n// \t\t\t\t\treturn [{ in: when, morph: [when.morph, then] }]\n// \t\t\t\t}\n// \t\t\t\treturn [{ in: when, morph: then }]\n// \t\t\t})\n// \t\t\tif (defaultCase) {\n// \t\t\t\tbranches.push({ in: keywordNodes.unknown, morph: defaultCase })\n// \t\t\t}\n// \t\t\tconst matchers = $.node(\"union\", {\n// \t\t\t\tbranches,\n// \t\t\t\tordered: true\n// \t\t\t})\n// \t\t\treturn matchers.assert\n// \t\t},\n// \t\torThrow: () => {\n// \t\t\t// implicitly finalize, we don't need to do anything else because we throw either way\n// \t\t\treturn parser.finalize()\n// \t\t},\n// \t\tdefault: (x: unknown) => {\n// \t\t\tif (x instanceof Function) {\n// \t\t\t\tdefaultCase = x as never\n// \t\t\t} else {\n// \t\t\t\tdefaultCase = () => x\n// \t\t\t}\n// \t\t\treturn parser.finalize()\n// \t\t}\n// \t}\n// \treturn parser\n// }\n// return Object.assign(() => matchParser(false), {\n// \tonly: () => matchParser(true)\n// }) as never\n", "import { isKeyOf } from \"@arktype/util\";\nexport class Scanner {\n    chars;\n    i;\n    constructor(def) {\n        this.chars = [...def];\n        this.i = 0;\n    }\n    /** Get lookahead and advance scanner by one */\n    shift() {\n        return (this.chars[this.i++] ?? \"\");\n    }\n    get lookahead() {\n        return (this.chars[this.i] ?? \"\");\n    }\n    get nextLookahead() {\n        return this.chars[this.i + 1] ?? \"\";\n    }\n    get length() {\n        return this.chars.length;\n    }\n    shiftUntil(condition) {\n        let shifted = \"\";\n        while (this.lookahead) {\n            if (condition(this, shifted)) {\n                if (shifted[shifted.length - 1] === Scanner.escapeToken)\n                    shifted = shifted.slice(0, -1);\n                else\n                    break;\n            }\n            shifted += this.shift();\n        }\n        return shifted;\n    }\n    shiftUntilNextTerminator() {\n        this.shiftUntilNonWhitespace();\n        return this.shiftUntil(Scanner.lookaheadIsTerminator);\n    }\n    shiftUntilNonWhitespace() {\n        return this.shiftUntil(Scanner.lookaheadIsNotWhitespace);\n    }\n    jumpToIndex(i) {\n        this.i = i < 0 ? this.length + i : i;\n    }\n    get location() {\n        return this.i;\n    }\n    get unscanned() {\n        return this.chars.slice(this.i, this.length).join(\"\");\n    }\n    get scanned() {\n        return this.chars.slice(0, this.i).join(\"\");\n    }\n    sliceChars(start, end) {\n        return this.chars.slice(start, end).join(\"\");\n    }\n    lookaheadIs(char) {\n        return this.lookahead === char;\n    }\n    lookaheadIsIn(tokens) {\n        return this.lookahead in tokens;\n    }\n}\n(function (Scanner) {\n    Scanner.lookaheadIsTerminator = (scanner) => scanner.lookahead in Scanner.terminatingChars;\n    Scanner.lookaheadIsNotWhitespace = (scanner) => !(scanner.lookahead in Scanner.whiteSpaceTokens);\n    Scanner.terminatingChars = {\n        \"<\": true,\n        \">\": true,\n        \"=\": true,\n        \"|\": true,\n        \"&\": true,\n        \")\": true,\n        \"[\": true,\n        \"%\": true,\n        \" \": true,\n        \",\": true\n    };\n    Scanner.finalizingLookaheads = {\n        \">\": true,\n        \",\": true,\n        \"\": true\n    };\n    Scanner.escapeToken = \"\\\\\";\n    Scanner.whiteSpaceTokens = {\n        \" \": true,\n        \"\\n\": true,\n        \"\\t\": true\n    };\n    Scanner.lookaheadIsFinalizing = (lookahead, unscanned) => lookahead === \">\" ?\n        unscanned[0] === \"=\" ?\n            // >== would only occur in an expression like Array<number>==5\n            // otherwise, >= would only occur as part of a bound like number>=5\n            unscanned[1] === \"=\"\n            // if > is the end of a generic instantiation, the next token will be an operator or the end of the string\n            : unscanned.trimStart() === \"\" ||\n                isKeyOf(unscanned.trimStart()[0], Scanner.terminatingChars)\n        // if the lookahead is a finalizing token but not >, it's unambiguously a finalizer (currently just \",\")\n        : lookahead === \",\";\n})(Scanner || (Scanner = {}));\n", "import { ArkErrors, normalizeIndex } from \"@arktype/schema\";\nimport { append, isArray, printable, stringAndSymbolicEntriesOf, throwParseError, unset } from \"@arktype/util\";\nimport { Scanner } from \"./string/shift/scanner.js\";\nexport const parseObjectLiteral = (def, ctx) => {\n    let spread;\n    const structure = {};\n    // We only allow a spread operator to be used as the first key in an object\n    // because to match JS behavior any keys before the spread are overwritten\n    // by the values in the target object, so there'd be no useful purpose in having it\n    // anywhere except for the beginning.\n    const parsedEntries = stringAndSymbolicEntriesOf(def).map(parseEntry);\n    if (parsedEntries[0]?.kind === \"...\") {\n        // remove the spread entry so we can iterate over the remaining entries\n        // expecting non-spread entries\n        const spreadEntry = parsedEntries.shift();\n        const spreadNode = ctx.$.parse(spreadEntry.value, ctx);\n        if (!spreadNode.hasKind(\"intersection\") || !spreadNode.structure) {\n            return throwParseError(writeInvalidSpreadTypeMessage(typeof spreadEntry.value === \"string\" ?\n                spreadEntry.value\n                : printable(spreadEntry.value)));\n        }\n        spread = spreadNode.structure;\n    }\n    for (const entry of parsedEntries) {\n        if (entry.kind === \"...\")\n            return throwParseError(nonLeadingSpreadError);\n        if (entry.kind === \"+\") {\n            if (entry.value !== \"reject\" &&\n                entry.value !== \"delete\" &&\n                entry.value !== \"ignore\")\n                throwParseError(writeInvalidUndeclaredBehaviorMessage(entry.value));\n            structure.undeclared = entry.value;\n            continue;\n        }\n        if (entry.kind === \"index\") {\n            // handle key parsing first to match type behavior\n            const key = ctx.$.parse(entry.key, ctx);\n            const value = ctx.$.parse(entry.value, ctx);\n            const normalizedSignature = normalizeIndex(key, value, ctx.$);\n            if (normalizedSignature.required) {\n                structure.required = append(structure.required, normalizedSignature.required);\n            }\n            if (normalizedSignature.index)\n                structure.index = append(structure.index, normalizedSignature.index);\n        }\n        else {\n            const value = ctx.$.parse(entry.value, ctx);\n            const inner = { key: entry.key, value };\n            if (entry.default !== unset) {\n                const out = value(entry.default);\n                if (out instanceof ArkErrors)\n                    throwParseError(`Default value at ${printable(entry.key)} ${out}`);\n                value.assert(entry.default);\n                inner.default = entry.default;\n            }\n            structure[entry.kind] = append(structure[entry.kind], inner);\n        }\n    }\n    const structureNode = ctx.$.node(\"structure\", structure);\n    return ctx.$.schema({\n        domain: \"object\",\n        structure: spread?.merge(structureNode) ?? structureNode\n    });\n};\nexport const writeInvalidUndeclaredBehaviorMessage = (actual) => `Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${printable(actual)})`;\nexport const nonLeadingSpreadError = \"Spread operator may only be used as the first key in an object\";\nexport const parseEntry = ([key, value]) => {\n    const parsedKey = parseKey(key);\n    if (isArray(value) && value[1] === \"=\") {\n        if (parsedKey.kind !== \"required\")\n            throwParseError(invalidDefaultKeyKindMessage);\n        return {\n            kind: \"optional\",\n            key: parsedKey.key,\n            value: value[0],\n            default: value[2]\n        };\n    }\n    return {\n        kind: parsedKey.kind,\n        key: parsedKey.key,\n        value,\n        default: unset\n    };\n};\n// single quote use here is better for TypeScript's inlined error to avoid escapes\nexport const invalidDefaultKeyKindMessage = `Only required keys may specify default values, e.g. { ark: ['string', '=', '⛵'] }`;\nconst parseKey = (key) => typeof key === \"symbol\" ? { kind: \"required\", key }\n    : key.at(-1) === \"?\" ?\n        key.at(-2) === Scanner.escapeToken ?\n            { kind: \"required\", key: `${key.slice(0, -2)}?` }\n            : {\n                kind: \"optional\",\n                key: key.slice(0, -1)\n            }\n        : key[0] === \"[\" && key.at(-1) === \"]\" ?\n            { kind: \"index\", key: key.slice(1, -1) }\n            : key[0] === Scanner.escapeToken && key[1] === \"[\" && key.at(-1) === \"]\" ?\n                { kind: \"required\", key: key.slice(1) }\n                : key === \"...\" || key === \"+\" ? { kind: key, key }\n                    : {\n                        kind: \"required\",\n                        key: key === \"\\\\...\" ? \"...\"\n                            : key === \"\\\\+\" ? \"+\"\n                                : key\n                    };\nexport const writeInvalidSpreadTypeMessage = (def) => `Spread operand must resolve to an object literal type (was ${def})`;\n", "export const writeUnsatisfiableExpressionError = (expression) => `${expression} results in an unsatisfiable type`;\nexport const writePrefixedPrivateReferenceMessage = (def) => `Private type references should not include '#'. Use '${def.slice(1)}' instead.`;\n", "export const minComparators = {\n    \">\": true,\n    \">=\": true\n};\nexport const maxComparators = {\n    \"<\": true,\n    \"<=\": true\n};\nexport const comparators = {\n    \">\": true,\n    \">=\": true,\n    \"<\": true,\n    \"<=\": true,\n    \"==\": true\n};\nexport const invertedComparators = {\n    \"<\": \">\",\n    \">\": \"<\",\n    \"<=\": \">=\",\n    \">=\": \"<=\",\n    \"==\": \"==\"\n};\nexport const writeUnmatchedGroupCloseMessage = (unscanned) => `Unmatched )${(unscanned === \"\" ? \"\" : ` before ${unscanned}`)}`;\nexport const writeUnclosedGroupMessage = (missingChar) => `Missing ${missingChar}`;\nexport const writeOpenRangeMessage = (min, comparator) => `Left bounds are only valid when paired with right bounds (try ...${comparator}${min})`;\nexport const writeUnpairableComparatorMessage = (comparator) => `Left-bounded expressions must specify their limits using < or <= (was ${comparator})`;\nexport const writeMultipleLeftBoundsMessage = (openLimit, openComparator, limit, comparator) => `An expression may have at most one left bound (parsed ${openLimit}${invertedComparators[openComparator]}, ${limit}${invertedComparators[comparator]})`;\n", "import { writeUnclosedGroupMessage } from \"../../reduce/shared.js\";\nexport const parseGenericArgs = (name, params, s) => _parseGenericArgs(name, params, s, [], []);\nconst _parseGenericArgs = (name, params, s, argDefs, argNodes) => {\n    const argState = s.parseUntilFinalizer();\n    // remove the finalizing token from the argDef\n    argDefs.push(argState.scanner.scanned.slice(0, -1));\n    argNodes.push(argState.root);\n    if (argState.finalizer === \">\") {\n        if (argNodes.length === params.length) {\n            return {\n                result: argNodes,\n                unscanned: argState.scanner.unscanned\n            };\n        }\n        return argState.error(writeInvalidGenericArgsMessage(name, params, argDefs));\n    }\n    if (argState.finalizer === \",\")\n        return _parseGenericArgs(name, params, s, argDefs, argNodes);\n    return argState.error(writeUnclosedGroupMessage(\">\"));\n};\nexport const writeInvalidGenericArgsMessage = (name, params, argDefs) => `${name}<${params.join(\", \")}> requires exactly ${params.length} args (got ${argDefs.length}${argDefs.length === 0 ? \"\" : `: ${argDefs.join(\", \")}`})`;\n", "import { BaseRoot, hasArkKind, writeUnresolvableMessage } from \"@arktype/schema\";\nimport { printable, throwParseError, tryParseNumber, tryParseWellFormedBigint } from \"@arktype/util\";\nimport { writePrefixedPrivateReferenceMessage } from \"../../../semantic/validate.js\";\nimport { parseGenericArgs, writeInvalidGenericArgsMessage } from \"./genericArgs.js\";\nexport const parseUnenclosed = (s) => {\n    const token = s.scanner.shiftUntilNextTerminator();\n    if (token === \"keyof\")\n        s.addPrefix(\"keyof\");\n    else\n        s.root = unenclosedToNode(s, token);\n};\nexport const parseGenericInstantiation = (name, g, s) => {\n    s.scanner.shiftUntilNonWhitespace();\n    const lookahead = s.scanner.shift();\n    if (lookahead !== \"<\")\n        return s.error(writeInvalidGenericArgsMessage(name, g.params, []));\n    const parsedArgs = parseGenericArgs(name, g.params, s);\n    const remainingChars = parsedArgs.unscanned.length;\n    // set the scanner position to where the args scanner left off\n    s.scanner.jumpToIndex(remainingChars === 0 ? s.scanner.length : -remainingChars);\n    return g(...parsedArgs.result);\n};\nconst unenclosedToNode = (s, token) => maybeParseReference(s, token) ??\n    maybeParseUnenclosedLiteral(s, token) ??\n    s.error(token === \"\" ? writeMissingOperandMessage(s)\n        : token[0] === \"#\" ?\n            writePrefixedPrivateReferenceMessage(token)\n            : writeUnresolvableMessage(token));\nconst maybeParseReference = (s, token) => {\n    if (s.ctx.args?.[token])\n        return s.ctx.args[token].raw;\n    const resolution = s.ctx.$.maybeResolve(token);\n    if (resolution instanceof BaseRoot)\n        return resolution;\n    if (resolution === undefined)\n        return;\n    if (hasArkKind(resolution, \"generic\"))\n        return parseGenericInstantiation(token, resolution, s);\n    return throwParseError(`Unexpected resolution ${printable(resolution)}`);\n};\nconst maybeParseUnenclosedLiteral = (s, token) => {\n    const maybeNumber = tryParseNumber(token, { strict: true });\n    if (maybeNumber !== undefined)\n        return s.ctx.$.node(\"unit\", { unit: maybeNumber });\n    const maybeBigint = tryParseWellFormedBigint(token);\n    if (maybeBigint !== undefined)\n        return s.ctx.$.node(\"unit\", { unit: maybeBigint });\n};\nexport const writeMissingOperandMessage = (s) => {\n    const operator = s.previousOperator();\n    return operator ?\n        writeMissingRightOperandMessage(operator, s.scanner.unscanned)\n        : writeExpressionExpectedMessage(s.scanner.unscanned);\n};\nexport const writeMissingRightOperandMessage = (token, unscanned = \"\") => `Token '${token}' requires a right operand${unscanned ? ` before '${unscanned}'` : \"\"}`;\nexport const writeExpressionExpectedMessage = (unscanned) => `Expected an expression${unscanned ? ` before '${unscanned}'` : \"\"}`;\n", "import { jsObjects, makeRootAndArrayPropertiesMutable, tsKeywords } from \"@arktype/schema\";\nimport { append, objectKindOrDomainOf, throwParseError } from \"@arktype/util\";\nimport { writeMissingRightOperandMessage } from \"./string/shift/operand/unenclosed.js\";\nexport const parseTuple = (def, ctx) => maybeParseTupleExpression(def, ctx) ?? parseTupleLiteral(def, ctx);\nexport const parseTupleLiteral = (def, ctx) => {\n    let sequences = [{}];\n    let i = 0;\n    while (i < def.length) {\n        let spread = false;\n        let optional = false;\n        if (def[i] === \"...\" && i < def.length - 1) {\n            spread = true;\n            i++;\n        }\n        const element = ctx.$.parse(def[i], ctx);\n        i++;\n        if (def[i] === \"?\") {\n            if (spread)\n                return throwParseError(spreadOptionalMessage);\n            optional = true;\n            i++;\n        }\n        if (spread) {\n            if (!element.extends(jsObjects.Array))\n                return throwParseError(writeNonArraySpreadMessage(element.expression));\n            // a spread must be distributed over branches e.g.:\n            // def: [string, ...(number[] | [true, false])]\n            // nodes: [string, ...number[]] | [string, true, false]\n            sequences = sequences.flatMap(base => \n            // since appendElement mutates base, we have to shallow-ish clone it for each branch\n            element.branches.map(branch => appendSpreadBranch(makeRootAndArrayPropertiesMutable(base), branch)));\n        }\n        else {\n            sequences = sequences.map(base => appendElement(base, optional ? \"optional\" : \"required\", element));\n        }\n    }\n    return ctx.$.raw.schema(sequences.map(sequence => ({\n        proto: Array,\n        sequence\n    })));\n};\nconst appendElement = (base, kind, element) => {\n    switch (kind) {\n        case \"required\":\n            if (base.optionals)\n                // e.g. [string?, number]\n                return throwParseError(requiredPostOptionalMessage);\n            if (base.variadic) {\n                // e.g. [...string[], number]\n                base.postfix = append(base.postfix, element);\n            }\n            else {\n                // e.g. [string, number]\n                base.prefix = append(base.prefix, element);\n            }\n            return base;\n        case \"optional\":\n            if (base.variadic)\n                // e.g. [...string[], number?]\n                return throwParseError(optionalPostVariadicMessage);\n            // e.g. [string, number?]\n            base.optionals = append(base.optionals, element);\n            return base;\n        case \"variadic\":\n            // e.g. [...string[], number, ...string[]]\n            if (base.postfix)\n                throwParseError(multipleVariadicMesage);\n            if (base.variadic) {\n                if (!base.variadic.equals(element)) {\n                    // e.g. [...string[], ...number[]]\n                    throwParseError(multipleVariadicMesage);\n                }\n                // e.g. [...string[], ...string[]]\n                // do nothing, second spread doesn't change the type\n            }\n            else {\n                // e.g. [string, ...number[]]\n                base.variadic = element.raw;\n            }\n            return base;\n    }\n};\nconst appendSpreadBranch = (base, branch) => {\n    const spread = branch.firstReferenceOfKind(\"sequence\");\n    if (!spread) {\n        // the only array with no sequence reference is unknown[]\n        return appendElement(base, \"variadic\", tsKeywords.unknown);\n    }\n    spread.prefix.forEach(node => appendElement(base, \"required\", node));\n    spread.optionals.forEach(node => appendElement(base, \"optional\", node));\n    spread.variadic && appendElement(base, \"variadic\", spread.variadic);\n    spread.postfix.forEach(node => appendElement(base, \"required\", node));\n    return base;\n};\nconst maybeParseTupleExpression = (def, ctx) => {\n    const tupleExpressionResult = isIndexZeroExpression(def) ? prefixParsers[def[0]](def, ctx)\n        : isIndexOneExpression(def) ? indexOneParsers[def[1]](def, ctx)\n            : undefined;\n    return tupleExpressionResult;\n};\nexport const writeNonArraySpreadMessage = (operand) => `Spread element must be an array (was ${operand})`;\nexport const multipleVariadicMesage = \"A tuple may have at most one variadic element\";\nexport const requiredPostOptionalMessage = \"A required element may not follow an optional element\";\nexport const optionalPostVariadicMessage = \"An optional element may not follow a variadic element\";\nexport const spreadOptionalMessage = \"A spread element cannot be optional\";\nexport const parseKeyOfTuple = (def, ctx) => ctx.$.parse(def[1], ctx).keyof();\nconst parseBranchTuple = (def, ctx) => {\n    if (def[2] === undefined)\n        return throwParseError(writeMissingRightOperandMessage(def[1], \"\"));\n    const l = ctx.$.parse(def[0], ctx);\n    const r = ctx.$.parse(def[2], ctx);\n    return def[1] === \"&\" ? l.and(r) : l.or(r);\n};\nconst parseArrayTuple = (def, ctx) => ctx.$.parse(def[0], ctx).array();\nconst isIndexOneExpression = (def) => indexOneParsers[def[1]] !== undefined;\nexport const parseMorphTuple = (def, ctx) => {\n    if (typeof def[2] !== \"function\") {\n        return throwParseError(writeMalformedFunctionalExpressionMessage(\"=>\", def[2]));\n    }\n    // TODO: nested morphs?\n    return ctx.$.parse(def[0], ctx).pipe(def[2]);\n};\nexport const writeMalformedFunctionalExpressionMessage = (operator, value) => `${operator === \":\" ? \"Narrow\" : \"Morph\"} expression requires a function following '${operator}' (was ${typeof value})`;\nexport const parseNarrowTuple = (def, ctx) => {\n    if (typeof def[2] !== \"function\") {\n        return throwParseError(writeMalformedFunctionalExpressionMessage(\":\", def[2]));\n    }\n    return ctx.$.parse(def[0], ctx).constrain(\"predicate\", def[2]);\n};\nconst parseAttributeTuple = (def, ctx) => ctx.$.parse(def[0], ctx).configureShallowDescendants(def[2]);\nconst indexOneParsers = {\n    \"|\": parseBranchTuple,\n    \"&\": parseBranchTuple,\n    \"[]\": parseArrayTuple,\n    \":\": parseNarrowTuple,\n    \"=>\": parseMorphTuple,\n    \"@\": parseAttributeTuple\n};\nconst prefixParsers = {\n    keyof: parseKeyOfTuple,\n    instanceof: (def, ctx) => {\n        if (typeof def[1] !== \"function\") {\n            return throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(def[1])));\n        }\n        const branches = def\n            .slice(1)\n            .map(ctor => typeof ctor === \"function\" ?\n            ctx.$.node(\"proto\", { proto: ctor })\n            : throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(ctor))));\n        return branches.length === 1 ?\n            branches[0]\n            : ctx.$.node(\"union\", { branches });\n    },\n    \"===\": (def, ctx) => ctx.$.units(def.slice(1))\n};\nconst isIndexZeroExpression = (def) => prefixParsers[def[0]] !== undefined;\nexport const writeInvalidConstructorMessage = (actual) => `Expected a constructor following 'instanceof' operator (was ${actual})`;\n", "import { hasArkKind } from \"@arktype/schema\";\nimport { isThunk, objectKindOf, printable, throwParseError } from \"@arktype/util\";\nimport { parseObjectLiteral } from \"./objectLiteral.js\";\nimport { parseTuple } from \"./tuple.js\";\nexport const parseObject = (def, ctx) => {\n    const objectKind = objectKindOf(def);\n    switch (objectKind) {\n        case undefined:\n            if (hasArkKind(def, \"root\"))\n                return def;\n            return parseObjectLiteral(def, ctx);\n        case \"Array\":\n            return parseTuple(def, ctx);\n        case \"RegExp\":\n            return ctx.$.node(\"intersection\", {\n                domain: \"string\",\n                regex: def\n            }, { prereduced: true });\n        case \"Function\": {\n            const resolvedDef = isThunk(def) ? def() : def;\n            if (hasArkKind(resolvedDef, \"root\"))\n                return resolvedDef;\n            return throwParseError(writeBadDefinitionTypeMessage(\"Function\"));\n        }\n        default:\n            return throwParseError(writeBadDefinitionTypeMessage(objectKind ?? printable(def)));\n    }\n};\nexport const writeBadDefinitionTypeMessage = (actual) => `Type definitions must be strings or objects (was ${actual})`;\n", "import { throwParseError, tryParseNumber } from \"@arktype/util\";\nexport const isDateLiteral = (value) => typeof value === \"string\" &&\n    value[0] === \"d\" &&\n    (value[1] === \"'\" || value[1] === '\"') &&\n    value.at(-1) === value[1];\nexport const isValidDate = (d) => d.toString() !== \"Invalid Date\";\nexport const extractDateLiteralSource = (literal) => literal.slice(2, -1);\nexport const writeInvalidDateMessage = (source) => `'${source}' could not be parsed by the Date constructor`;\nexport const tryParseDate = (source, errorOnFail) => maybeParseDate(source, errorOnFail);\nconst maybeParseDate = (source, errorOnFail) => {\n    const stringParsedDate = new Date(source);\n    if (isValidDate(stringParsedDate))\n        return stringParsedDate;\n    const epochMillis = tryParseNumber(source);\n    if (epochMillis !== undefined) {\n        const numberParsedDate = new Date(epochMillis);\n        if (isValidDate(numberParsedDate))\n            return numberParsedDate;\n    }\n    return errorOnFail ?\n        throwParseError(errorOnFail === true ? writeInvalidDateMessage(source) : errorOnFail)\n        : undefined;\n};\n", "import { internalKeywords, jsObjects, tsKeywords, writeUnboundableMessage } from \"@arktype/schema\";\nimport { isKeyOf, throwParseError } from \"@arktype/util\";\nimport { invertedComparators, maxComparators, writeUnpairableComparatorMessage } from \"../../reduce/shared.js\";\nimport { extractDateLiteralSource, isDateLiteral } from \"../operand/date.js\";\nexport const parseBound = (s, start) => {\n    const comparator = shiftComparator(s, start);\n    if (s.root.hasKind(\"unit\")) {\n        if (typeof s.root.unit === \"number\") {\n            s.reduceLeftBound(s.root.unit, comparator);\n            s.unsetRoot();\n            return;\n        }\n        if (s.root.unit instanceof Date) {\n            const literal = `d'${s.root.description ?? s.root.unit.toISOString()}'`;\n            s.unsetRoot();\n            s.reduceLeftBound(literal, comparator);\n            return;\n        }\n    }\n    return parseRightBound(s, comparator);\n};\nconst oneCharComparators = {\n    \"<\": true,\n    \">\": true\n};\nexport const comparatorStartChars = {\n    \"<\": 1,\n    \">\": 1,\n    \"=\": 1\n};\nconst shiftComparator = (s, start) => s.scanner.lookaheadIs(\"=\") ? `${start}${s.scanner.shift()}`\n    : isKeyOf(start, oneCharComparators) ? start\n        : s.error(singleEqualsMessage);\nexport const writeIncompatibleRangeMessage = (l, r) => `Bound kinds ${l} and ${r} are incompatible`;\nexport const getBoundKinds = (comparator, limit, root, boundKind) => {\n    if (root.extends(tsKeywords.number)) {\n        if (typeof limit !== \"number\") {\n            return throwParseError(writeInvalidLimitMessage(comparator, limit, boundKind));\n        }\n        return (comparator === \"==\" ? [\"min\", \"max\"]\n            : comparator[0] === \">\" ? [\"min\"]\n                : [\"max\"]);\n    }\n    if (root.extends(internalKeywords.lengthBoundable)) {\n        if (typeof limit !== \"number\") {\n            return throwParseError(writeInvalidLimitMessage(comparator, limit, boundKind));\n        }\n        return (comparator === \"==\" ? [\"minLength\", \"maxLength\"]\n            : comparator[0] === \">\" ? [\"minLength\"]\n                : [\"maxLength\"]);\n    }\n    if (root.extends(jsObjects.Date)) {\n        // allow either numeric or date limits\n        return (comparator === \"==\" ? [\"after\", \"before\"]\n            : comparator[0] === \">\" ? [\"after\"]\n                : [\"before\"]);\n    }\n    return throwParseError(writeUnboundableMessage(root.expression));\n};\nexport const singleEqualsMessage = \"= is not a valid comparator. Use == to check for equality\";\nconst openLeftBoundToRoot = (leftBound) => ({\n    rule: isDateLiteral(leftBound.limit) ?\n        extractDateLiteralSource(leftBound.limit)\n        : leftBound.limit,\n    exclusive: leftBound.comparator.length === 1\n});\nexport const parseRightBound = (s, comparator) => {\n    // store the node that will be bounded\n    const previousRoot = s.unsetRoot();\n    const previousScannerIndex = s.scanner.location;\n    s.parseOperand();\n    const limitNode = s.unsetRoot();\n    // after parsing the next operand, use the locations to get the\n    // token from which it was parsed\n    const limitToken = s.scanner.sliceChars(previousScannerIndex, s.scanner.location);\n    s.root = previousRoot;\n    if (!limitNode.hasKind(\"unit\") ||\n        (typeof limitNode.unit !== \"number\" && !(limitNode.unit instanceof Date)))\n        return s.error(writeInvalidLimitMessage(comparator, limitToken, \"right\"));\n    const limit = limitNode.unit;\n    // apply the newly-parsed right bound\n    const exclusive = comparator.length === 1;\n    // if the comparator is ==, both the min and max of that pair will be applied\n    for (const kind of getBoundKinds(comparator, typeof limit === \"number\" ? limit : limitToken, previousRoot, \"right\"))\n        s.constrainRoot(kind, { rule: limit, exclusive });\n    if (!s.branches.leftBound)\n        return;\n    // if there's an open left bound, perform additional validation and apply it\n    if (!isKeyOf(comparator, maxComparators))\n        return s.error(writeUnpairableComparatorMessage(comparator));\n    const lowerBoundKind = getBoundKinds(s.branches.leftBound.comparator, s.branches.leftBound.limit, previousRoot, \"left\");\n    s.constrainRoot(lowerBoundKind[0], openLeftBoundToRoot(s.branches.leftBound));\n    s.branches.leftBound = null;\n};\nexport const writeInvalidLimitMessage = (comparator, limit, boundKind) => `Comparator ${boundKind === \"left\" ? invertedComparators[comparator] : comparator} must be ${boundKind === \"left\" ? \"preceded\" : \"followed\"} by a corresponding literal (was ${limit})`;\n", "import { tryParseInteger } from \"@arktype/util\";\nexport const parseDivisor = (s) => {\n    const divisorToken = s.scanner.shiftUntilNextTerminator();\n    const divisor = tryParseInteger(divisorToken, {\n        errorOnFail: writeInvalidDivisorMessage(divisorToken)\n    });\n    if (divisor === 0)\n        s.error(writeInvalidDivisorMessage(0));\n    s.root = s.root.constrain(\"divisor\", divisor);\n};\nexport const writeInvalidDivisorMessage = (divisor) => `% operator must be followed by a non-zero integer literal (was ${divisor})`;\n", "import { isKeyOf } from \"@arktype/util\";\nimport { Scanner } from \"../scanner.js\";\nimport { comparatorStartChars, parseBound } from \"./bounds.js\";\nimport { parseDivisor } from \"./divisor.js\";\nexport const parseOperator = (s) => {\n    const lookahead = s.scanner.shift();\n    return (lookahead === \"\" ? s.finalize(\"\")\n        : lookahead === \"[\" ?\n            s.scanner.shift() === \"]\" ?\n                s.setRoot(s.root.array())\n                : s.error(incompleteArrayTokenMessage)\n            : lookahead === \"|\" || lookahead === \"&\" ? s.pushRootToBranch(lookahead)\n                : lookahead === \")\" ? s.finalizeGroup()\n                    : Scanner.lookaheadIsFinalizing(lookahead, s.scanner.unscanned) ?\n                        s.finalize(lookahead)\n                        : isKeyOf(lookahead, comparatorStartChars) ? parseBound(s, lookahead)\n                            : lookahead === \"%\" ? parseDivisor(s)\n                                : lookahead === \" \" ? parseOperator(s)\n                                    : s.error(writeUnexpectedCharacterMessage(lookahead)));\n};\nexport const writeUnexpectedCharacterMessage = (char, shouldBe = \"\") => `'${char}' is not allowed here${shouldBe && ` (should be ${shouldBe})`}`;\nexport const incompleteArrayTokenMessage = `Missing expected ']'`;\n", "import { throwParseError } from \"@arktype/util\";\nimport { writeUnexpectedCharacterMessage } from \"./string/shift/operator/operator.js\";\nimport { Scanner } from \"./string/shift/scanner.js\";\nexport const parseGenericParams = (def) => _parseGenericParams(new Scanner(def));\nexport const emptyGenericParameterMessage = \"An empty string is not a valid generic parameter name\";\nconst _parseGenericParams = (scanner) => {\n    const param = scanner.shiftUntilNextTerminator();\n    if (param === \"\")\n        throwParseError(emptyGenericParameterMessage);\n    scanner.shiftUntilNonWhitespace();\n    const nextNonWhitespace = scanner.shift();\n    return (nextNonWhitespace === \"\" ? [param]\n        : nextNonWhitespace === \",\" ? [param, ..._parseGenericParams(scanner)]\n            : throwParseError(writeUnexpectedCharacterMessage(nextNonWhitespace, \",\")));\n};\n", "import { isKeyOf } from \"@arktype/util\";\nimport { tryParseDate, writeInvalidDateMessage } from \"./date.js\";\nexport const parseEnclosed = (s, enclosing) => {\n    const enclosed = s.scanner.shiftUntil(untilLookaheadIsClosing[enclosingTokens[enclosing]]);\n    if (s.scanner.lookahead === \"\")\n        return s.error(writeUnterminatedEnclosedMessage(enclosed, enclosing));\n    // Shift the scanner one additional time for the second enclosing token\n    s.scanner.shift();\n    if (enclosing === \"/\") {\n        // fail parsing if the regex is invalid\n        new RegExp(enclosed);\n        s.root = s.ctx.$.node(\"intersection\", {\n            domain: \"string\",\n            regex: enclosed\n        }, { prereduced: true });\n    }\n    else if (isKeyOf(enclosing, enclosingQuote))\n        s.root = s.ctx.$.node(\"unit\", { unit: enclosed });\n    else {\n        const date = tryParseDate(enclosed, writeInvalidDateMessage(enclosed));\n        s.root = s.ctx.$.node(\"unit\", { unit: date, description: enclosed });\n    }\n};\nexport const enclosingQuote = {\n    \"'\": 1,\n    '\"': 1\n};\nexport const enclosingChar = {\n    \"/\": 1,\n    \"'\": 1,\n    '\"': 1\n};\nexport const enclosingTokens = {\n    \"d'\": \"'\",\n    'd\"': '\"',\n    \"'\": \"'\",\n    '\"': '\"',\n    \"/\": \"/\"\n};\nexport const untilLookaheadIsClosing = {\n    \"'\": scanner => scanner.lookahead === `'`,\n    '\"': scanner => scanner.lookahead === `\"`,\n    \"/\": scanner => scanner.lookahead === `/`\n};\nconst enclosingCharDescriptions = {\n    '\"': \"double-quote\",\n    \"'\": \"single-quote\",\n    \"/\": \"forward slash\"\n};\nexport const writeUnterminatedEnclosedMessage = (fragment, enclosingStart) => `${enclosingStart}${fragment} requires a closing ${enclosingCharDescriptions[enclosingTokens[enclosingStart]]}`;\n", "import { Scanner } from \"../scanner.js\";\nimport { enclosingChar, enclosingQuote, parseEnclosed } from \"./enclosed.js\";\nimport { parseUnenclosed, writeMissingOperandMessage } from \"./unenclosed.js\";\nexport const parseOperand = (s) => s.scanner.lookahead === \"\" ? s.error(writeMissingOperandMessage(s))\n    : s.scanner.lookahead === \"(\" ? s.shiftedByOne().reduceGroupOpen()\n        : s.scanner.lookaheadIsIn(enclosingChar) ? parseEnclosed(s, s.scanner.shift())\n            : s.scanner.lookaheadIsIn(Scanner.whiteSpaceTokens) ?\n                parseOperand(s.shiftedByOne())\n                : s.scanner.lookahead === \"d\" ?\n                    s.scanner.nextLookahead in enclosingQuote ?\n                        parseEnclosed(s, `${s.scanner.shift()}${s.scanner.shift()}`)\n                        : parseUnenclosed(s)\n                    : parseUnenclosed(s);\n", "import { throwInternalError, throwParseError } from \"@arktype/util\";\nimport { writeUnexpectedCharacterMessage } from \"./shift/operator/operator.js\";\nexport const fullStringParse = (s) => {\n    s.parseOperand();\n    const result = parseUntilFinalizer(s).root;\n    if (!result) {\n        return throwInternalError(`Root was unexpectedly unset after parsing string '${s.scanner.scanned}'`);\n    }\n    s.scanner.shiftUntilNonWhitespace();\n    if (s.scanner.lookahead) {\n        // throw a parse error if non-whitespace characters made it here without being parsed\n        throwParseError(writeUnexpectedCharacterMessage(s.scanner.lookahead));\n    }\n    return result;\n};\nexport const parseUntilFinalizer = (s) => {\n    while (s.finalizer === undefined)\n        next(s);\n    return s;\n};\nconst next = (s) => s.hasRoot() ? s.parseOperator() : s.parseOperand();\n", "import { isKeyOf, throwInternalError, throwParseError } from \"@arktype/util\";\nimport { parseOperand } from \"../shift/operand/operand.js\";\nimport { parseOperator } from \"../shift/operator/operator.js\";\nimport { Scanner } from \"../shift/scanner.js\";\nimport { parseUntilFinalizer } from \"../string.js\";\nimport { invertedComparators, minComparators, writeMultipleLeftBoundsMessage, writeOpenRangeMessage, writeUnclosedGroupMessage, writeUnmatchedGroupCloseMessage, writeUnpairableComparatorMessage } from \"./shared.js\";\nexport class DynamicState {\n    ctx;\n    scanner;\n    // set root type to `any` so that all constraints can be applied\n    root;\n    branches = {\n        prefixes: [],\n        leftBound: null,\n        intersection: null,\n        union: null\n    };\n    finalizer;\n    groups = [];\n    constructor(def, ctx) {\n        this.ctx = ctx;\n        this.scanner = new Scanner(def);\n    }\n    error(message) {\n        return throwParseError(message);\n    }\n    hasRoot() {\n        return this.root !== undefined;\n    }\n    setRoot(root) {\n        this.root = root;\n    }\n    unsetRoot() {\n        const value = this.root;\n        this.root = undefined;\n        return value;\n    }\n    constrainRoot(...args) {\n        this.root = this.root.constrain(args[0], args[1]);\n    }\n    finalize(finalizer) {\n        if (this.groups.length)\n            return this.error(writeUnclosedGroupMessage(\")\"));\n        this.finalizeBranches();\n        this.finalizer = finalizer;\n    }\n    reduceLeftBound(limit, comparator) {\n        const invertedComparator = invertedComparators[comparator];\n        if (!isKeyOf(invertedComparator, minComparators))\n            return this.error(writeUnpairableComparatorMessage(comparator));\n        if (this.branches.leftBound) {\n            return this.error(writeMultipleLeftBoundsMessage(this.branches.leftBound.limit, this.branches.leftBound.comparator, limit, invertedComparator));\n        }\n        this.branches.leftBound = {\n            comparator: invertedComparator,\n            limit\n        };\n    }\n    finalizeBranches() {\n        this.assertRangeUnset();\n        if (this.branches.union) {\n            this.pushRootToBranch(\"|\");\n            this.root = this.branches.union;\n        }\n        else if (this.branches.intersection) {\n            this.pushRootToBranch(\"&\");\n            this.root = this.branches.intersection;\n        }\n        else\n            this.applyPrefixes();\n    }\n    finalizeGroup() {\n        this.finalizeBranches();\n        const topBranchState = this.groups.pop();\n        if (!topBranchState)\n            return this.error(writeUnmatchedGroupCloseMessage(this.scanner.unscanned));\n        this.branches = topBranchState;\n    }\n    addPrefix(prefix) {\n        this.branches.prefixes.push(prefix);\n    }\n    applyPrefixes() {\n        while (this.branches.prefixes.length) {\n            const lastPrefix = this.branches.prefixes.pop();\n            this.root =\n                lastPrefix === \"keyof\" ?\n                    this.root.keyof()\n                    : throwInternalError(`Unexpected prefix '${lastPrefix}'`);\n        }\n    }\n    pushRootToBranch(token) {\n        this.assertRangeUnset();\n        this.applyPrefixes();\n        const root = this.root;\n        this.branches.intersection = this.branches.intersection?.and(root) ?? root;\n        if (token === \"|\") {\n            this.branches.union =\n                this.branches.union?.or(this.branches.intersection) ??\n                    this.branches.intersection;\n            this.branches.intersection = null;\n        }\n        this.root = undefined;\n    }\n    parseUntilFinalizer() {\n        return parseUntilFinalizer(new DynamicState(this.scanner.unscanned, this.ctx));\n    }\n    parseOperator() {\n        return parseOperator(this);\n    }\n    parseOperand() {\n        return parseOperand(this);\n    }\n    assertRangeUnset() {\n        if (this.branches.leftBound) {\n            return this.error(writeOpenRangeMessage(this.branches.leftBound.limit, this.branches.leftBound.comparator));\n        }\n    }\n    reduceGroupOpen() {\n        this.groups.push(this.branches);\n        this.branches = {\n            prefixes: [],\n            leftBound: null,\n            union: null,\n            intersection: null\n        };\n    }\n    previousOperator() {\n        return (this.branches.leftBound?.comparator ??\n            this.branches.prefixes.at(-1) ??\n            (this.branches.intersection ? \"&\"\n                : this.branches.union ? \"|\"\n                    : undefined));\n    }\n    shiftedByOne() {\n        this.scanner.shift();\n        return this;\n    }\n}\n", "import { ArkErrors, BaseRoot } from \"@arktype/schema\";\nimport { Callable } from \"@arktype/util\";\nimport { Generic } from \"./generic.js\";\nimport { parseGenericParams } from \"./parser/generic.js\";\nconst typeParserAttachments = Object.freeze({\n    errors: ArkErrors\n});\nexport class RawTypeParser extends Callable {\n    constructor($) {\n        super((...args) => {\n            if (args.length === 1) {\n                // treat as a simple definition\n                return $.parseRoot(args[0]);\n            }\n            if (args.length === 2 &&\n                typeof args[0] === \"string\" &&\n                args[0][0] === \"<\" &&\n                args[0].at(-1) === \">\") {\n                // if there are exactly two args, the first of which looks like <${string}>,\n                // treat as a generic\n                const params = parseGenericParams(args[0].slice(1, -1));\n                const def = args[1];\n                // TODO: validateUninstantiatedGeneric, remove this cast\n                return new Generic(params, def, $);\n            }\n            // otherwise, treat as a tuple expression. technically, this also allows\n            // non-expression tuple definitions to be parsed, but it's not a supported\n            // part of the API as specified by the associated types\n            return $.parseRoot(args);\n        }, { bind: $, attach: typeParserAttachments });\n    }\n}\nexport const Type = BaseRoot;\n", "import { RawRootScope, hasArkKind } from \"@arktype/schema\";\nimport { domainOf, hasDomain, isThunk, throwParseError } from \"@arktype/util\";\nimport { Generic } from \"./generic.js\";\nimport { createMatchParser } from \"./match.js\";\nimport { parseObject, writeBadDefinitionTypeMessage } from \"./parser/definition.js\";\nimport { parseGenericParams } from \"./parser/generic.js\";\nimport { DynamicState } from \"./parser/string/reduce/dynamic.js\";\nimport { fullStringParse } from \"./parser/string/string.js\";\nimport { RawTypeParser } from \"./type.js\";\nexport const scope = ((def, config = {}) => new RawScope(def, config));\nexport class RawScope extends RawRootScope {\n    parseCache = {};\n    constructor(def, config) {\n        const aliases = {};\n        for (const k in def) {\n            const parsedKey = parseScopeKey(k);\n            aliases[parsedKey.name] =\n                parsedKey.params.length ?\n                    // TODO: this\n                    new Generic(parsedKey.params, def[k], {})\n                    : def[k];\n        }\n        super(aliases, config);\n    }\n    type = new RawTypeParser(this);\n    match = createMatchParser(this);\n    declare = (() => ({\n        type: this.type\n    })).bind(this);\n    define = ((def) => def).bind(this);\n    preparseRoot(def) {\n        if (isThunk(def) && !hasArkKind(def, \"generic\"))\n            return def();\n        return def;\n    }\n    parseRoot(def) {\n        // args: { this: {} as RawRoot },\n        return this.parse(def, {\n            $: this,\n            args: {}\n            // type parsing can bypass nodes if it hits the cache,\n            // so bind it directly (could be optimized)\n        }).bindScope(this);\n    }\n    parse(def, ctx) {\n        if (typeof def === \"string\") {\n            if (ctx.args && Object.keys(ctx.args).every(k => !def.includes(k))) {\n                // we can only rely on the cache if there are no contextual\n                // resolutions like \"this\" or generic args\n                return this.parseString(def, ctx);\n            }\n            if (!this.parseCache[def])\n                this.parseCache[def] = this.parseString(def, ctx);\n            return this.parseCache[def];\n        }\n        return hasDomain(def, \"object\") ?\n            parseObject(def, ctx)\n            : throwParseError(writeBadDefinitionTypeMessage(domainOf(def)));\n    }\n    parseString(def, ctx) {\n        return (this.maybeResolveRoot(def) ??\n            ((def.endsWith(\"[]\") &&\n                this.maybeResolveRoot(def.slice(0, -2))?.array()) ||\n                fullStringParse(new DynamicState(def, ctx))));\n    }\n}\nexport const writeShallowCycleErrorMessage = (name, seen) => `Alias '${name}' has a shallow resolution cycle: ${[...seen, name].join(\":\")}`;\nexport const parseScopeKey = (k) => {\n    const firstParamIndex = k.indexOf(\"<\");\n    if (firstParamIndex === -1) {\n        return {\n            name: k,\n            params: []\n        };\n    }\n    if (k.at(-1) !== \">\") {\n        throwParseError(`'>' must be the last character of a generic declaration in a scope`);\n    }\n    return {\n        name: k.slice(0, firstParamIndex),\n        params: parseGenericParams(k.slice(firstParamIndex + 1, -1))\n    };\n};\n", "import { keywordNodes } from \"@arktype/schema\";\nimport { RawScope, scope } from \"./scope.js\";\nexport const tsGenerics = {};\nexport const ambient = scope(keywordNodes);\nRawScope.ambient = ambient.raw;\nexport const ark = ambient.export();\nexport const type = ambient.type;\nexport const match = ambient.match;\nexport const define = ambient.define;\nexport const declare = ambient.declare;\n", "import { RootModule } from \"@arktype/schema\";\nexport const Module = RootModule;\n"],
  "mappings": ";;;;;AAgBO,IAAM,YAAY,CAAC,SAAU,MAAM,QAAQ,IAAI,IAAI,OAAO,CAAC,IAAI;AAC/D,IAAM,aAAa,CAAC,MAAM,OAAO;AACpC,QAAM,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC;AACtB,aAAW,QAAQ,MAAM;AACrB,QAAI,GAAG,IAAI;AACP,aAAO,CAAC,EAAE,KAAK,IAAI;AAAA;AAEnB,aAAO,CAAC,EAAE,KAAK,IAAI;AAAA,EAC3B;AACA,SAAO;AACX;AACO,IAAM,gBAAgB;AACtB,IAAM,WAAW,CAAC,OAAO,YAAY,MAAM,SAAS,OAAO;AAW3D,IAAM,SAAS,CAAC,IAAI,OAAO,SAAS;AACvC,MAAI,UAAU;AACV,WAAO,MAAM,CAAC;AAClB,MAAI,OAAO,QAAW;AAClB,WAAQ,UAAU,SAAY,CAAC,IACzB,MAAM,QAAQ,KAAK,IAAI,QACnB,CAAC,KAAK;AAAA,EACpB;AACA,MAAI,6BAAM;AACN,UAAM,QAAQ,KAAK,IAAI,GAAG,QAAQ,GAAG,KAAK,IAAI,GAAG,QAAQ,KAAK;AAAA;AAE9D,UAAM,QAAQ,KAAK,IAAI,GAAG,KAAK,GAAG,KAAK,IAAI,GAAG,KAAK,KAAK;AAC5D,SAAO;AACX;AA4BO,IAAM,eAAe,CAAC,IAAI,UAAU;AACvC,MAAI,OAAO;AACP,WAAO,CAAC,KAAK;AACjB,MAAI,CAAC,GAAG,SAAS,KAAK;AAClB,OAAG,KAAK,KAAK;AACjB,SAAO;AACX;AACO,IAAM,UAAU,CAAC,OAAO,iBAAiB,MAAM,OAAO,CAAC,QAAQ,SAAS;AAC3E,QAAM,MAAM,KAAK,YAAY;AAC7B,gCAAgB,CAAC;AACjB,SAAO,GAAG,EAAE,KAAK,IAAI;AACrB,SAAO;AACX,GAAG,CAAC,CAAC;;;AC5FE,IAAM,eAAe,CAAC,UAAU,OAAO,OAAO,OAAO,eAAe,KAAK,GAAG,OAAO,0BAA0B,KAAK,CAAC;;;ACAnH,IAAM,uBAAN,cAAmC,MAAM;AAChD;AACO,IAAM,qBAAqB,aAAW,WAAW,SAAS,oBAAoB;AAC9E,IAAM,aAAa,CAAC,SAAS,OAAO,UAAU;AACjD,QAAM,IAAI,KAAK,OAAO;AAC1B;AACO,IAAM,aAAN,cAAyB,MAAM;AAAA,EAA/B;AAAA;AACH,gCAAO;AAAA;AACX;AACO,IAAM,kBAAkB,aAAW,WAAW,SAAS,UAAU;;;ACRjE,SAAS,UAAU,GAAG,cAAc;AAD3C,MAAAA;AAEI,QAAM,eAAe,MAAM,QAAQ,CAAC;AACpC,QAAM,UAAU,OAAO,QAAQ,CAAC,EAAE,QAAQ,CAAC,OAAO,MAAM;AACpD,UAAM,SAAS,eAAe,aAAa,GAAG,MAAM,CAAC,CAAC,IAAI,aAAa,GAAG,OAAO,CAAC;AAClF,UAAM,WAAW,MAAM,QAAQ,OAAO,CAAC,CAAC,KAAK,OAAO,WAAW;AAAA;AAAA;AAAA,MAG3D;AAAA,QAGE,CAAC,MAAM;AACb,WAAO;AAAA,EACX,CAAC;AACD,QAAM,eAAe,OAAO,YAAY,OAAO;AAC/C,SAAO,SAAOA,MAAA,QAAQ,CAAC,MAAT,gBAAAA,IAAa,QAAO,WAC9B,OAAO,OAAO,YAAY,IACxB;AACV;;;ACjBO,IAAM,YAAY,CAAC,MAAM,OAAO,QAAQ,CAAC;AACzC,IAAM,cAAc,CAAC,YAAY,OAAO,YAAY,OAAO;AAE3D,IAAM,UAAU,CAAC,GAAG,MAAM,KAAK;AAI/B,IAAM,mBAAmB,MAAM;AAAA,EAClC,YAAY,YAAY;AACpB,WAAO,OAAO,MAAM,UAAU;AAAA,EAClC;AACJ;AAEO,IAAM,cAAN,cAA0B,iBAAiB;AAClD;AACO,IAAM,WAAW,MAAM;AAC9B;AAEO,IAAM,eAAN,cAA2B,SAAS;AAC3C;AACO,IAAM,cAAc,CAAC,GAAG,aAAa;AACxC,QAAM,IAAI,CAAC;AACX,QAAM,IAAI,CAAC;AACX,MAAI;AACJ,OAAK,KAAK,GAAG;AACT,QAAI,KAAK;AACL,QAAE,CAAC,IAAI,EAAE,CAAC;AAAA;AAEV,QAAE,CAAC,IAAI,EAAE,CAAC;AAAA,EAClB;AACA,SAAO,CAAC,GAAG,CAAC;AAChB;AACO,IAAM,OAAO,CAAC,GAAG,SAAS,YAAY,GAAG,IAAI,EAAE,CAAC;AAChD,IAAM,OAAO,CAAC,GAAG,SAAS,YAAY,GAAG,IAAI,EAAE,CAAC;AAChD,IAAM,gBAAgB,CAAC,MAAM,OAAO,KAAK,CAAC,EAAE,WAAW;AACvD,IAAM,6BAA6B,CAAC,MAAM;AAAA,EAC7C,GAAG,OAAO,QAAQ,CAAC;AAAA,EACnB,GAAG,OAAO,sBAAsB,CAAC,EAAE,IAAI,OAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;AACzD;AAEO,IAAM,mBAAmB,CAAC,MAAM;AAAA;AAAA,EAEvC,OAAO,iBAAiB,MAAM,OAAO,0BAA0B,MAAM,CAAC;AAAA;AAE/D,IAAM,QAAQ,OAAO,mCAAmC;;;AC3CxD,IAAM,QAAQ,CAAC,QAAQ,QAAQ;AAClC,MAAI,eAAe,WAAY;AAC3B,SAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,EAAE,KAAK,IAAI;AAAA,EAC7C,CAAC;AACL;AACO,IAAM,SAAS,CAAC,QAAQ,YAAY,WAAY;AACnD,QAAM,QAAQ,OAAO,KAAK,IAAI;AAC9B,SAAO,eAAe,MAAM,QAAQ,MAAM,QAAQ,SAAS,WACvD,EAAE,MAAM,IACN;AAAA,IACE,OAAO,MAAM;AAAA,IACb,YAAY;AAAA,EAChB,CAAC;AACL,SAAO;AACX;AACO,IAAM,cAAc,CAAC,UAAU;AAClC,MAAI,SAAS;AACb,SAAO,MAAO,WAAW,QAAS,SAAS,MAAM,IAAK;AAC1D;AACO,IAAM,UAAU,CAAC,UAAU,OAAO,UAAU,cAAc,MAAM,WAAW;AAS3E,IAAM,kBAAkB,cAAc,SAAS;AAAA,EAClD,eAAe,MAAM;AACjB,UAAM,SAAS,KAAK,MAAM,GAAG,EAAE;AAC/B,UAAM,OAAO,KAAK,GAAG,EAAE;AACvB,QAAI;AACA,YAAM,GAAG,QAAQ,IAAI;AAAA,IACzB,SACO,GAAG;AACN,aAAO,mBAAmB;AAAA,2BACX,CAAC;AAAA,2BACD,KAAK,MAAM,GAAG,EAAE,CAAC;AAAA,sBACtB,KAAK,GAAG,EAAE,CAAC;AAAA,kBACf;AAAA,IACV;AAAA,EACJ;AACJ;AAEO,IAAM,WAAN,cAAuB,SAAS;AAAA,EACnC,YAAY,GAAG,MAAM;AACjB,UAAM;AACN,WAAO,OAAO,OAAO,OAAO,eAAe,EAAE,MAAK,6BAAM,SAAQ,IAAI,GAAG,KAAK,YAAY,SAAS,GAAG,6BAAM,MAAM;AAAA,EACpH;AACJ;AAUO,IAAM,YAAY,YAAY,MAAM;AACvC,MAAI;AACA,WAAO,IAAI,SAAS,cAAc,EAAE;AAAA,EACxC,SACO,GAAG;AACN,WAAO;AAAA,EACX;AACJ,CAAC;;;ACrEM,IAAM,YAAY,CAAC,MAAM,SAAS,SAAS,IAAI,MAAM;AACrD,IAAM,WAAW,CAAC,SAAS;AAC9B,QAAM,cAAc,OAAO;AAC3B,SAAQ,gBAAgB,WACpB,SAAS,OACL,SACE,WACJ,gBAAgB,aAAa,WACzB;AACd;AACA,IAAM,+BAA+B;AAAA,EACjC,SAAS;AAAA,EACT,MAAM;AAAA,EACN,WAAW;AACf;AACA,IAAM,kCAAkC;AAAA,EACpC,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AACZ;AAEO,IAAM,qBAAqB;AAAA,EAC9B,GAAG;AAAA,EACH,GAAG;AACP;;;ACtBO,IAAM,sBAAsB;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACO,IAAM,eAAe,CAAC,SAAS;AAnBtC,MAAAC;AAoBI,MAAI,YAAY,OAAO,eAAe,IAAI;AAC1C,UAAO,uCAAW,iBACb,CAAC,QAAQ,UAAU,YAAY,MAAM,mBAAmB,KACrD,EAAE,gBAAgB,oBAAoB,UAAU,YAAY,IAAI;AACpE,gBAAY,OAAO,eAAe,SAAS;AAC/C,QAAM,QAAOA,MAAA,uCAAW,gBAAX,gBAAAA,IAAwB;AACrC,MAAI,SAAS,UAAa,SAAS;AAC/B,WAAO;AACX,SAAO;AACX;AACO,IAAM,uBAAuB,CAAC,SAAU,OAAO,SAAS,YAAY,SAAS,OAChF,aAAa,IAAI,KAAK,WACpB,SAAS,IAAI;AAEZ,IAAM,UAAU,CAAC,SAAS,MAAM,QAAQ,IAAI;AAE5C,IAAM,yBAAyB;AAAA,EAClC,OAAO;AAAA,EACP,UAAU;AAAA,EACV,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,KAAK;AAAA,EACL,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AACb;AAGO,IAAM,iCAAiC,CAAC,SAAS;AACpD,QAAM,kBAAkB,OAAO,IAAI,EAAE,QAAQ;AAC7C,SAAQ,mBACJ,QAAQ,iBAAiB,mBAAmB,KAC5C,oBAAoB,eAAe,MAAM,OACzC,kBACE;AACV;AAiBO,IAAM,kBAAkB,CAAC,UAAU;AACtC,QAAM,SAAS,CAAC;AAChB,MAAI,OAAO;AACX,SAAO,SAAS,OAAO,aAAa,SAAS,QAAQ,SAAS,QAAW;AACrE,eAAW,KAAK,OAAO,oBAAoB,IAAI;AAC3C,UAAI,MAAM,iBAAiB,CAAC,OAAO,SAAS,CAAC;AACzC,eAAO,KAAK,CAAC;AACrB,eAAW,UAAU,OAAO,sBAAsB,IAAI;AAClD,UAAI,CAAC,OAAO,SAAS,MAAM;AACvB,eAAO,KAAK,MAAM;AAC1B,WAAO,OAAO,eAAe,IAAI;AAAA,EACrC;AACA,SAAO;AACX;AACA,IAAM,mBAAmB;AAAA,EACrB,QAAQ,gBAAgB,EAAE;AAAA,EAC1B,SAAS,gBAAgB,KAAK;AAAA,EAC9B,MAAM,CAAC;AAAA,EACP,QAAQ,gBAAgB,CAAC;AAAA;AAAA,EAEzB,QAAQ,CAAC;AAAA,EACT,QAAQ,gBAAgB,EAAE;AAAA,EAC1B,QAAQ,gBAAgB,OAAO,CAAC;AAAA,EAChC,WAAW,CAAC;AAChB;AACO,IAAM,oBAAoB,CAAC,WAAW,CAAC,GAAG,iBAAiB,MAAM,CAAC;AAClE,IAAM,qBAAqB,CAAC,MAAM,SAAS;AAC9C,MAAI,UAAU,KAAK;AACnB,SAAO,YAAY,MAAM;AACrB,QAAI,YAAY,KAAK;AACjB,aAAO;AACX,cAAU,OAAO,eAAe,OAAO;AAAA,EAC3C;AACA,SAAO;AACX;;;AC/GO,IAAM,qBAAqB,CAAC,UAAW,OAAO,UAAU,WAAW,KAAK,UAAU,KAAK,IACxF,OAAO,UAAU,WAAW,GAAG,KAAK,MAChC,GAAG,KAAK;;;ACElB,IAAI,UAAU,YAAY;AACtB,aAAW;AAAA;AAAA;AAAA,qEAGsD;AACrE;AACO,IAAM,WAAW,CAAC;AACzB,WAAW,OAAO;AAClB,IAAM,oBAAoB,oBAAI,QAAQ;AACtC,IAAM,aAAa,CAAC;AACb,IAAM,WAAW,CAAC,UAAU;AAC/B,QAAM,eAAe,kBAAkB,IAAI,KAAK;AAChD,MAAI;AACA,WAAO;AACX,MAAI,OAAO,YAAY,KAAK;AAC5B,MAAI,WAAW,IAAI;AACf,WAAO,GAAG,IAAI,GAAG,WAAW,IAAI,GAAG;AAAA;AAEnC,eAAW,IAAI,IAAI;AACvB,WAAS,IAAI,IAAI;AACjB,oBAAkB,IAAI,OAAO,IAAI;AACjC,SAAO;AACX;AACO,IAAM,YAAY,CAAC,SAAS,QAAQ,IAAI;AACxC,IAAM,sBAAsB,CAAC,UAAU,UAAU,SAAS,KAAK,CAAC;AAChE,IAAM,kBAAkB,CAAC,YAAY,6BAA6B,KAAK,OAAO;AAC9E,IAAM,yBAAyB,CAAC,UAAU,UAAU,OAAO,QAAQ,KAAK,OAAO,UAAU,WAC5F,oBAAoB,KAAK,IACvB,mBAAmB,KAAK;AAC9B,IAAM,cAAc,CAAC,UAAU;AAC3B,UAAQ,OAAO,OAAO;AAAA,IAClB,KAAK,UAAU;AACX,UAAI,UAAU;AACV;AACJ,YAAM,SAAS,aAAa,KAAK,KAAK;AAEtC,aAAO,OAAO,CAAC,EAAE,YAAY,IAAI,OAAO,MAAM,CAAC;AAAA,IACnD;AAAA,IACA,KAAK;AACD,aAAO,gBAAgB,MAAM,IAAI,IAAI,MAAM,OAAO;AAAA,IACtD,KAAK;AACD,aAAO,MAAM,eAAe,gBAAgB,MAAM,WAAW,IACzD,MAAM,cACJ;AAAA,EACd;AACA,SAAO,mBAAmB,6DAA6D,SAAS,KAAK,CAAC,EAAE;AAC5G;;;AC/CO,IAAM,mBAAN,cAA+B,aAAa;AAAA,EAG/C,eAAe,MAAM;AACjB,UAAM;AAHV;AACA,gCAAO;AAYP,uCAAc;AATV,SAAK,WAAW;AAChB,eAAW,OAAO,MAAM;AACpB,UAAI,OAAO,MAAM;AACb,cAAM,IAAI,MAAM,aAAa,GAAG,wDAAwD;AAAA,MAC5F;AACA;AACA,WAAK,GAAG,IAAI;AAAA,IAChB;AAAA,EACJ;AAAA,EAEA,SAAS;AACL,SAAK,eAAe;AACpB,WAAO;AAAA,EACX;AAAA,EACA,SAAS;AACL,SAAK,eAAe;AACpB,WAAO;AAAA,EACX;AAAA,EACA,KAAK,KAAK,WAAW,OAAO;AACxB,WAAO,yBAAyB,KAAK,QAAQ;AAAA,EACjD;AAAA,EACA,MAAM,KAAK,WAAW,OAAO;AACzB,WAAO,gBAAgB,GAAG,GAAG,IAAI,QAAQ;AAAA,EAC7C;AAAA,EACA,KAAK,WAAW;AACZ;AACA,SAAK,QAAQ,GAAG,IAAI,OAAO,KAAK,WAAW,CAAC,GAAG,SAAS;AAAA;AACxD,WAAO;AAAA,EACX;AAAA,EACA,MAAM,YAAY,YAAY;AAC1B,SAAK,KAAK,SAAS,UAAU,MAAM,UAAU,EAAE;AAC/C,WAAO;AAAA,EACX;AAAA,EACA,IAAI,YAAY,YAAY;AACxB,WAAO,KAAK,KAAK,OAAO,UAAU,MAAM,UAAU,EAAE;AAAA,EACxD;AAAA,EACA,IAAI,YAAY,YAAY;AACxB,WAAO,KAAK,KAAK,GAAG,UAAU,MAAM,UAAU,EAAE;AAAA,EACpD;AAAA,EACA,GAAG,WAAW,MAAM;AAChB,WAAO,KAAK,MAAM,OAAO,SAAS,KAAK,IAAI;AAAA,EAC/C;AAAA,EACA,OAAO,WAAW,MAAM;AACpB,WAAO,KAAK,MAAM,YAAY,SAAS,KAAK,IAAI;AAAA,EACpD;AAAA,EACA,KAAK,MAAM;AACP,WAAO,KAAK,MAAM,QAAQ,IAAI;AAAA,EAClC;AAAA;AAAA,EAEA,IAAI,OAAO,MAAM,eAAe,GAAG;AAC/B,WAAO,KAAK,MAAM,gBAAgB,YAAY,KAAK,KAAK,UAAU,IAAI;AAAA,EAC1E;AAAA;AAAA,EAEA,MAAM,QAAQ,MAAM;AAChB,WAAO,KAAK,MAAM,mBAAmB,MAAM,KAAK,IAAI;AAAA,EACxD;AAAA,EACA,MAAM,QAAQ,UAAU,SAAS,IAAI;AACjC,SAAK,KAAK,GAAG,MAAM,IAAI;AACvB,SAAK,OAAO;AACZ,aAAS,IAAI;AACb,SAAK,OAAO;AACZ,WAAO,KAAK,KAAK,IAAI,MAAM,EAAE;AAAA,EACjC;AAAA,EACA,OAAO,aAAa,IAAI;AACpB,WAAO,KAAK,KAAK,UAAU,UAAU,EAAE;AAAA,EAC3C;AAAA,EACA,UAAU;AACN,WAAO,IAAI,gBAAgB,GAAG,KAAK,UAAU,KAAK,IAAI;AAAA,EAC1D;AACJ;AACO,IAAM,2BAA2B,CAAC,KAAK,WAAW,UAAU;AAC/D,MAAI,OAAO,QAAQ,YAAY,gBAAgB,GAAG;AAC9C,WAAO,GAAG,WAAW,MAAM,EAAE,IAAI,GAAG;AACxC,SAAO,gBAAgB,oBAAoB,GAAG,GAAG,QAAQ;AAC7D;AACO,IAAM,sBAAsB,CAAC,QAAQ,OAAO,QAAQ,WAAW,oBAAoB,GAAG,IAAI,KAAK,UAAU,GAAG;AAC5G,IAAM,kBAAkB,CAAC,KAAK,WAAW,UAAU,GAAG,WAAW,OAAO,EAAE,IAAI,GAAG;;;ACpFjF,IAAM,KAAK,OAAO,IAAI;;;ACCtB,IAAI;AAAA,CACV,SAAUC,MAAK;AAAA,EACZ,MAAM,KAAK;AAAA,EACX;AACA,EAAAA,KAAI,OAAO;AAAA,EACX,MAAM,aAAa;AAAA,EACnB;AACA,EAAAA,KAAI,eAAe;AACnB,EAAAA,KAAI,QAAQ,CAAC,QAAQ,IAAI;AAAA,EACzB,MAAM,UAAU;AAAA,EAChB;AACA,EAAAA,KAAI,YAAY;AAChB,EAAAA,KAAI,OAAO,IAAI,UAAU,QAAM,MAAM,OAAO,CAAC,KAAK,SAAS,KAAK,IAAI,GAAG,GAAG,EAAE;AAChF,GAAG,QAAQ,MAAM,CAAC,EAAE;;;ACEb,IAAM,0BAA0B;AAChC,IAAM,qBAAqB,wBAAwB,KAAK,KAAK,uBAAuB;AAC3F,IAAM,oBAAoB;AAC1B,IAAM,eAAe,CAAC,MAAM,EAAE,WAAW,KAAK,kBAAkB,KAAK,CAAC;AAM/D,IAAM,2BAA2B;AACjC,IAAM,sBAAsB,yBAAyB,KAAK,KAAK,wBAAwB;AAC9F,IAAM,qBAAqB;AAC3B,IAAM,gBAAgB,mBAAmB,KAAK,KAAK,kBAAkB;AACrE,IAAM,6BAA6B;AAAA,EAC/B,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,SAAS;AACb;AACO,IAAM,sCAAsC,CAAC,KAAK,SAAS,IAAI,GAAG,mBAAmB,2BAA2B,IAAI,CAAC;AAC5H,IAAM,eAAe,CAAC,KAAK,SAAS,SAAS,WAAW,mBAAmB,GAAG,IAAI,oBAAoB,GAAG;AACzG,IAAM,YAAY,CAAC,KAAK,SAAS,SAAS,WAAW,OAAO,GAAG,IAAI,OAAO,SAAS,GAAG;AACtF,IAAM,aAAa,CAAC,KAAK,SAAS,SAAS,WAAW,aAAa,GAAG,IAAI,cAAc,GAAG;AACpF,IAAM,iBAAiB,CAAC,OAAO,YAAY,aAAa,OAAO,UAAU,OAAO;AAChF,IAAM,kBAAkB,CAAC,OAAO,YAAY,aAAa,OAAO,WAAW,OAAO;AACzF,IAAM,eAAe,CAAC,OAAO,MAAM,YAAY;AAC3C,QAAM,QAAQ,UAAU,OAAO,IAAI;AACnC,MAAI,CAAC,OAAO,MAAM,KAAK,GAAG;AACtB,QAAI,WAAW,OAAO,IAAI,GAAG;AACzB,UAAI,mCAAS,QAAQ;AACjB,eAAO,aAAa,OAAO,IAAI,IAAI,QAAS,gBAAgB,oCAAoC,OAAO,IAAI,CAAC;AAAA,MAChH;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AACA,UAAQ,mCAAS,eACb,iBAAgB,mCAAS,iBAAgB,OACrC,mBAAmB,2BAA2B,IAAI,CAAC,UAAU,KAAK,MAChE,mCAAS,WAAW,IACxB;AACV;AACO,IAAM,2BAA2B,CAAC,QAAQ;AAC7C,MAAI,IAAI,IAAI,SAAS,CAAC,MAAM;AACxB;AACJ,QAAM,sBAAsB,IAAI,MAAM,GAAG,EAAE;AAC3C,MAAI;AACJ,MAAI;AACA,YAAQ,OAAO,mBAAmB;AAAA,EACtC,QACM;AACF;AAAA,EACJ;AACA,MAAI,yBAAyB,KAAK,mBAAmB;AACjD,WAAO;AACX,MAAI,mBAAmB,KAAK,mBAAmB,GAAG;AAG9C,WAAO,gBAAgB,oCAAoC,KAAK,QAAQ,CAAC;AAAA,EAC7E;AACJ;;;ACrEO,IAAM,YAAY,CAAC,MAAM,WAAW;AACvC,UAAQ,SAAS,IAAI,GAAG;AAAA,IACpB,KAAK;AACD,aAAO,gBAAgB,OACnB,KAAK,aAAa,IAChB,KAAK,UAAU,WAAW,MAAM,eAAe,CAAC,CAAC,GAAG,MAAM,MAAM;AAAA,IAC1E,KAAK;AACD,aAAO,cAAc,SAAS,IAAI;AAAA,IACtC;AACI,aAAO,mBAAmB,IAAI;AAAA,EACtC;AACJ;AACA,IAAM,gBAAgB;AAAA,EAClB,SAAS,MAAM;AAAA,EACf,UAAU,OAAK,UAAU,SAAS,CAAC,CAAC;AAAA,EACpC,YAAY,OAAK,YAAY,SAAS,CAAC,CAAC;AAC5C;AACA,IAAM,aAAa,CAAC,MAAM,MAAM,SAAS;AACrC,UAAQ,SAAS,IAAI,GAAG;AAAA,IACpB,KAAK,UAAU;AACX,UAAI,OAAO,SAAS;AAChB,eAAO,cAAc,WAAW,IAAI;AACxC,UAAI,KAAK,SAAS,IAAI;AAClB,eAAO;AACX,YAAM,WAAW,CAAC,GAAG,MAAM,IAAI;AAC/B,UAAI,MAAM,QAAQ,IAAI;AAClB,eAAO,KAAK,IAAI,UAAQ,WAAW,MAAM,MAAM,QAAQ,CAAC;AAC5D,UAAI,gBAAgB;AAChB,eAAO,KAAK,aAAa;AAC7B,YAAM,SAAS,CAAC;AAChB,iBAAW,KAAK;AACZ,eAAO,CAAC,IAAI,WAAW,KAAK,CAAC,GAAG,MAAM,QAAQ;AAClD,aAAO;AAAA,IACX;AAAA,IACA,KAAK;AACD,aAAO,cAAc,SAAS,IAAI;AAAA,IACtC,KAAK;AACD,aAAO,GAAG,IAAI;AAAA,IAClB,KAAK;AACD,aAAO,KAAK,eAAe;AAAA,IAC/B;AACI,aAAO;AAAA,EACf;AACJ;;;AChDO,IAAM,aAAa,CAAC,MAAO,EAAE,CAAC,EAAE,YAAY,IAAI,EAAE,MAAM,CAAC;;;ACKhE,IAAM,oBAAoB,OAAO,mBAAmB;;;ACJ7C,IAAM,oCAAoC,CAAC;AAAA;AAAA;AAAA,EAGlD,UAAU,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AAAA;AAC5C,IAAM,mBAAmB,CAAC,SAAS;AACtC,QAAM,kBAAkB,KAAK,OAAO,CAAC,GAAG,MAAM,OAAO,MAAM,YAAY,gBAAgB,CAAC,IACpF,GAAG,CAAC,IAAI,CAAC,KACP,GAAG,CAAC,IAAI,UAAU,CAAC,CAAC,KAAK,EAAE;AACjC,SAAO,gBAAgB,CAAC,MAAM,MAAM,gBAAgB,MAAM,CAAC,IAAI;AACnE;AACO,IAAM,UAAU,OAAO,qBAAqB;AAC5C,IAAM,aAAa,CAAC,OAAO,UAAS,+BAAQ,cAAa;AACzD,IAAM,SAAS,CAAC,UAAU,WAAW,OAAO,MAAM,KAAK,WAAW,OAAO,YAAY;AAIrF,IAAM,WAAW,OAAO,UAAU;;;ACflC,IAAM,aAAa,CAAC,QAAQ,SAAS,QAAQ;AAC7C,IAAM,kBAAkB;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACO,IAAM,kBAAkB;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACO,IAAM,kBAAkB;AAAA,EAC3B,GAAG;AAAA,EACH,GAAG;AAAA,EACH;AAAA,EACA;AACJ;AACO,IAAM,YAAY;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACO,IAAM,YAAY,CAAC,GAAG,WAAW,GAAG,eAAe;AACnD,IAAM,iBAAiB,UAAU,iBAAiB,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC;AACxE,IAAM,gBAAgB,UAAU,CAAC,GAAG,iBAAiB,YAAY,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;AACpF,IAAM,mBAAmB,UAAU,WAAW,CAAC,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC;AACpE,IAAM,aAAa,CAAC,UAAU,OAAO,UAAU,YAAY,SAAS;AAOpE,IAAM,mBAAmB,CAAC,SAAS,iBAAiB,IAAI;AACxD,IAAM,qBAAqB,CAAC,SAAS,UAAU,MAAM,iBAAiB,IAAI,IAAI,CAAC;AAC/E,IAAM,yBAAyB,CAAC,MAAM;AACzC,MAAI,OAAO,MAAM,YACb,OAAO,MAAM,aACb,OAAO,MAAM,YACb,MAAM;AACN,WAAO;AACX,SAAO,uBAAuB,CAAC;AACnC;AACO,IAAM,sBAAsB,CAAC,QAAQ;AACxC,MAAI,SAAS;AACb,aAAW,CAAC,GAAG,CAAC,KAAK,OAAO,QAAQ,GAAG;AACnC,cAAU,GAAG,CAAC,KAAK,uBAAuB,CAAC,CAAC;AAChD,SAAO,SAAS;AACpB;AACO,IAAM,WAAW;AAAA,EACpB,aAAa,EAAE,MAAM,KAAK;AAC9B;AACO,IAAM,gBAAgB,CAAC,MAAM;AAjEpC,MAAAC,KAAAC,KAAA;AAkEI,QAAM,iBAAiB;AACvB,MAAI,eAAe,oBAAoB;AACnC,KAAAD,MAAA,eAAe,UAAS,aAAxBA,IAAwB,WAAa,SAAO,iBAAiB,MACzD,IAAI,cACF,eAAe,SAAS,YAAY,GAAG;AAC7C,KAAAC,MAAA,eAAe,UAAS,WAAxBA,IAAwB,SAAW,UAAQ,UAAU,IAAI;AACzD,yBAAe,UAAS,YAAxB,GAAwB,UAAY,SAAO,WAAW,IAAI,QAAQ,GAAG,IAAI,SAAS,SAAS,IAAI,MAAM,MAAM,EAAE;AAC7G,yBAAe,UAAS,YAAxB,GAAwB,UAAY,SAAO;AACvC,UAAI,IAAI,KAAK,WAAW;AACpB,eAAO,IAAI;AACf,YAAM,sBAAsB,GAAG,IAAI,UAAU,IAAI,IAAI,OAAO;AAC5D,UAAI,oBAAoB,CAAC,MAAM,KAAK;AAEhC,eAAO,YAAY,mBAAmB;AAAA,MAC1C;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO,OAAO,eAAe,MAAM,QAAQ;AAC3C,SAAO;AACX;;;ACrFO,IAAM,eAAe,CAAC;AACtB,IAAM,eAAe,CAAC,MAAM,eAAe;AAC9C,QAAM,SAAS,EAAE,GAAG,KAAK;AACzB,MAAI;AACJ,OAAK,KAAK,YAAY;AAClB,WAAO,CAAC,IACJ,WAAW,CAAC,IACR;AAAA,MACI,GAAG,KAAK,CAAC;AAAA,MACT,GAAG,WAAW,CAAC;AAAA,IACnB,IACE,WAAW,CAAC;AAAA,EAC1B;AACA,SAAO;AACX;;;ACfA;AAEO,IAAM,WAAN,eAAuB,mBAEzB,cAFyB,IAAa;AAAA,EAMvC,YAAY,OAAO,KAAK;AACpB,UAAM;AANV;AACA,wBAAC,IAAW;AACZ;AACA;AACA;AAGI,SAAK,QAAQ;AACb,qBAAiB,MAAM,KAAK;AAC5B,UAAM,OAAO,IAAI;AACjB,QAAI,MAAM,SAAS,SAAS;AAExB,YAAM,SAAS,MAAM,OAAO,QAAQ,OAAK,EAAE,QAAQ,OAAO,IAAI,EAAE,SAAS,CAAC;AAAA,IAC9E;AACA,SAAK,aAAa,IAAI,OAAO,KAAK,IAAI;AACtC,SAAK,OAAO,MAAM,QAAQ,CAAC,GAAG,IAAI,IAAI;AACtC,QAAI,MAAM;AACN,WAAK,KAAK,KAAK,GAAG,MAAM,YAAY;AACxC,SAAK,OAAO,UAAU,QAAQ,MAAM,OAAO;AAAA,EAC/C;AAAA,EACA,QAAQ,MAAM;AACV,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA,EACA,IAAI,aAAa;AACb,WAAO,iBAAiB,KAAK,IAAI;AAAA,EACrC;AAAA,EACA,IAAI,WAAW;AA7BnB,QAAAC,KAAAC;AA8BQ,WAAQ,KAAK,MAAM,cAAYA,OAAAD,MAAA,KAAK,YAAW,aAAhB,gBAAAC,IAAA,KAAAD,KAA2B,KAAK;AAAA,EACnE;AAAA,EACA,IAAI,SAAS;AAhCjB,QAAAA,KAAAC;AAmCQ,WAAO,KAAK,MAAM,WAAW,SACzB,KAAK,MAAM,UACTA,OAAAD,MAAA,KAAK,YAAW,WAAhB,gBAAAC,IAAA,KAAAD,KAAyB,KAAK;AAAA,EACxC;AAAA,EACA,IAAI,UAAU;AACV,WAAO,KAAK,MAAM,WAAW,KAAK,WAAW,QAAQ,IAAI;AAAA,EAC7D;AAAA,EACA,IAAI,UAAU;AACV,WAAO,KAAK,MAAM,WAAW,KAAK,WAAW,QAAQ,IAAI;AAAA,EAC7D;AAAA,EACA,WAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,QAAQ;AACJ,UAAM;AAAA,EACV;AACJ;AACO,IAAM,YAAN,cAAwB,cAAc;AAAA,EAEzC,YAAY,KAAK;AACb,UAAM;AAFV;AAKA,kCAAS,CAAC;AACV,iCAAQ;AACR,mCAAU;AAJN,SAAK,MAAM;AAAA,EACf;AAAA,EAIA,IAAI,OAAO;AACP,UAAM,WAAW,KAAK,OAAO,MAAM,UAAU;AAC7C,QAAI,UAAU;AACV,YAAM,oBAAoB,IAAI,SAAS;AAAA,QACnC,MAAM;AAAA,QACN,QAAQ,SAAS,QAAQ,cAAc,IACnC,CAAC,GAAG,SAAS,QAAQ,KAAK,IACxB,CAAC,UAAU,KAAK;AAAA,MAC1B,GAAG,KAAK,GAAG;AACX,YAAM,gBAAgB,KAAK,QAAQ,QAAQ;AAI3C,WAAK,QAAQ,kBAAkB,KAAK,KAAK,SAAS,aAAa,IAC3D;AACJ,WAAK,OAAO,MAAM,UAAU,IAAI;AAAA,IACpC,OACK;AACD,WAAK,OAAO,MAAM,UAAU,IAAI;AAChC,WAAK,QAAQ,KAAK,KAAK;AAAA,IAC3B;AACA,SAAK;AAAA,EACT;AAAA,EACA,IAAI,UAAU;AACV,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA,EACA,IAAI,UAAU;AACV,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA,EACA,WAAW;AACP,WAAO,KAAK,KAAK,IAAI;AAAA,EACzB;AAAA,EACA,QAAQ;AACJ,UAAM,IAAI,eAAe,MAAM,KAAK,OAAO;AAAA,EAC/C;AACJ;;;AC/FO,IAAM,mBAAN,MAAuB;AAAA,EAQ1B,YAAYE,OAAM,QAAQ;AAP1B;AACA;AACA,gCAAO,CAAC;AACR,wCAAe,CAAC;AAChB,kCAAS,IAAI,UAAU,IAAI;AAC3B,oCAAW,CAAC;AACZ,gCAAO,CAAC;AAEJ,SAAK,OAAOA;AACZ,SAAK,SAAS;AAAA,EAClB;AAAA,EACA,IAAI,gBAAgB;AAChB,WAAO,KAAK,SAAS,GAAG,EAAE;AAAA,EAC9B;AAAA,EACA,YAAY,QAAQ;AAhBxB,QAAAC;AAiBQ,UAAM,QAAQ;AAAA,MACV,MAAM,CAAC,GAAG,KAAK,IAAI;AAAA,MACnB;AAAA,IACJ;AACA,MAAAA,MAAA,KAAK,kBAAL,gBAAAA,IAAoB,aAAa,KAAK,WAClC,KAAK,aAAa,KAAK,KAAK;AAAA,EACpC;AAAA,EACA,WAAW;AACP,QAAI,KAAK,SAAS;AACd,aAAO,KAAK;AAIhB,WAAO,KAAK,aAAa,QAAQ;AAC7B,YAAM,EAAE,MAAM,OAAO,IAAI,KAAK,aAAa,MAAM;AACjD,YAAM,MAAM,KAAK,GAAG,EAAE;AACtB,UAAI;AACJ,UAAI,QAAQ,QAAW;AAEnB,iBAAS,KAAK;AACd,iBAAS,YAAY,GAAG,YAAY,KAAK,SAAS,GAAG;AACjD,mBAAS,OAAO,KAAK,SAAS,CAAC;AAAA,MACvC;AACA,WAAK,OAAO;AACZ,iBAAW,SAAS,QAAQ;AACxB,cAAM,SAAS,MAAM,WAAW,SAAY,KAAK,OAAO,OAAO,GAAG,GAAG,IAAI;AACzE,YAAI,kBAAkB;AAClB,iBAAO;AACX,YAAI,KAAK,SAAS;AACd,iBAAO,KAAK;AAChB,YAAI,kBAAkB,UAAU;AAG5B,eAAK,MAAM,MAAM;AACjB,iBAAO,KAAK;AAAA,QAChB;AAGA,YAAI,WAAW;AACX,eAAK,OAAO;AAAA;AAEZ,iBAAO,GAAG,IAAI;AAAA,MACtB;AAAA,IACJ;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,IAAI,oBAAoB;AACpB,WAAQ,KAAK,gBACT,KAAK,cAAc,QACf,IACE,IACJ,KAAK,OAAO;AAAA,EACtB;AAAA,EACA,WAAW;AACP,WAAO,KAAK,sBAAsB;AAAA,EACtC;AAAA,EACA,IAAI,WAAW;AACX,WAAO,KAAK,SAAS,WAAW;AAAA,EACpC;AAAA,EACA,MAAM,OAAO;AACT,UAAM,SAAS,OAAO,UAAU,WAC5B,MAAM,OACF,QACE,EAAE,GAAG,OAAO,MAAM,YAAY,IAClC,EAAE,MAAM,aAAa,UAAU,MAAM;AAC3C,UAAM,QAAQ,IAAI,SAAS,QAAQ,IAAI;AACvC,QAAI,KAAK;AACL,WAAK,cAAc,QAAQ;AAAA;AAE3B,WAAK,OAAO,IAAI,KAAK;AACzB,WAAO;AAAA,EACX;AAAA,EACA,IAAI,OAAO;AACP,QAAI,SAAS,KAAK;AAClB,eAAW,WAAW,KAAK;AACvB,eAAS,iCAAS;AACtB,WAAO;AAAA,EACX;AAAA,EACA,QAAQ,OAAO;AACX,SAAK,MAAM,KAAK;AAChB,WAAO;AAAA,EACX;AAAA,EACA,aAAa;AACT,SAAK,SAAS,KAAK;AAAA,MACf,OAAO;AAAA,MACP,cAAc,CAAC;AAAA,IACnB,CAAC;AAAA,EACL;AAAA,EACA,YAAY;AACR,WAAO,KAAK,SAAS,IAAI;AAAA,EAC7B;AACJ;;;ACzGO,IAAM,WAAN,cAAuB,SAAS;AAAA,EAEnC,YAAY,aAAa;AACrB;AAAA;AAAA;AAAA,MAGA,CAAC,MAAM,iBAAiB;AACpB,YAAI,CAAC,KAAK,iBACN,CAAC,KAAK,yBACN,KAAK,OAAO,IAAI;AAChB,iBAAO;AACX,YAAI,cAAc;AACd,eAAK,cAAc,MAAM,YAAY;AACrC,iBAAO,aAAa;AAAA,QACxB;AACA,cAAM,MAAM,IAAI,iBAAiB,MAAM,KAAK,EAAE,cAAc;AAC5D,aAAK,cAAc,MAAM,GAAG;AAC5B,eAAO,IAAI,SAAS;AAAA,MACxB;AAAA,MAAG,EAAE,QAAQ,YAAY;AAAA,IAAC;AAjB9B;AAoBA,uCAAc,GAAG,KAAK,EAAE,EAAE,GAAG,KAAK,EAAE;AACpC,yCAAgB,KAAK,SAAS,WACzB,KAAK,QAAQ,UAAU,KAAK,KAAK,WAAW,KAC5C,KAAK,QAAQ,WAAW,KAAK,KAAK,eAAe,YAClD,KAAK,SAAS,KAAK,WAAS,MAAM,aAAa;AACnD;AAAA;AAAA;AAAA;AAAA,MAEC,KAAK,QAAQ,WAAW,KAAK,KAAK,MAAM,UAAU,WAAW,KAC1D,KAAK,SAAS,WACd,KAAK,SAAS,KAAK,WAAS,MAAM,qBAAqB;AAAA;AAC3D,0CAAiB,KAAK,SAAS,OAAO,CAAC,QAAQ,UAAU,OAAO,OAAO,QAAQ,MAAM,cAAc,GAAG,EAAE,CAAC,KAAK,EAAE,GAAG,KAAK,CAAC;AAIzH,sCAAa,iBAAiB,KAAK,IAAI;AACvC,+BAAM;AACN,kCAAS,CAAC,SAAS;AACf,UAAI,KAAK,uBAAuB;AAC5B,eAAO,KAAK,eAAe,MAAM,IAAI,iBAAiB,MAAM,KAAK,EAAE,cAAc,CAAC;AAAA,MACtF;AACA,aAAO,KAAK,eAAe,IAAI;AAAA,IACnC;AAOA;AAAA;AAAA;AAAA;AAKA;AAKA;AAxCI,SAAK,cAAc;AAAA,EACvB;AAAA,EAYA,IAAI,aAAa;AACb,WAAO,OAAO,OAAO,KAAK,cAAc;AAAA,EAC5C;AAAA,EASA,SAAS,MAAM;AACX,WAAO,KAAK,IAAI;AAAA,EACpB;AAAA,EAKA,IAAI,KAAK;AACL,SAAK,QAAL,KAAK,MAAQ,KAAK,MAAM,IAAI;AAC5B,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,MAAM;AACN,SAAK,SAAL,KAAK,OAAS,KAAK,MAAM,KAAK;AAC9B,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,cAAc;AA/DtB,QAAAC,KAAAC;AAgEQ,SAAK,iBAAL,KAAK,eACD,KAAK,MAAM,iBACPA,OAAAD,MAAA,KAAK,EAAE,eAAe,KAAK,IAAI,GAAE,gBAAjC,gBAAAC,IAAA,KAAAD,KAA+C;AACvD,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,MAAM,MAAM;AACR,QAAI,CAAC,KAAK;AACN,aAAO;AACX,UAAM,UAAU,CAAC;AACjB,eAAW,CAAC,GAAG,CAAC,KAAK,KAAK,SAAS;AAC/B,YAAM,0BAA0B,KAAK,KAAK,KAAK,CAAC;AAChD,UAAI,wBAAwB;AACxB;AACJ,UAAI,wBAAwB,OAAO;AAC/B,cAAM,aAAa;AACnB,gBAAQ,CAAC,IACL,QAAQ,UAAU,IACd,WAAW,IAAI,WAAS,MAAM,IAAI,CAAC,IACjC,WAAW,IAAI;AAAA,MAC7B;AAEI,gBAAQ,CAAC,IAAI;AAAA,IACrB;AACA,WAAO,KAAK,EAAE,KAAK,KAAK,MAAM,OAAO;AAAA,EACzC;AAAA,EACA,SAAS;AACL,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,WAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,OAAO,OAAO;AACV,WAAO,KAAK,aAAa,MAAM;AAAA,EACnC;AAAA,EACA,cAAc,MAAM;AAChB,QAAI,CAAC,KAAK,SAAS;AACf,iBAAW,GAAG,KAAK,IAAI,kCAAkC,IAAI,EAAE;AACnE,WAAO;AAAA,EACX;AAAA,EACA,QAAQ,MAAM;AACV,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA,EACA,UAAU;AACN,WAAO,SAAS,YAAY,KAAK,IAAI;AAAA,EACzC;AAAA,EACA,eAAe;AACX,WAAO,SAAS,iBAAiB,KAAK,IAAI;AAAA,EAC9C;AAAA,EACA,eAAe;AACX,WAAO,SAAS,iBAAiB,KAAK,IAAI;AAAA,EAC9C;AAAA,EACA,SAAS;AACL,WAAO,SAAS,WAAW,KAAK,IAAI;AAAA,EACxC;AAAA,EACA,QAAQ,OAAO;AACX,WAAO,KAAK,QAAQ,MAAM,KAAK,KAAK,OAAO,KAAK;AAAA,EACpD;AAAA,EACA,sBAAsB;AAClB,WAAO,KAAK,KAAK;AAAA,EACrB;AAAA,EACA,IAAI,qBAAqB;AACrB,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,UAAU,GAAG;AACT,QAAI,KAAK,MAAM;AACX,aAAO;AACX,WAAO,IAAI,KAAK,YAAY,OAAO,OAAO,aAAa,KAAK,WAAW,GAAG,EAAE,EAAE,CAAC,CAAC;AAAA,EACpF;AAAA,EACA,eAAe,QAAQ;AACnB,WAAO,KAAK,WAAW,KAAK,OAAK,MAAM,QAAQ,OAAO,CAAC,CAAC;AAAA,EAC5D;AAAA,EACA,sBAAsB,QAAQ;AAC1B,WAAQ,KAAK,eAAe,MAAM,KAC9B,WAAW,GAAG,KAAK,EAAE,yCAAyC,MAAM,EAAE;AAAA,EAC9E;AAAA,EACA,qBAAqB,MAAM;AACvB,WAAO,KAAK,eAAe,CAACE,UAASA,MAAK,SAAS,IAAI;AAAA,EAC3D;AAAA,EACA,4BAA4B,MAAM;AAC9B,WAAQ,KAAK,eAAe,CAAAA,UAAQA,MAAK,SAAS,IAAI,KAClD,WAAW,GAAG,KAAK,EAAE,WAAW,IAAI,aAAa;AAAA,EACzD;AAAA,EACA,UAAU,QAAQ,MAAM;AACpB,WAAO,KAAK,WAAW,QAAQ;AAAA,MAC3B,MAAM,CAAC;AAAA,MACP,MAAM,CAAC;AAAA,MACP,kBAAiB,6BAAM,qBAAoB,MAAM;AAAA,IACrD,CAAC;AAAA,EACL;AAAA,EACA,WAAW,QAAQ,KAAK;AACpB,QAAI,IAAI,KAAK,KAAK,EAAE;AAIhB,aAAO,KAAK,EAAE,cAAc,IAAI,KAAK,KAAK,EAAE,CAAC;AACjD,QAAI,CAAC,IAAI,gBAAgB,MAAM,GAAG;AAC9B,aAAO;AACX,QAAI;AACJ,QAAI,KAAK,KAAK,EAAE,IAAI,MAAM;AAC1B,UAAM,+BAA+B,UAAU,KAAK,OAAO,CAAC,GAAG,MAAM;AACjE,UAAI,CAAC,KAAK,KAAK,KAAK,CAAC,EAAE;AACnB,eAAO,CAAC,GAAG,CAAC;AAChB,YAAM,WAAW;AACjB,UAAI,CAAC,QAAQ,QAAQ,GAAG;AACpB,cAAMC,eAAc,SAAS,WAAW,QAAQ,GAAG;AACnD,eAAOA,eAAc,CAAC,GAAGA,YAAW,IAAI,CAAC;AAAA,MAC7C;AACA,YAAM,cAAc,SAAS,QAAQ,OAAK;AACtC,cAAM,mBAAmB,EAAE,WAAW,QAAQ,GAAG;AACjD,eAAO,oBAAoB,CAAC;AAAA,MAChC,CAAC;AACD,aAAO,YAAY,SAAS,CAAC,GAAG,WAAW,IAAI,CAAC;AAAA,IACpD,CAAC;AACD,WAAO,IAAI,KAAK,KAAK,EAAE;AACvB,UAAM,mBAAmB,OAAO,KAAK,MAAM,8BAA8B,GAAG;AAC5E,QAAI,qBAAqB;AACrB,aAAO;AAEX,QAAI,cAAc,gBAAgB;AAC9B,aAAO;AACX,SAAK,KAAK,SAAS,cACf,KAAK,SAAS,cACd,KAAK,SAAS,YACd,EAAE,WAAW;AACb,aAAO;AACX,QAAI,KAAK,SAAS,SAAS;AACvB;AACA,uBAAiB,OAAjB,iBAAiB,KAAO,KAAK,EAAE,SAC1B;AAAA,IACT;AACA,WAAQ,kBAAkB,KAAK,EAAE,KAAK,KAAK,MAAM,gBAAgB;AAAA,EACrE;AAAA,EACA,4BAA4B,qBAAqB;AAC7C,UAAM,SAAS,OAAO,wBAAwB,WAC1C,EAAE,aAAa,oBAAoB,IACjC;AACN,WAAO,KAAK,UAAU,CAAC,MAAM,WAAW,EAAE,GAAG,OAAO,GAAG,OAAO,IAAI;AAAA,MAC9D,iBAAiB,CAAAD,UAAQA,MAAK,SAAS;AAAA,IAC3C,CAAC;AAAA,EACL;AACJ;;;AC1MO,IAAM,WAAN,MAAM,UAAS;AAAA,EAElB,YAAY,SAAS;AADrB;AAEI,SAAK,UAAU;AAAA,EACnB;AAAA,EACA,QAAQ;AACJ,WAAO,IAAI,UAAS,KAAK,OAAO;AAAA,EACpC;AAAA,EACA,OAAO,KAAK,MAAM,GAAG,GAAG;AACpB,WAAO,IAAI,UAAS;AAAA,MAChB,MAAM;AAAA,QACF,CAAC,IAAI,GAAG;AAAA,UACJ;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,OAAO,YAAY,SAAS;AACxB,QAAI,CAAC,QAAQ,QAAQ;AACjB,aAAO,mBAAmB,yDAAyD;AAAA,IACvF;AACA,WAAO,IAAI,UAAS,EAAE,MAAM,YAAY,OAAO,EAAE,CAAC;AAAA,EACtD;AAAA,EACA,IAAI,OAAO;AACP,WAAO,UAAU,KAAK,OAAO,EAAE,QAAQ,CAAC,CAAC,MAAM,aAAa,MAAM,UAAU,aAAa,EAAE,IAAI,CAAC,CAAC,MAAM,QAAQ,OAAO;AAAA,MAClH;AAAA,MACA;AAAA,MACA;AAAA,IACJ,EAAE,CAAC;AAAA,EACP;AAAA,EACA,kBAAkB;AACd,UAAM,UAAU,KAAK;AACrB,QAAI,QAAQ,WAAW,GAAG;AACtB,YAAM,EAAE,MAAM,SAAS,IAAI,QAAQ,CAAC;AACpC,YAAM,aAAa,KAAK,MAAM,IAAI,EAAE,KAAK,GAAG;AAC5C,aAAO,eAAe,cAAc,OAAO,UAAU,EAAE,OAAO,gBAAgB,QAAQ,CAAC;AAAA,IAC3F;AACA,WAAO;AAAA,IAAiE,QACnE,IAAI,CAAC,EAAE,MAAM,SAAS,MAAM,GAAG,IAAI,KAAK,gBAAgB,QAAQ,CAAC,EAAE,EACnE,KAAK,MAAM,CAAC;AAAA,EACrB;AAAA,EACA,UAAU;AACN,WAAO,KAAK,KAAK,WAAW;AAAA,EAChC;AAAA,EACA,QAAQ;AACJ,WAAO,gBAAgB,KAAK,gBAAgB,CAAC;AAAA,EACjD;AAAA,EACA,SAAS;AACL,UAAM,kBAAkB,UAAU,KAAK,OAAO,EAAE,IAAI,CAAC,CAAC,MAAM,SAAS,MAAM;AAAA,MACvE;AAAA,MACA,UAAU,WAAW,CAAC,MAAM,aAAa;AAAA,QACrC;AAAA,QACA,EAAE,GAAG,SAAS,GAAG,GAAG,SAAS,EAAE;AAAA,MACnC,CAAC;AAAA,IACL,CAAC;AACD,WAAO,IAAI,UAAS,YAAY,eAAe,CAAC;AAAA,EACpD;AAAA,EACA,IAAI,OAAO;AACP,cAAU,MAAM,OAAO,EAAE,QAAQ,CAAC,CAAC,MAAM,SAAS,MAAM,OAAO,OAAO,KAAK,QAAQ,IAAI,KAAK,CAAC,GAAG,SAAS,CAAC;AAAA,EAC9G;AAAA,EACA,cAAc,KAAK;AACf,UAAM,oBAAoB,UAAU,KAAK,OAAO,EAAE,IAAI,CAAC,CAAC,MAAM,SAAS,MAAM;AACzE,YAAM,WAAW,KAAK,MAAM,IAAI;AAChC,eAAS,QAAQ,OAAO,QAAQ,WAAW,SAAS,GAAG,IAAI,GAAG;AAC9D,YAAM,iBAAiB,KAAK,UAAU,QAAQ;AAC9C,aAAO,CAAC,gBAAgB,SAAS;AAAA,IACrC,CAAC;AACD,WAAO,IAAI,UAAS,YAAY,iBAAiB,CAAC;AAAA,EACtD;AAAA,EACA,WAAW;AACP,WAAO,UAAU,KAAK,OAAO;AAAA,EACjC;AACJ;AACA,IAAM,kBAAkB,CAAC,WAAW,GAAG,eAAe,OAAO,CAAC,CAAC,QAAQ,eAAe,OAAO,CAAC,CAAC;AAC/F,IAAM,iBAAiB,CAAC,UAAU,WAAW,OAAO,MAAM,IAAI,MAAM,aAC9D,QAAQ,KAAK,IAAI,MAAM,IAAI,cAAc,EAAE,KAAK,KAAK,IACjD,OAAO,KAAK;;;AC5EtB,IAAM,oBAAoB,CAAC;AACpB,IAAM,qBAAqB,CAAC,GAAG,GAAG,MAAM,eAAe,GAAG,GAAG,EAAE,GAAG,QAAQ,OAAO,MAAM,MAAM,CAAC;AAC9F,IAAM,gBAAgB,CAAC,GAAG,GAAG,MAAM,eAAe,GAAG,GAAG,EAAE,GAAG,QAAQ,OAAO,MAAM,KAAK,CAAC;AACxF,IAAM,iBAAiB,CAAC,GAAG,GAAG,QAAQ;AACzC,QAAM,WAAW,IAAI,OAAO,OAAO;AACnC,QAAM,aAAa,GAAG,EAAE,QAAQ,GAAG,QAAQ,GAAG,EAAE,QAAQ;AACxD,MAAI,kBAAkB,UAAU,MAAM;AAClC,WAAO,kBAAkB,UAAU;AACvC,MAAI,CAAC,IAAI,MAAM;AAEX,UAAM,aAAa,GAAG,EAAE,QAAQ,GAAG,QAAQ,GAAG,EAAE,QAAQ;AACxD,QAAI,kBAAkB,UAAU,MAAM,QAAW;AAG7C,YAAM,WAAW,kBAAkB,UAAU;AAC7C,YAAM,WAAW,oBAAoB,WAAW,SAAS,OAAO,IAAI;AAEpE,wBAAkB,UAAU,IAAI;AAChC,aAAO;AAAA,IACX;AAAA,EACJ;AACA,MAAI,EAAE,OAAO,CAAC;AACV,WAAO;AACX,MAAI;AACJ,MAAI,IAAI,QAAQ,EAAE,QAAQ,OAAO,GAAG;AAChC,aACI,IAAI,SACA,YAAY,GAAG,GAAG,GAAG,IACnB,cAAc,GAAG,GAAG,GAAG;AAAA,EACrC,WACS,IAAI,QAAQ,EAAE,QAAQ,OAAO,GAAG;AACrC,aACI,IAAI,SACA,cAAc,GAAG,GAAG,GAAG,IACrB,YAAY,GAAG,GAAG,GAAG;AAAA,EACnC,OACK;AACD,UAAM,eAAe,EAAE,aAAa,EAAE,aAAa,EAAE,OAAO,EAAE;AAC9D,UAAM,iBAAiB,EAAE,KAAK,cAAc,EAAE,IAAI,KAAK,EAAE,KAAK,cAAc,EAAE,IAAI;AAClF,QAAI,mBAAmB,QAAW;AAI9B,eAAS;AAAA,IACb,WACS,iBAAiB,EAAE;AACxB,eAAS,eAAe,GAAG,GAAG,GAAG;AAAA,SAChC;AACD,eAAS,eAAe,GAAG,GAAG,EAAE,GAAG,KAAK,QAAQ,CAAC,IAAI,OAAO,CAAC;AAC7D,UAAI,kBAAkB;AAClB,iBAAS,OAAO,OAAO;AAAA,IAC/B;AAAA,EACJ;AACA,MAAI,OAAO,MAAM,GAAG;AAGhB,QAAI,EAAE,OAAO,MAAM;AACf,eAAS;AAAA,aACJ,EAAE,OAAO,MAAM;AACpB,eAAS;AAAA,EACjB;AACA,oBAAkB,UAAU,IAAI;AAChC,SAAO;AACX;AAEO,IAAM,gBAAgB,CAAC,MAAM,IAAI,QAAQ;AAC5C,QAAM,SAAS,CAAC,GAAG,KAAK,MAAM;AAC9B,MAAI,KAAK,cAAc;AAEnB,UAAM,kBAAkB,eAAe,KAAK,cAAc,IAAI,GAAG;AACjE,QAAI,2BAA2B;AAC3B,aAAO;AACX,WAAO,OAAO,SAAS,CAAC,IAAI;AAAA,EAChC;AAEI,WAAO,KAAK,EAAE;AAClB,SAAO,IAAI,EAAE,KAAK,SAAS;AAAA,IACvB;AAAA,IACA,IAAI,KAAK;AAAA,EACb,CAAC;AACL;AACO,IAAM,cAAc,CAAC,MAAM,IAAI,QAAQ;AAC1C,QAAM,SAAS,eAAe,MAAM,GAAG,IAAI,GAAG;AAC9C,MAAI,kBAAkB;AAClB,WAAO;AACX,SAAO,IAAI,EAAE,KAAK,SAAS;AAAA,IACvB,QAAQ,GAAG;AAAA,IACX,IAAI;AAAA,EACR,CAAC;AACL;;;AC5FA,IAAAE,KAAAC;AAMO,IAAM,iBAAN,eAA6BA,MAAA,UAC/BD,MAAA,SAD+BC,KAAS;AAAA,EAAtC;AAAA;AACH,wBAACD,KAAW;AACZ;AAAA;AAAA,EACA,UAAU,GAAG;AACT,WAAO,mBAAmB,MAAM,GAAG,KAAK,CAAC;AAAA,EAC7C;AACJ;AACO,IAAM,yBAAN,cAAqC,eAAe;AAAA,EAApD;AAAA;AACH,yCAAgB,CAAC,MAAM,QAAQ;AAC3B,UAAI,CAAC,KAAK,eAAe,MAAM,GAAG;AAC9B,YAAI,MAAM,KAAK,YAAY;AAAA,IACnC;AAAA;AAAA,EACA,QAAQ,IAAI;AACR,QAAI,GAAG,kBAAkB;AACrB,SAAG,OAAO,KAAK,iBAAiB;AAAA,SAC/B;AACD,SAAG,GAAG,KAAK,kBAAkB,MAAM,GAAG,KAAK,GAAG,GAAG,GAAG,UAAU,KAAK,oBAAoB,GAAG,CAAC;AAAA,IAC/F;AAAA,EACJ;AAAA,EACA,IAAI,eAAe;AACf,WAAO,EAAE,MAAM,KAAK,MAAM,aAAa,KAAK,aAAa,GAAG,KAAK,MAAM;AAAA,EAC3E;AAAA,EACA,IAAI,uBAAuB;AACvB,WAAO,oBAAoB,KAAK,YAAY;AAAA,EAChD;AACJ;AACO,IAAM,sBAAsB,CAAC,SAAS,CAACE,SAAQ,QAAQ;AAC1D,MAAI,QAAQA,OAAM,GAAG;AACjB,QAAIA,QAAO,WAAW,GAAG;AAErB;AAAA,IACJ;AACA,WAAOA,QACF,IAAI,CAAAA,YAAU,IAAI,EAAE,KAAK,MAAMA,OAAM,CAAC,EACtC,KAAK,CAAC,GAAG,MAAO,EAAE,YAAY,EAAE,YAAY,KAAK,CAAE;AAAA,EAC5D;AACA,QAAM,QAAQ,IAAI,EAAE,KAAK,MAAMA,OAAM;AACrC,SAAO,MAAM,oBAAoB,IAAI,CAAC,KAAK,IAAI;AACnD;AACO,IAAM,uBAAuB,CAAC,MAAM;AA7C3C,MAAAF;AA8CI,QAAM,OAAO,EAAE,EAAE,MAAM;AACvB,MAAI,CAAC,MAAM;AACP,QAAI,SAAS,EAAE,EAAE,WAAW,KAAK,EAAE,SAAS,cACxC,EAAE,IAAI,EAAE,SAAS,QAAQ,MACvB,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,OAAO,OAAO,EAAE,WAAW,qBAAqB,EAAE,CAAC,CAAC,GAAG,EAAE,YAAY,KAAK,CAAC;AACtG,eAAWG,SAAQ,EAAE,OAAO;AACxB,UAAI,kBAAkB;AAClB,eAAO;AACX,eAAS,eAAeA,OAAM,QAAQ,EAAE,GAAG;AAAA,IAC/C;AACA,WAAO;AAAA,EACX;AACA,MAAI,UAAU;AACd,WAAS,IAAI,GAAG,IAAI,EAAE,EAAE,QAAQ,KAAK;AACjC,UAAM,SAAS,eAAe,EAAE,EAAE,CAAC,GAAG,MAAM,EAAE,GAAG;AACjD,QAAI,WAAW;AACX;AACJ,QAAI,kBAAkB;AAClB,aAAO;AACX,QAAI,CAAC,SAAS;AACV,UAAI,OAAO,OAAO,GAAG;AACjB,UAAE,MAAM,KAAK,MAAM;AACnB,UAAE,EAAE,OAAO,CAAC;AACZ,eAAO,qBAAqB,CAAC;AAAA,MACjC;AACA,QAAE,EAAE,CAAC,IAAI;AACT,gBAAU;AAAA,IACd,WACS,CAAC,EAAE,EAAE,SAAS,MAAM,GAAG;AAC5B,aAAO,mBAAmB,kFAAkF,MAAM,EAAE;AAAA,IACxH;AAAA,EACJ;AACA,MAAI,CAAC;AACD,MAAE,EAAE,KAAK,IAAI;AACjB,MAAI,EAAE,SAAS;AACX,KAAAH,MAAA,KAAK,oBAAL,gBAAAA,IAAsB,QAAQ,CAAAI,UAAQ,aAAa,EAAE,GAAGA,KAAI;AAChE,SAAO,qBAAqB,CAAC;AACjC;AACO,IAAM,qBAAqB,CAAC,UAAU;AACzC,QAAM,SAAS,OAAO,QAAQ,KAAK,EAC9B,QAAQ,CAAC,CAAC,GAAG,CAAC,MAAM,KAAK,iBAAiB,IAAI,CAAC,CAAC,EAChD,KAAK,CAAC,GAAG,MAAM,EAAE,aAAa,EAAE,aAAa,KAC5C,EAAE,aAAa,EAAE,aAAa,IAC1B,EAAE,YAAY,EAAE,YAAY,KACxB,CAAC;AACf,SAAO;AACX;AAEO,IAAM,uBAAuB,CAAC,gBAAgB;AACjD,QAAM,QAAQ,CAAC;AACf,aAAW,cAAc,aAAa;AAClC,QAAI,WAAW,oBAAoB,GAAG;AAClC,YAAM,WAAW,IAAI,IAAI,OAAO,MAAM,WAAW,IAAI,GAAG,UAAU;AAAA,IACtE,OACK;AACD,UAAI,MAAM,WAAW,IAAI,GAAG;AACxB,eAAO,mBAAmB,yDAAyD,WAAW,IAAI,EAAE;AAAA,MACxG;AACA,YAAM,WAAW,IAAI,IAAI;AAAA,IAC7B;AAAA,EACJ;AACA,SAAO;AACX;AACO,IAAM,2BAA2B,IAAI,SAAS,gBAAgB,2BAA2B,GAAG,IAAI,CAAC;AACjG,IAAM,6BAA6B,CAAC,MAAM,UAAU,WAAW,GAAG,WAAW,IAAI,CAAC,oBAAoB,SAAS,WAAW,SAAS,OAAO,QAAQ,QAAQ,EAAE,WAAW;;;AC5GvK,IAAM,oCAAoC,CAAC,MAAM;AACpD,IAAE,EAAE,OAAO,EAAE,KAAK;AAAA;AAAA;AAAA,EAGlB,CAAC;AACD,SAAO;AACX;AARA,IAAAC,KAAAC;AASO,IAAM,cAAN,eAA0BA,MAAA,UAI5BD,MAAA,SAJ4BC,KAAS;AAAA,EAKtC,YAAY,QAAQ,KAAK,GAAG;AACxB,UAAM,IAAI,SAAS;AACf;AAMA,aAAO,EAAE,OAAO,GAAG;AAAA,IACvB,CAAC;AAbL;AACA;AACA;AACA,wBAACD,KAAW;AAWR,SAAK,SAAS;AACd,SAAK,MAAM;AACX,SAAK,IAAI;AAAA,EACb;AACJ;;;ACzBO,IAAM,0BAA0B,cAAc;AAAA,EACjD,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,gBAAgB;AAAA,EAChB,MAAM;AAAA,IACF,WAAW,CAAC;AAAA,EAChB;AAAA,EACA,WAAW,CAAAE,YAAU,OAAOA,YAAW,aAAa,EAAE,WAAWA,QAAO,IAAIA;AAAA,EAC5E,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQ,sBAAsBA,MAAK,UAAU,QAAQ,wBAAwB;AAAA,EAC9F;AAAA,EACA,oBAAoB;AAAA,EACpB,eAAe;AAAA;AAAA;AAAA;AAAA;AAAA,IAKX,WAAW,MAAM;AAAA,EACrB;AACJ,CAAC;AACM,IAAM,gBAAN,cAA4B,eAAe;AAAA,EAA3C;AAAA;AACH,+CAAsB,oBAAoB,KAAK,SAAS;AACxD,6CAAoB,GAAG,KAAK,mBAAmB;AAC/C,4CAAmB,IAAI,KAAK,iBAAiB;AAC7C,wCAAe;AACf,sCAAa,KAAK;AAClB,0CAAiB,KAAK;AACtB,wCAAe;AAAA,MACX,MAAM;AAAA,MACN,aAAa,KAAK;AAAA,IACtB;AACA,gDAAuB,sCAAsC,KAAK,WAAW;AAC7E,yCAAgB,CAAC,MAAM,QAAQ;AAC3B,UAAI,CAAC,KAAK,UAAU,MAAM,GAAG,KAAK,CAAC,IAAI,SAAS;AAC5C,YAAI,MAAM,KAAK,YAAY;AAAA,IACnC;AAAA;AAAA,EACA,QAAQ,IAAI;AACR,QAAI,GAAG,kBAAkB,UAAU;AAC/B,SAAG,OAAO,KAAK,iBAAiB;AAChC;AAAA,IACJ;AACA,OAAG,GAAG,GAAG,KAAK,gBAAgB,uBAAuB,MAAM,GAAG,KAAK,aAAa,KAAK,oBAAoB,GAAG,CAAC;AAAA,EACjH;AACJ;;;AC5CO,IAAM,wBAAwB,cAAc;AAAA,EAC/C,MAAM;AAAA,EACN,gBAAgB;AAAA,EAChB,MAAM;AAAA,IACF,MAAM,CAAC;AAAA,EACX;AAAA,EACA,WAAW,CAAAC,YAAU,OAAOA,YAAW,WAAW,EAAE,MAAMA,QAAO,IAAIA;AAAA,EACrE,oBAAoB;AAAA,EACpB,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQA,MAAK,SAAS,IAAI,eAAe,iBAAiBA,MAAK,IAAI;AAAA,EACpF;AAAA,EACA,eAAe;AAAA,IACX,SAAS,CAAC,GAAG,GAAG,QAAQ,IAAI,EAAE,KAAK,WAAW;AAAA,MAC1C,MAAM,KAAK,IAAK,EAAE,OAAO,EAAE,OAAQ,sBAAsB,EAAE,MAAM,EAAE,IAAI,CAAC;AAAA,IAC5E,CAAC;AAAA,EACL;AACJ,CAAC;AACM,IAAM,cAAN,cAA0B,uBAAuB;AAAA,EAAjD;AAAA;AACH,0CAAiB,UAAQ,OAAO,KAAK,SAAS;AAC9C,6CAAoB,UAAU,KAAK,IAAI;AACvC,4CAAmB,UAAU,KAAK,IAAI;AACtC,wCAAe,KAAK,EAAE,SAAS,OAAO;AACtC,sCAAa,KAAK,KAAK,IAAI;AAAA;AAC/B;AAGA,IAAM,wBAAwB,CAAC,GAAG,MAAM;AACpC,MAAI;AACJ,MAAIC,yBAAwB;AAC5B,MAAI,UAAU;AACd,SAAO,YAAY,GAAG;AAClB,eAAW;AACX,cAAUA,yBAAwB;AAClC,IAAAA,yBAAwB;AAAA,EAC5B;AACA,SAAOA;AACX;;;ACpCO,IAAM,YAAN,cAAwB,uBAAuB;AAAA,EAA/C;AAAA;AACH,4CAAmB,wBAAwB,KAAK,IAAI;AACpD,0CAAiB,KAAK,qBAAqB,UAAU,SAC/C,KAAK,qBAAqB,WAAW,gBACjC;AACV,sCAAa,kBAAkB,KAAK,MAAM,KAAK,SAAS;AACxD,wCAAe,KAAK,KAAK,QAAQ;AACjC,sCAAa,GAAG,KAAK,UAAU,GAAG,KAAK,IAAI;AAC3C,6CAAoB,GAAG,KAAK,cAAc,IAAI,KAAK,UAAU,IAAI,KAAK,YAAY;AAClF,4CAAmB,GAAG,KAAK,cAAc,IAAI,mBAAmB,KAAK,UAAU,CAAC,IAAI,KAAK,YAAY;AAGrG;AAAA;AAAA,uCAAc,KAAK,qBAAqB,SACpC,kBAAkB,KAAK,YAAY,IACjC,GAAG,KAAK,YAAY;AAC1B,qCAAY,KAAK,WAAW,GAAG,MAAM,MAAM,UAAU;AAAA;AAAA,EACrD,eAAe,GAAG;AACd,UAAM,sBAAsB,KAAK,cAAc,UAC3C,KAAK,eAAe,EAAE,eACpB,KAAK,eAAe,EAAE;AAC5B,WAAQ,uBACH,KAAK,iBAAiB,EAAE,gBACrB,KAAK,cAAc,QACnB,CAAC,EAAE;AAAA,EACf;AAAA,EACA,cAAc,GAAG;AACb,QAAI,KAAK,eAAe,CAAC;AACrB,aAAO;AACX,QAAI,KAAK,iBAAiB,EAAE,iBAAiB,KAAK,aAAa,EAAE;AAC7D,aAAO;AACX,WAAO;AAAA,EACX;AAAA,EACA,cAAc,GAAG;AACb,WAAQ,KAAK,iBAAiB,EAAE,gBAAgB,CAAC,KAAK,aAAa,CAAC,EAAE;AAAA,EAC1E;AACJ;AACA,IAAM,qBAAqB;AAAA,EACvB,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AACV;AACO,IAAM,wBAAwB;AAAA,EACjC,KAAK;AAAA,EACL,WAAW;AAAA,EACX,OAAO;AACX;AACO,IAAM,oBAAoB;AAAA;AAAA,EAE7B,OAAO,CAAC,SAAS,QAAQ;AAC7B;AACO,IAAM,iBAAiB,CAAC,UAAU,OAAO,UAAU,YAAY,OAAO,UAAU,WACnF,IAAI,KAAK,KAAK,IACZ;AACN,IAAM,0BAA0B;AAAA,EAC5B,KAAK;AAAA,EACL,KAAK;AAAA,EACL,WAAW;AAAA,EACX,WAAW;AAAA,EACX,OAAO;AAAA,EACP,QAAQ;AACZ;AACO,IAAM,oBAAoB,CAAC,MAAM,cAAc,GAAG,QAAQ,MAAM,qBAAqB,IAAI,MAAM,GAAG,GAAG,YAAY,KAAK,GAAG;AACzH,IAAM,oBAAoB,CAAC,UAAU,OAAO,UAAU,WAAW,QAAQ,IAAI,KAAK,KAAK,EAAE,eAAe;AACxG,IAAM,0BAA0B,CAACC,UAAS,sBAAsBA,KAAI;;;AChEpE,IAAM,sBAAsB,cAAc;AAAA,EAC7C,MAAM;AAAA,EACN,gBAAgB;AAAA,EAChB,oBAAoB;AAAA,EACpB,MAAM;AAAA,IACF,MAAM;AAAA,MACF,OAAO;AAAA,MACP,WAAW,CAAAC,YAAUA,QAAO,YAAY;AAAA,IAC5C;AAAA,IACA,WAAW;AAAA,EACf;AAAA,EACA,WAAW,CAAAA,YAAW,OAAOA,YAAW,YACpC,OAAOA,YAAW,YAClBA,mBAAkB,OAClB,EAAE,MAAMA,QAAO,IACbA;AAAA,EACN,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQA,MAAK,YACtB,SAASA,MAAK,WAAW,KACvB,GAAGA,MAAK,WAAW;AAAA,IACzB,QAAQ,UAAQ,KAAK,eAAe;AAAA,EACxC;AAAA,EACA,eAAe;AAAA,IACX,OAAO,CAAC,GAAG,MAAO,EAAE,eAAe,CAAC,IAAI,IAAI;AAAA,EAChD;AACJ,CAAC;AACM,IAAM,YAAN,cAAwB,UAAU;AAAA,EAAlC;AAAA;AACH,wCAAe,KAAK,EAAE,SAAS,KAAK;AACpC,0CAAiB,KAAK,YAAY,UAAQ,OAAO,KAAK,OAAO,UAAQ,QAAQ,KAAK;AAAA;AACtF;;;AC5BO,IAAM,uBAAuB,cAAc;AAAA,EAC9C,MAAM;AAAA,EACN,gBAAgB;AAAA,EAChB,oBAAoB;AAAA,EACpB,MAAM;AAAA,IACF,MAAM;AAAA,MACF,OAAO;AAAA,MACP,WAAW,CAAAC,YAAUA,QAAO,YAAY;AAAA,IAC5C;AAAA,IACA,WAAW;AAAA,EACf;AAAA,EACA,WAAW,CAAAA,YAAW,OAAOA,YAAW,YACpC,OAAOA,YAAW,YAClBA,mBAAkB,OAClB,EAAE,MAAMA,QAAO,IACbA;AAAA,EACN,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQA,MAAK,YACtB,UAAUA,MAAK,WAAW,KACxB,GAAGA,MAAK,WAAW;AAAA,IACzB,QAAQ,UAAQ,KAAK,eAAe;AAAA,EACxC;AAAA,EACA,eAAe;AAAA,IACX,QAAQ,CAAC,GAAG,MAAO,EAAE,eAAe,CAAC,IAAI,IAAI;AAAA,IAC7C,OAAO,CAAC,QAAQ,OAAO,QAAQ,OAAO,cAAc,KAAK,IACrD,OAAO,cAAc,KAAK,IACtB,IAAI,EAAE,KAAK,QAAQ,EAAE,MAAM,OAAO,KAAK,CAAC,IACtC,OACJ,SAAS,KAAK,SAAS,QAAQ,KAAK;AAAA,EAC9C;AACJ,CAAC;AACM,IAAM,aAAN,cAAyB,UAAU;AAAA,EAAnC;AAAA;AACH,0CAAiB,KAAK,YAAY,UAAQ,OAAO,KAAK,OAAO,UAAQ,QAAQ,KAAK;AAClF,wCAAe,KAAK,EAAE,SAAS,KAAK;AAAA;AACxC;;;AClCO,IAAM,4BAA4B,cAAc;AAAA,EACnD,MAAM;AAAA,EACN,gBAAgB;AAAA,EAChB,MAAM;AAAA,IACF,MAAM,CAAC;AAAA,EACX;AAAA,EACA,WAAW,CAAAC,YAAU,OAAOA,YAAW,WAAW,EAAE,MAAMA,QAAO,IAAIA;AAAA,EACrE,oBAAoB;AAAA,EACpB,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQ,kBAAkBA,MAAK,IAAI;AAAA,IAChD,QAAQ,UAAQ,GAAG,KAAK,MAAM;AAAA,EAClC;AAAA,EACA,eAAe;AAAA,IACX,aAAa,CAAC,GAAG,GAAG,QAAQ,IAAI,SAAS;AAAA,MACrC,cAAc;AAAA,QACV,MAAM;AAAA,UACF,GAAG,IAAI,EAAE,KAAK,QAAQ,EAAE,MAAM,EAAE,KAAK,CAAC;AAAA,UACtC,GAAG,IAAI,EAAE,KAAK,QAAQ,EAAE,MAAM,EAAE,KAAK,CAAC;AAAA,QAC1C;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,IACD,WAAW,CAAC,aAAa,eAAe,UAAU,YAC9C,YAAY,OAAO,UAAU,OAC3B,YAAY,QAAQ,UAAU,QAChC,cACE,SAAS,KAAK,SAAS,aAAa,SAAS;AAAA,IACnD,WAAW,CAAC,aAAa,eAAe,UAAU,YAC9C,YAAY,OAAO,UAAU,OAC3B,YAAY,QAAQ,UAAU,QAChC,cACE,SAAS,KAAK,SAAS,aAAa,SAAS;AAAA,EACvD;AACJ,CAAC;AACM,IAAM,kBAAN,cAA8B,uBAAuB;AAAA,EAArD;AAAA;AACH,0CAAiB,UAAQ,KAAK,WAAW,KAAK;AAC9C,6CAAoB,mBAAmB,KAAK,IAAI;AAChD,4CAAmB,mBAAmB,KAAK,IAAI;AAC/C,wCAAe,KAAK,EAAE,SAAS,gBAAgB;AAC/C,sCAAa,aAAa,KAAK,IAAI;AAAA;AACvC;;;ACvCO,IAAM,oBAAoB,cAAc;AAAA,EAC3C,MAAM;AAAA,EACN,gBAAgB;AAAA,EAChB,oBAAoB;AAAA,EACpB,MAAM;AAAA,IACF,MAAM,CAAC;AAAA,IACP,WAAW;AAAA,EACf;AAAA,EACA,WAAW,CAAAC,YAAU,OAAOA,YAAW,WAAW,EAAE,MAAMA,QAAO,IAAIA;AAAA,EACrE,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQ,GAAGA,MAAK,YAAY,cAAc,SAAS,IAAIA,MAAK,IAAI;AAAA,EACjF;AAAA,EACA,eAAe;AAAA,IACX,KAAK,CAAC,GAAG,MAAO,EAAE,eAAe,CAAC,IAAI,IAAI;AAAA,IAC1C,KAAK,CAAC,KAAK,KAAK,QAAQ,IAAI,cAAc,GAAG,IACzC,IAAI,cAAc,GAAG,IACjB,IAAI,EAAE,KAAK,QAAQ,EAAE,MAAM,IAAI,KAAK,CAAC,IACnC,OACJ,SAAS,KAAK,SAAS,KAAK,GAAG;AAAA,EACzC;AACJ,CAAC;AACM,IAAM,UAAN,cAAsB,UAAU;AAAA,EAAhC;AAAA;AACH,wCAAe,KAAK,EAAE,SAAS,OAAO;AACtC,0CAAiB,KAAK,YAAY,UAAQ,OAAO,KAAK,OAAO,UAAQ,QAAQ,KAAK;AAAA;AACtF;;;ACxBO,IAAM,0BAA0B,cAAc;AAAA,EACjD,MAAM;AAAA,EACN,gBAAgB;AAAA,EAChB,oBAAoB;AAAA,EACpB,MAAM;AAAA,IACF,MAAM,CAAC;AAAA,IACP,WAAW;AAAA,EACf;AAAA,EACA,WAAW,CAAAC,YAAU,OAAOA,YAAW,WAAW,EAAE,MAAMA,QAAO,IAAIA;AAAA,EACrE,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQA,MAAK,YACtB,oBAAoBA,MAAK,IAAI,KAC3B,kBAAkBA,MAAK,IAAI;AAAA,IACjC,QAAQ,UAAQ,GAAG,KAAK,MAAM;AAAA,EAClC;AAAA,EACA,eAAe;AAAA,IACX,WAAW,CAAC,GAAG,MAAO,EAAE,eAAe,CAAC,IAAI,IAAI;AAAA,IAChD,WAAW,CAAC,KAAK,KAAK,QAAQ,IAAI,cAAc,GAAG,IAC/C,IAAI,cAAc,GAAG,IACjB,IAAI,EAAE,KAAK,eAAe,EAAE,MAAM,IAAI,KAAK,CAAC,IAC1C,OACJ,SAAS,KAAK,SAAS,KAAK,GAAG;AAAA,EACzC;AACJ,CAAC;AACM,IAAM,gBAAN,cAA4B,UAAU;AAAA,EAAtC;AAAA;AACH,wCAAe,KAAK,EAAE,SAAS,gBAAgB;AAC/C,0CAAiB,KAAK,YAClB,UAAQ,KAAK,SAAS,KAAK,OACzB,UAAQ,KAAK,UAAU,KAAK;AAAA;AACtC;;;AC9BO,IAAM,oBAAoB,cAAc;AAAA,EAC3C,MAAM;AAAA,EACN,gBAAgB;AAAA,EAChB,oBAAoB;AAAA,EACpB,MAAM;AAAA,IACF,MAAM,CAAC;AAAA,IACP,WAAW;AAAA,EACf;AAAA,EACA,WAAW,CAAAC,YAAU,OAAOA,YAAW,WAAW,EAAE,MAAMA,QAAO,IAAIA;AAAA,EACrE,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQ,GAAGA,MAAK,YAAY,cAAc,UAAU,IAAIA,MAAK,IAAI;AAAA,EAClF;AAAA,EACA,eAAe;AAAA,IACX,KAAK,CAAC,GAAG,MAAO,EAAE,eAAe,CAAC,IAAI,IAAI;AAAA,EAC9C;AACJ,CAAC;AACM,IAAM,UAAN,cAAsB,UAAU;AAAA,EAAhC;AAAA;AACH,wCAAe,KAAK,EAAE,SAAS,OAAO;AACtC,0CAAiB,KAAK,YAAY,UAAQ,OAAO,KAAK,OAAO,UAAQ,QAAQ,KAAK;AAAA;AACtF;;;ACnBO,IAAM,0BAA0B,cAAc;AAAA,EACjD,MAAM;AAAA,EACN,gBAAgB;AAAA,EAChB,oBAAoB;AAAA,EACpB,MAAM;AAAA,IACF,MAAM,CAAC;AAAA,IACP,WAAW;AAAA,EACf;AAAA,EACA,WAAW,CAAAC,YAAU,OAAOA,YAAW,WAAW,EAAE,MAAMA,QAAO,IAAIA;AAAA,EACrE,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQA,MAAK,YACtBA,MAAK,SAAS,IACV,cACE,oBAAoBA,MAAK,IAAI,KACjCA,MAAK,SAAS,IAAI,cACd,mBAAmBA,MAAK,IAAI;AAAA,IACtC,QAAQ,UAAQ,GAAG,KAAK,MAAM;AAAA,EAClC;AAAA,EACA,eAAe;AAAA,IACX,WAAW,CAAC,GAAG,MAAO,EAAE,eAAe,CAAC,IAAI,IAAI;AAAA,EACpD;AACJ,CAAC;AACM,IAAM,gBAAN,cAA4B,UAAU;AAAA,EAAtC;AAAA;AACH,wCAAe,KAAK,EAAE,SAAS,gBAAgB;AAC/C,0CAAiB,KAAK,YAClB,UAAQ,KAAK,SAAS,KAAK,OACzB,UAAQ,KAAK,UAAU,KAAK;AAAA;AACtC;;;ACtBO,IAAM,6BAA6B;AAAA,EACtC,KAAK;AAAA,EACL,KAAK;AAAA,EACL,WAAW;AAAA,EACX,WAAW;AAAA,EACX,aAAa;AAAA,EACb,OAAO;AAAA,EACP,QAAQ;AACZ;AACO,IAAM,qBAAqB;AAAA,EAC9B,KAAK;AAAA,EACL,KAAK;AAAA,EACL,WAAW;AAAA,EACX,WAAW;AAAA,EACX,aAAa;AAAA,EACb,OAAO;AAAA,EACP,QAAQ;AACZ;;;ACtBO,IAAM,sBAAsB,cAAc;AAAA,EAC7C,MAAM;AAAA,EACN,gBAAgB;AAAA,EAChB,MAAM;AAAA,IACF,MAAM,CAAC;AAAA,IACP,OAAO,CAAC;AAAA,EACZ;AAAA,EACA,WAAW,CAAAC,YAAU,OAAOA,YAAW,WAAW,EAAE,MAAMA,QAAO,IAC3DA,mBAAkB,SAChBA,QAAO,QACH,EAAE,MAAMA,QAAO,QAAQ,OAAOA,QAAO,MAAM,IACzC,EAAE,MAAMA,QAAO,OAAO,IAC1BA;AAAA,EACV,oBAAoB;AAAA,EACpB,oBAAoB;AAAA,EACpB,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQ,cAAcA,MAAK,IAAI;AAAA,EAChD;AAAA,EACA,eAAe;AAAA;AAAA;AAAA,IAGX,OAAO,MAAM;AAAA,EACjB;AACJ,CAAC;AACM,IAAM,YAAN,cAAwB,uBAAuB;AAAA,EAA/C;AAAA;AACH,oCAAW,IAAI,OAAO,KAAK,MAAM,KAAK,KAAK;AAC3C,sCAAa,GAAG,KAAK,QAAQ;AAC7B,0CAAiB,KAAK,SAAS,KAAK,KAAK,KAAK,QAAQ;AACtD,6CAAoB,GAAG,KAAK,UAAU;AACtC,4CAAmB,IAAI,KAAK,iBAAiB;AAC7C,wCAAe,KAAK,EAAE,SAAS,OAAO;AAAA;AAC1C;;;ACjCA,IAAAC,KAAAC;AAQO,IAAM,WAAN,eAAuBA,MAAA,UAEzBD,MAAA,SAFyBC,KAAS;AAAA,EAAhC;AAAA;AACH,oCAAW,KAAK,QAAQ,OAAO,IAAI,KAAK,MAAM,WAAW,CAAC,IAAI;AAC9D,wBAACD,KAAW;AAIZ;AAAA;AAAA,EAHA,IAAI,MAAM;AACN,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ;AACJ,QAAI,CAAC,KAAK,QAAQ;AACd,WAAK,SAAS,KAAK,SAAS;AAC5B,UAAI,KAAK,OAAO,SAAS,WAAW,GAAG;AACnC,wBAAgB,SAAS,KAAK,UAAU,mCAAmC;AAAA,MAC/E;AAAA,IACJ;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,UAAU,GAAG;AACT,UAAM,QAAQ,KAAK,EAAE,UAAU,CAAC;AAChC,WAAO,mBAAmB,MAAM,OAAO,KAAK,CAAC;AAAA,EACjD;AAAA,EACA,IAAI,GAAG;AACH,UAAM,SAAS,KAAK,UAAU,CAAC;AAC/B,WAAO,kBAAkB,WAAW,OAAO,MAAM,IAAI;AAAA,EACzD;AAAA,EACA,GAAG,GAAG;AACF,UAAM,QAAQ,KAAK,EAAE,UAAU,CAAC;AAChC,UAAM,WAAW,CAAC,GAAG,KAAK,UAAU,GAAG,MAAM,QAAQ;AACrD,WAAO,KAAK,EAAE,OAAO,QAAQ;AAAA,EACjC;AAAA,EACA,OAAO,MAAM;AACT,UAAM,SAAS,KAAK,SAAS,IAAI;AACjC,WAAO,kBAAkB,YAAY,OAAO,MAAM,IAAI;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAQ,GAAG;AACP,UAAM,QAAQ,KAAK,EAAE,UAAU,CAAC;AAChC,WAAO,KAAK,EAAE,OAAO,KAAK,SAAS,OAAO,YAAU,OAAO,QAAQ,KAAK,CAAC,CAAC;AAAA,EAC9E;AAAA,EACA,QAAQ,GAAG;AACP,UAAM,QAAQ,KAAK,EAAE,UAAU,CAAC;AAChC,WAAO,KAAK,EAAE,OAAO,KAAK,SAAS,OAAO,YAAU,CAAC,OAAO,QAAQ,KAAK,CAAC,CAAC;AAAA,EAC/E;AAAA,EACA,QAAQ;AACJ,WAAO,KAAK,EAAE,OAAO;AAAA,MACjB,OAAO;AAAA,MACP,UAAU;AAAA,IACd,GAAG,EAAE,YAAY,KAAK,CAAC;AAAA,EAC3B;AAAA,EACA,SAAS,GAAG;AACR,UAAM,eAAe,KAAK,UAAU,CAAC;AACrC,WAAO,EAAE,wBAAwB;AAAA,EACrC;AAAA,EACA,QAAQ,GAAG;AACP,UAAM,eAAe,KAAK,UAAU,CAAC;AACrC,WAAQ,EAAE,wBAAwB,aAAa,KAAK,OAAO,YAAY;AAAA,EAC3E;AAAA,EACA,SAAS,GAAG;AACR,WAAO,EAAE,QAAQ,IAAI;AAAA,EACzB;AAAA,EACA,UAAU,qBAAqB;AAC3B,WAAO,KAAK,4BAA4B,mBAAmB;AAAA,EAC/D;AAAA,EACA,SAAS,aAAa;AAClB,WAAO,KAAK,UAAU,WAAW;AAAA,EACrC;AAAA,EACA,KAAK,OAAO;AAGR,WAAO,KAAK,OAAO,KAAK;AAAA,EAC5B;AAAA,EACA,QAAQ,QAAQ;AACZ,WAAO,OAAO,OAAO,CAAC,KAAK,UAAU,IAAI,SAAS,KAAK,GAAG,IAAI;AAAA,EAClE;AAAA,EACA,SAAS,OAAO;AACZ,QAAI,WAAW,OAAO,MAAM,GAAG;AAC3B,YAAM,SAAS,cAAc,MAAM,OAAO,KAAK,CAAC;AAChD,UAAI,kBAAkB;AAClB,eAAO,OAAO,MAAM;AACxB,aAAO;AAAA,IACX;AACA,QAAI,KAAK,QAAQ,OAAO,GAAG;AACvB,YAAM,WAAW,KAAK,SAAS,IAAI,CAAAE,UAAQA,MAAK,KAAK,KAAK,CAAC;AAC3D,aAAO,KAAK,EAAE,KAAK,SAAS,EAAE,GAAG,KAAK,OAAO,SAAS,CAAC;AAAA,IAC3D;AACA,QAAI,KAAK,QAAQ,OAAO,GAAG;AACvB,aAAO,KAAK,EAAE,KAAK,SAAS;AAAA,QACxB,GAAG,KAAK;AAAA,QACR,QAAQ,CAAC,GAAG,KAAK,QAAQ,KAAK;AAAA,MAClC,CAAC;AAAA,IACL;AACA,WAAO,KAAK,EAAE,KAAK,SAAS;AAAA,MACxB,IAAI;AAAA,MACJ,QAAQ,CAAC,KAAK;AAAA,IAClB,CAAC;AAAA,EACL;AAAA,EACA,OAAO,WAAW;AACd,WAAO,KAAK,aAAa,aAAa,SAAS;AAAA,EACnD;AAAA,EACA,UAAU,MAAMC,SAAQ;AACpB,WAAO,KAAK,WAAW,MAAM,MAAMA,OAAM;AAAA,EAC7C;AAAA,EACA,aAAa,MAAMA,SAAQ;AACvB,WAAO,KAAK,WAAW,OAAO,MAAMA,OAAM;AAAA,EAC9C;AAAA,EACA,WAAW,IAAI,MAAMA,SAAQ;AACzB,UAAM,aAAa,KAAK,EAAE,KAAK,MAAMA,OAAM;AAC3C,QAAI,WAAW,gBAAgB,CAAC,KAAK,EAAE,EAAE,QAAQ,WAAW,YAAY,GAAG;AACvE,aAAO,yBAAyB,MAAM,WAAW,cAAc,IAAI;AAAA,IACvE;AACA,UAAM,sBAAsB,KAAK,EAAE,KAAK,gBAAgB;AAAA,MACpD,CAAC,IAAI,GAAG;AAAA,IACZ,CAAC;AACD,UAAM,SAAS,OAAO,OAClB,mBAAmB,MAAM,qBAAqB,KAAK,CAAC,IAClD,cAAc,MAAM,qBAAqB,KAAK,CAAC;AACrD,QAAI,kBAAkB;AAClB,aAAO,MAAM;AACjB,WAAO;AAAA,EACX;AAAA,EACA,gBAAgB,YAAY;AACxB,WAAO,KAAK,UAAU,CAAC,MAAM,UAAU,SAAS,cAC5C,eAAe,WACX,KAAK,OAAO,EAAE,YAAY,EAAE,CAAC,IAC3B,EAAE,GAAG,OAAO,WAAW,IAC3B,OAAO,EAAE,iBAAiB,CAAAD,UAAQ,CAAC,SAAS,iBAAiBA,MAAK,IAAI,EAAE,CAAC;AAAA,EACnF;AAAA,EACA,WAAW,WAAW;AAClB,WAAO,KAAK,UAAU,aAAa,SAAS;AAAA,EAChD;AAAA,EACA,YAAYC,SAAQ;AAChB,WAAO,KAAK,UAAU,WAAWA,OAAM;AAAA,EAC3C;AAAA,EACA,SAASA,SAAQ;AACb,WAAO,KAAK,UAAU,SAASA,OAAM;AAAA,EACzC;AAAA,EACA,QAAQA,SAAQ;AACZ,WAAO,KAAK,UAAU,OAAOA,OAAM;AAAA,EACvC;AAAA,EACA,OAAOA,SAAQ;AACX,WAAO,KAAK,UAAU,OAAOA,OAAM;AAAA,EACvC;AAAA,EACA,SAASA,SAAQ;AACb,WAAO,KAAK,UAAU,OAAO,uBAAuBA,OAAM,CAAC;AAAA,EAC/D;AAAA,EACA,SAASA,SAAQ;AACb,WAAO,KAAK,UAAU,OAAO,uBAAuBA,OAAM,CAAC;AAAA,EAC/D;AAAA,EACA,cAAcA,SAAQ;AAClB,WAAO,KAAK,UAAU,aAAaA,OAAM;AAAA,EAC7C;AAAA,EACA,aAAaA,SAAQ;AACjB,WAAO,KAAK,UAAU,aAAaA,OAAM;AAAA,EAC7C;AAAA,EACA,eAAeA,SAAQ;AACnB,WAAO,KAAK,UAAU,aAAa,uBAAuBA,OAAM,CAAC;AAAA,EACrE;AAAA,EACA,eAAeA,SAAQ;AACnB,WAAO,KAAK,UAAU,aAAa,uBAAuBA,OAAM,CAAC;AAAA,EACrE;AAAA,EACA,cAAcA,SAAQ;AAClB,WAAO,KAAK,UAAU,eAAeA,OAAM;AAAA,EAC/C;AAAA,EACA,UAAUA,SAAQ;AACd,WAAO,KAAK,UAAU,SAASA,OAAM;AAAA,EACzC;AAAA,EACA,WAAWA,SAAQ;AACf,WAAO,KAAK,UAAU,UAAUA,OAAM;AAAA,EAC1C;AAAA,EACA,UAAUA,SAAQ;AACd,WAAO,KAAK,UAAU,SAAS,uBAAuBA,OAAM,CAAC;AAAA,EACjE;AAAA,EACA,YAAYA,SAAQ;AAChB,WAAO,KAAK,UAAU,UAAU,uBAAuBA,OAAM,CAAC;AAAA,EAClE;AACJ;AACO,IAAM,yBAAyB,CAACA,YAAY,OAAOA,YAAW,YAAY,EAAEA,mBAAkB,QACjG,EAAE,GAAGA,SAAQ,WAAW,KAAK,IAC3B;AAAA,EACE,MAAMA;AAAA,EACN,WAAW;AACf;;;AC9LG,IAAM,+BAA+B,CAAC,MAAM,mBAAmB,UAAU,mBAAmB,IAAI,GAAG,CAAC,GAAGC,UAAS;AAAA,EACnHA;AAAA,EACA;AACJ,CAAC;;;ACLD,IAAI,oBAAwD,SAAU,SAAS,cAAc,OAAO;AAChG,MAAI,WAAW,UAAU,SAAS;AAClC,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,YAAQ,WAAW,aAAa,CAAC,EAAE,KAAK,SAAS,KAAK,IAAI,aAAa,CAAC,EAAE,KAAK,OAAO;AAAA,EAC1F;AACA,SAAO,WAAW,QAAQ;AAC9B;AACA,IAAI,eAA8C,SAAU,MAAM,cAAc,YAAY,WAAW,cAAc,mBAAmB;AACpI,WAAS,OAAO,GAAG;AAAE,QAAI,MAAM,UAAU,OAAO,MAAM,WAAY,OAAM,IAAI,UAAU,mBAAmB;AAAG,WAAO;AAAA,EAAG;AACtH,MAAI,OAAO,UAAU,MAAM,MAAM,SAAS,WAAW,QAAQ,SAAS,WAAW,QAAQ;AACzF,MAAI,SAAS,CAAC,gBAAgB,OAAO,UAAU,QAAQ,IAAI,OAAO,KAAK,YAAY;AACnF,MAAI,aAAa,iBAAiB,SAAS,OAAO,yBAAyB,QAAQ,UAAU,IAAI,IAAI,CAAC;AACtG,MAAI,GAAG,OAAO;AACd,WAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,KAAK;AAC7C,QAAI,UAAU,CAAC;AACf,aAAS,KAAK,UAAW,SAAQ,CAAC,IAAI,MAAM,WAAW,CAAC,IAAI,UAAU,CAAC;AACvE,aAAS,KAAK,UAAU,OAAQ,SAAQ,OAAO,CAAC,IAAI,UAAU,OAAO,CAAC;AACtE,YAAQ,iBAAiB,SAAU,GAAG;AAAE,UAAI,KAAM,OAAM,IAAI,UAAU,wDAAwD;AAAG,wBAAkB,KAAK,OAAO,KAAK,IAAI,CAAC;AAAA,IAAG;AAC5K,QAAI,UAAU,GAAG,WAAW,CAAC,GAAG,SAAS,aAAa,EAAE,KAAK,WAAW,KAAK,KAAK,WAAW,IAAI,IAAI,WAAW,GAAG,GAAG,OAAO;AAC7H,QAAI,SAAS,YAAY;AACrB,UAAI,WAAW,OAAQ;AACvB,UAAI,WAAW,QAAQ,OAAO,WAAW,SAAU,OAAM,IAAI,UAAU,iBAAiB;AACxF,UAAI,IAAI,OAAO,OAAO,GAAG,EAAG,YAAW,MAAM;AAC7C,UAAI,IAAI,OAAO,OAAO,GAAG,EAAG,YAAW,MAAM;AAC7C,UAAI,IAAI,OAAO,OAAO,IAAI,EAAG,cAAa,QAAQ,CAAC;AAAA,IACvD,WACS,IAAI,OAAO,MAAM,GAAG;AACzB,UAAI,SAAS,QAAS,cAAa,QAAQ,CAAC;AAAA,UACvC,YAAW,GAAG,IAAI;AAAA,IAC3B;AAAA,EACJ;AACA,MAAI,OAAQ,QAAO,eAAe,QAAQ,UAAU,MAAM,UAAU;AACpE,SAAO;AACX;AAOA,IAAI,aAAa,MAAM;AAxCvB,MAAAC;AAyCI,MAAI,cAAc;AAClB,MAAI,6BAA6B,CAAC;AAClC,MAAI;AACJ,SAAOA,MAAA,cAAwB,YAAY;AAAA,IAApC;AAAA;AAOH,yCAAc,kBAAkB,MAAM,0BAA0B,GAAG,KAAK;AAOxE,4CAAiB,CAAC,MAAM,QAAQ;AAC5B,cAAM,OAAO,IAAI,KAAK,KAAK,EAAE;AAC7B,YAAI,6BAAM,SAAS;AACf,iBAAO;AACX,YAAI,KAAK,KAAK,EAAE,IAAI,OAAO,MAAM,IAAI;AACrC,eAAO,KAAK,WAAW,eAAe,MAAM,GAAG;AAAA,MACnD;AACA,2CAAgB,CAAC,MAAM,QAAQ;AAC3B,cAAM,OAAO,IAAI,KAAK,KAAK,EAAE;AAC7B,YAAI,6BAAM,SAAS;AACf;AACJ,YAAI,KAAK,KAAK,EAAE,IAAI,OAAO,MAAM,IAAI;AACrC,aAAK,WAAW,cAAc,MAAM,GAAG;AAAA,MAC3C;AAAA;AAAA,IAnBA,IAAI,aAAa;AApDzB,UAAAA;AAqDY,eAAOA,MAAA,KAAK,YAAL,gBAAAA,IAAA,eAAoB,KAAK,EAAE,YAAY,KAAK,KAAK;AAAA,IAC5D;AAAA,IACA,WAAW;AACP,aAAO,KAAK,WAAW,MAAM;AAAA,IACjC;AAAA,IAeA,QAAQ,IAAI;AACR,SAAG,GAAG,YAAY,KAAK,EAAE,oBAAoB,MAAM,GAAG,OAAO,IAAI,CAAC;AAClE,SAAG,KAAK,YAAY,KAAK,EAAE,SAAS,EAAE,KAAK,YAAY,KAAK,EAAE,aAAa;AAC3E,SAAG,OAAO,GAAG,OAAO,KAAK,UAAU,CAAC;AAAA,IACxC;AAAA,EACJ,IAhCI,MAAO;AACH,UAAM,YAAY,OAAO,WAAW,cAAc,OAAO,WAAW,OAAO,OAAO,YAAY,OAAO,QAAQ,KAAK,IAAI,IAAI;AAC1H,iCAA6B,CAAC,MAAM;AACpC,iBAAaA,KAAM,MAAM,4BAA4B,EAAE,MAAM,UAAU,MAAM,cAAc,QAAQ,OAAO,SAAS,OAAO,QAAQ,EAAE,KAAK,SAAO,gBAAgB,KAAK,KAAK,SAAO,IAAI,WAAW,GAAG,UAAU,UAAU,GAAG,MAAM,0BAA0B;AAC1P,QAAI,UAAW,QAAO,eAAeA,KAAM,OAAO,UAAU,EAAE,YAAY,MAAM,cAAc,MAAM,UAAU,MAAM,OAAO,UAAU,CAAC;AAAA,EAC1I,MANGA;AAkCX,GAAG;AAEI,IAAM,uBAAuB,CAACC,YAAW,OAAOA,YAAW,WAAW,EAAE,OAAOA,QAAO,MAAM,CAAC,EAAE,IAAIA;AACnG,IAAM,sBAAsB,cAAc;AAAA,EAC7C,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,gBAAgB;AAAA,EAChB,MAAM;AAAA,IACF,OAAO;AAAA,MACH,WAAW,CAAAA,YAAU,IAAIA,OAAM;AAAA,IACnC;AAAA,IACA,SAAS,CAAC;AAAA,EACd;AAAA,EACA,WAAW;AAAA,EACX,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQA,MAAK;AAAA,EAC9B;AAAA,EACA,eAAe;AAAA,IACX,OAAO,CAAC,GAAG,GAAG,QAAQ,IAAI,EAAE,cAAc,MAAM,gBAAgB,eAAe,EAAE,YAAY,EAAE,YAAY,GAAG,GAAG,IAAI,CAAC,GAAG,GAAG,EAAE,KAAK,GAAG,IAAI,OAAO,OAAO,GAAG,GAAG,EAAE,KAAK,EAAE;AAAA,IACvK,GAAG,6BAA6B,SAAS,CAAC,GAAG,GAAG,QAAQ,IAAI,EAAE,cAAc,MAAM,gBAAgB,eAAe,EAAE,YAAY,GAAG,GAAG,GAAG,IAAI,CAAC,GAAG,GAAG,EAAE,KAAK,GAAG,IAAI,OAAO,OAAO,GAAG,GAAG,EAAE,KAAK,EAAE,CAAC;AAAA,EACnM;AACJ,CAAC;AACD,IAAM,kBAAkB,CAAC,QAAQ,MAAO,kBAAkB,WAAW,EAAE,SAAS,MAAM,MAAM;;;AClGrF,IAAM,WAAN,cAAuB,SAAS;AAAA,EAAhC;AAAA;AAIH,yCAAgB,CAAC,MAAM,QAAQ;AAC3B,UAAI,CAAC,KAAK,eAAe,MAAM,GAAG;AAC9B,YAAI,MAAM,KAAK,YAAY;AAAA,IACnC;AAAA;AAAA,EANA,WAAW;AACP,WAAO,KAAK,EAAE,MAAM,KAAK,WAAW;AAAA,EACxC;AAAA,EAKA,IAAI,eAAe;AACf,WAAO,EAAE,MAAM,KAAK,MAAM,aAAa,KAAK,aAAa,GAAG,KAAK,MAAM;AAAA,EAC3E;AAAA,EACA,IAAI,uBAAuB;AACvB,WAAO,oBAAoB,KAAK,YAAY;AAAA,EAChD;AAAA,EACA,QAAQ,IAAI;AACR,QAAI,GAAG,kBAAkB;AACrB,SAAG,OAAO,KAAK,iBAAiB;AAAA,SAC/B;AACD,SAAG,GAAG,KAAK,kBAAkB,MAAM,GAAG,KAAK,GAAG,GAAG,GAAG,UAAU,KAAK,oBAAoB,GAAG,CAAC;AAAA,IAC/F;AAAA,EACJ;AACJ;;;ACnBO,IAAM,aAAN,cAAyB,SAAS;AAAA,EAAlC;AAAA;AACH,0CAAiB,UAAQ,SAAS,IAAI,MAAM,KAAK;AACjD,6CAAoB,KAAK,WAAW,WAChC,gFACE,oBAAoB,KAAK,MAAM;AACrC,4CAAmB,KAAK,WAAW,WAC/B,gFACE,oBAAoB,KAAK,MAAM;AACrC,sCAAa,KAAK;AAClB,uCAAc,kBAAkB,KAAK,MAAM;AAAA;AAC/C;AACO,IAAM,uBAAuB,cAAc;AAAA,EAC9C,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,gBAAgB;AAAA,EAChB,MAAM;AAAA,IACF,QAAQ,CAAC;AAAA,EACb;AAAA,EACA,WAAW,CAAAC,YAAU,OAAOA,YAAW,WAAW,EAAE,QAAQA,QAAO,IAAIA;AAAA,EACvE,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQ,mBAAmBA,MAAK,MAAM;AAAA,IACnD,QAAQ,UAAS,OAAO,SAAS,YAAY,GAAG,IAAI,KAAK,SAAS,IAAI;AAAA,EAC1E;AAAA,EACA,eAAe;AAAA,IACX,QAAQ,CAAC,GAAG,MAAM,SAAS,KAAK,UAAU,GAAG,CAAC;AAAA,EAClD;AACJ,CAAC;;;AC9BM,IAAM,WAAW,EAAE,aAAa,EAAE;;;ACAzC,IAAAC;AASO,IAAM,mBAAN,cAA+B,SAAS;AAAA,EAAxC;AAAA;AACH,iCAAQ,KAAK,UAAU,KAAK,SAAS;AACrC,uCAAc,KAAK,SAAS,OAAO,CAACC,UAASA,MAAK,aAAa,CAAC;AAChE,wCAAaD,MAAA,KAAK,cAAL,gBAAAA,IAAgB,eACzB,KAAK,SAAS,IAAI,CAAAC,UAAQA,MAAK,kBAAkB,EAAE,KAAK,KAAK,KAC7D;AACJ,0CAAiB,CAAC,MAAM,QAAQ,KAAK,SAAS,MAAM,WAAS,MAAM,eAAe,MAAM,GAAG,CAAC;AAC5F,yCAAgB,CAAC,MAAM,QAAQ;AAC3B,YAAM,aAAa,IAAI;AACvB,UAAI,KAAK,OAAO;AACZ,aAAK,MAAM,cAAc,MAAM,GAAG;AAClC,YAAI,IAAI,oBAAoB;AACxB;AAAA,MACR;AACA,UAAI,KAAK,YAAY,QAAQ;AACzB,iBAAS,IAAI,GAAG,IAAI,KAAK,YAAY,SAAS,GAAG,KAAK;AAClD,eAAK,YAAY,CAAC,EAAE,cAAc,MAAM,GAAG;AAC3C,cAAI,IAAI,YAAY,IAAI,oBAAoB;AACxC;AAAA,QACR;AACA,aAAK,YAAY,GAAG,EAAE,EAAE,cAAc,MAAM,GAAG;AAC/C,YAAI,IAAI,oBAAoB;AACxB;AAAA,MACR;AACA,UAAI,KAAK,WAAW;AAChB,aAAK,UAAU,cAAc,MAAM,GAAG;AACtC,YAAI,IAAI,oBAAoB;AACxB;AAAA,MACR;AACA,UAAI,KAAK,WAAW;AAChB,iBAAS,IAAI,GAAG,IAAI,KAAK,UAAU,SAAS,GAAG,KAAK;AAChD,eAAK,UAAU,CAAC,EAAE,cAAc,MAAM,GAAG;AACzC,cAAI,IAAI,YAAY,IAAI,oBAAoB;AACxC;AAAA,QACR;AACA,aAAK,UAAU,GAAG,EAAE,EAAE,cAAc,MAAM,GAAG;AAAA,MACjD;AAAA,IACJ;AAAA;AAAA,EACA,QAAQ,IAAI;AACR,QAAI,GAAG,kBAAkB,UAAU;AAC/B,WAAK,SAAS,QAAQ,WAAS,GAAG,MAAM,KAAK,CAAC;AAC9C,SAAG,OAAO,IAAI;AACd;AAAA,IACJ;AACA,OAAG,qBAAqB;AACxB,QAAI,KAAK,OAAO;AACZ,SAAG,MAAM,KAAK,KAAK;AAEnB,UAAI,KAAK,SAAS,SAAS;AACvB,WAAG,aAAa;AAAA,IACxB;AACA,QAAI,KAAK,YAAY,QAAQ;AACzB,eAAS,IAAI,GAAG,IAAI,KAAK,YAAY,SAAS,GAAG,KAAK;AAClD,WAAG,MAAM,KAAK,YAAY,CAAC,CAAC;AAC5B,WAAG,iBAAiB;AAAA,MACxB;AACA,SAAG,MAAM,KAAK,YAAY,GAAG,EAAE,CAAC;AAChC,UAAI,KAAK,aAAa,KAAK;AACvB,WAAG,aAAa;AAAA,IACxB;AACA,QAAI,KAAK,WAAW;AAChB,SAAG,MAAM,KAAK,SAAS;AACvB,UAAI,KAAK;AACL,WAAG,aAAa;AAAA,IACxB;AACA,QAAI,KAAK,WAAW;AAChB,eAAS,IAAI,GAAG,IAAI,KAAK,UAAU,SAAS,GAAG,KAAK;AAChD,WAAG,MAAM,KAAK,UAAU,CAAC,CAAC;AAG1B,WAAG,aAAa;AAAA,MACpB;AACA,SAAG,MAAM,KAAK,UAAU,GAAG,EAAE,CAAC;AAAA,IAClC;AAAA,EACJ;AAAA,EACA,WAAW;AApFf,QAAAD;AAqFQ,WAAQ,KAAK,QACT,KAAK,YACD,KAAK,MAAM,SAAS,EAAE,GAAG,KAAK,UAAU,MAAM,CAAC,IAC7C,KAAK,MAAM,SAAS,MACxBA,MAAA,KAAK,cAAL,gBAAAA,IAAgB,YAAW,KAAK,EAAE,SAAS,MAAM;AAAA,EAC3D;AACJ;AACA,IAAM,yBAAyB,CAAC,GAAG,GAAG,QAAQ;AAE1C,MAAI,WAAW,GAAG,MAAM,KAAK,EAAE,QAAQ,cAAc;AACjD,WAAO,uBAAuB,EAAE,OAAO,GAAG,GAAG;AACjD,MAAI,WAAW,GAAG,MAAM,KAAK,EAAE,QAAQ,cAAc;AACjD,WAAO,uBAAuB,GAAG,EAAE,OAAO,GAAG;AACjD,QAAM,YAAY,cAAc,CAAC,IAAI,KAAK,GAAG,QAAQ,IAAI,CAAC;AAC1D,QAAM,SAAS,EAAE,SAAS,EAAE;AAC5B,QAAM,SAAS,EAAE,SAAS,EAAE;AAC5B,QAAM,cAAc,SAChB,SACI,eAAe,QAAQ,QAAQ,GAAG,IAChC,SACJ;AACN,MAAI,uBAAuB;AACvB,WAAO;AACX,MAAI;AACA,cAAU,YAAY,IAAI,IAAI;AAClC,SAAO,qBAAqB;AAAA,IACxB,MAAM;AAAA,IACN;AAAA,IACA,GAAG,mBAAmB,CAAC;AAAA,IACvB,GAAG,mBAAmB,CAAC;AAAA,IACvB,OAAO,CAAC;AAAA,IACR;AAAA,EACJ,CAAC;AACL;AACO,IAAM,6BAA6B,cAAc;AAAA,EACpD,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,WAAW,CAAAE,eAAa;AACpB,QAAI,OAAOA,UAAS;AAChB,aAAOA;AACX,UAAM,EAAE,WAAW,GAAGC,QAAO,IAAID;AACjC,UAAM,sBAAsB,CAAC,CAAC;AAC9B,UAAM,sBAAsB,aAAa,CAAC;AAC1C,UAAM,aAAa,UAAUC,SAAQ,CAAC,GAAG,MAAM;AAC3C,UAAI,QAAQ,GAAG,aAAa,GAAG;AAC3B,YAAI,qBAAqB;AACrB,0BAAgB,2BAA2B,CAAC,wDAAwD;AAAA,QACxG;AACA,4BAAoB,CAAC,IAAI;AACzB,eAAO,CAAC;AAAA,MACZ;AACA,aAAO,CAAC,GAAG,CAAC;AAAA,IAChB,CAAC;AACD,QAAI,CAAC,cAAc,mBAAmB;AAClC,iBAAW,YAAY;AAC3B,WAAO;AAAA,EACX;AAAA,EACA,cAAc,CAAC,EAAE,WAAW,GAAG,KAAK,MAAM,UAAU,WAAW,QAAQ,IAAI,EAAE,GAAG,WAAW,GAAG,KAAK,IAAI;AAAA,EACvG,MAAM;AAAA,IACF,QAAQ;AAAA,MACJ,OAAO;AAAA,MACP,OAAO,CAACA,SAAQ,QAAQ,IAAI,EAAE,KAAK,UAAUA,OAAM;AAAA,IACvD;AAAA,IACA,OAAO;AAAA,MACH,OAAO;AAAA,MACP,OAAO,CAACA,SAAQ,QAAQ,IAAI,EAAE,KAAK,SAASA,OAAM;AAAA,IACtD;AAAA,IACA,WAAW;AAAA,MACP,OAAO;AAAA,MACP,OAAO,CAACA,SAAQ,QAAQ,IAAI,EAAE,KAAK,aAAaA,OAAM;AAAA,MACtD,WAAW,CAAAF,UAAQ;AA3J/B,YAAAD;AA4JgB,YAAI,GAACA,MAAAC,MAAK,aAAL,gBAAAD,IAAe;AAChB,iBAAOC,MAAK;AAChB,cAAM,EAAE,UAAU,GAAG,cAAc,IAAIA,MAAK;AAC5C,cAAM,EAAE,mBAAmB,GAAG,aAAa,IAAI;AAC/C,cAAM,0BAA0B,aAAa,YAAY,OAAO,KAAK,YAAY,EAAE,WAAW,IAC1F,aAAa,WACX;AACN,eAAO,EAAE,GAAG,eAAe,UAAU,wBAAwB;AAAA,MACjE;AAAA,IACJ;AAAA,IACA,SAAS;AAAA,MACL,OAAO;AAAA,MACP,OAAO,oBAAoB,SAAS;AAAA,IACxC;AAAA,IACA,KAAK;AAAA,MACD,OAAO;AAAA,MACP,OAAO,oBAAoB,KAAK;AAAA,IACpC;AAAA,IACA,KAAK;AAAA,MACD,OAAO;AAAA,MACP,OAAO,oBAAoB,KAAK;AAAA,IACpC;AAAA,IACA,WAAW;AAAA,MACP,OAAO;AAAA,MACP,OAAO,oBAAoB,WAAW;AAAA,IAC1C;AAAA,IACA,WAAW;AAAA,MACP,OAAO;AAAA,MACP,OAAO,oBAAoB,WAAW;AAAA,IAC1C;AAAA,IACA,aAAa;AAAA,MACT,OAAO;AAAA,MACP,OAAO,oBAAoB,aAAa;AAAA,IAC5C;AAAA,IACA,QAAQ;AAAA,MACJ,OAAO;AAAA,MACP,OAAO,oBAAoB,QAAQ;AAAA,IACvC;AAAA,IACA,OAAO;AAAA,MACH,OAAO;AAAA,MACP,OAAO,oBAAoB,OAAO;AAAA,IACtC;AAAA,IACA,OAAO;AAAA,MACH,OAAO;AAAA,MACP,OAAO,oBAAoB,OAAO;AAAA,IACtC;AAAA,IACA,WAAW;AAAA,MACP,OAAO;AAAA,MACP,OAAO,oBAAoB,WAAW;AAAA,IAC1C;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,QAAQ,CAAC,OAAO;AAAA;AAAA;AAAA,IAGhB,uBAAuB,CAAC,GAAG,OAAO;AAAA,MAC9B;AAAA,MACA,QAAQ;AAAA,MACR,MAAM;AAAA,IACV,CAAC;AAAA;AAAA,EACD,UAAU;AAAA,IACN,aAAa,CAAAA,UAAK;AA1N1B,UAAAD;AA0N6B,aAAAC,MAAK,SAAS,WAAW,IAC1C,cACED,MAAAC,MAAK,cAAL,gBAAAD,IAAgB,gBACdC,MAAK,SAAS,IAAI,WAAS,MAAM,WAAW,EAAE,KAAK,OAAO;AAAA;AAAA,IAClE,UAAU,YAAU,OAAO,OAAO,OAAO,IAAI,OAAK,EAAE,QAAQ,EAAE,KAAK,QAAQ,CAAC;AAAA,IAC5E,SAAS,SAAO,GAAG,IAAI,MAAM;AAAA,EAAgB,IAAI,QAAQ;AAAA,EAC7D;AAAA,EACA,eAAe;AAAA,IACX,cAAc,CAAC,GAAG,GAAG,QAAQ,uBAAuB,GAAG,GAAG,GAAG;AAAA,IAC7D,GAAG,6BAA6B,gBAAgB,CAAC,GAAG,GAAG,QAAQ;AAnOvE,UAAAD;AAqOY,UAAI,EAAE,SAAS,WAAW;AACtB,eAAO;AACX,YAAM,QAAQ,EAAE,QAAQ,eAAe,EAAE,OAAO,GAAG,GAAG,IAAI;AAC1D,aAAQ,iBAAiB,WAAW,UAC9BA,MAAA,uBAAG,UAAH,gBAAAA,IAAU,OAAO;AAAA;AAAA,QAEf;AAAA,UAGE,EAAE,EAAE,KAAK,gBAAgB,OAAO,OAAO,KAAK,EAAE,OAAO,QAAQ,GAAG;AAAA,QAC9D,CAAC,MAAM,IAAI,GAAG;AAAA,MAClB,CAAC,GAAG,EAAE,YAAY,KAAK,CAAC;AAAA,IACpC,CAAC;AAAA,EACL;AACJ,CAAC;;;AC5OD,IAAM,kBAAkB;AAAA,EACpB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AACO,IAAM,sBAAsB,cAAc;AAAA,EAC7C,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,MAAM;AAAA,IACF,IAAI;AAAA,MACA,OAAO;AAAA,MACP,OAAO,CAACI,SAAQ,QAAQ,IAAI,EAAE,KAAK,iBAAiBA,OAAM;AAAA,IAC9D;AAAA,IACA,QAAQ;AAAA,MACJ,OAAO;AAAA,MACP,WAAW,YAAU,OAAO,IAAI,OAAK,WAAW,GAAG,MAAM,IAAI,EAAE,OAAO,oBAAoB,CAAC,CAAC;AAAA,IAChG;AAAA,EACJ;AAAA,EACA,WAAW,CAAAA,YAAUA;AAAA,EACrB,UAAU;AAAA,IACN,aAAa,CAAAC,UAAK;AA5B1B,UAAAC;AA4B6B,6BAAgBD,MAAK,GAAG,WAAW,SAAOC,MAAAD,MAAK,QAAL,gBAAAC,IAAU,gBAAe,SAAS;AAAA;AAAA,EACrG;AAAA,EACA,eAAe;AAAA,IACX,OAAO,CAAC,GAAG,GAAG,QAAQ;AAClB,UAAI,EAAE,OAAO,KAAK,CAAC,OAAO,MAAM,UAAU,EAAE,OAAO,CAAC,CAAC;AAEjD,eAAO,gBAAgB,gCAAgC;AAC3D,YAAM,eAAe,eAAe,EAAE,IAAI,EAAE,IAAI,GAAG;AACnD,UAAI,wBAAwB;AACxB,eAAO;AAGX,aAAO,IAAI,EAAE,OAAO,aAAa,SAAS,IAAI,cAAY,IAAI,EAAE,KAAK,SAAS;AAAA,QAC1E,QAAQ,EAAE;AAAA,QACV,IAAI;AAAA,MACR,CAAC,CAAC,CAAC;AAAA,IACP;AAAA,IACA,GAAG,6BAA6B,SAAS,CAAC,GAAG,GAAG,QAAQ;AACpD,YAAM,eAAe,eAAe,EAAE,IAAI,GAAG,GAAG;AAChD,aAAQ,wBAAwB,WAAW,eACrC,aAAa,SAAS,UACpB,IAAI,EAAE,KAAK,SAAS,aAAa,SAAS,IAAI,aAAW;AAAA,QACrD,GAAG,EAAE;AAAA,QACL,IAAI;AAAA,MACR,EAAE,CAAC,IACD,IAAI,EAAE,KAAK,SAAS;AAAA,QAClB,GAAG,EAAE;AAAA,QACL,IAAI;AAAA,MACR,CAAC;AAAA,IACb,CAAC;AAAA,EACL;AACJ,CAAC;AA3DD,IAAAA;AA4DO,IAAM,YAAN,cAAwB,SAAS;AAAA,EAAjC;AAAA;AACH,4CAAmB,KAAK,OAAO,IAAI,mBAAmB;AACtD,0CAAiB,IAAI,KAAK,gBAAgB;AAC1C,0CAAiB,CAAC,MAAM,QAAQ,KAAK,GAAG,eAAe,MAAM,GAAG;AAChE,yCAAgB,CAAC,MAAM,QAAQ;AAC3B,WAAK,GAAG,cAAc,MAAM,GAAG;AAC/B,UAAI,YAAY,KAAK,MAAM;AAAA,IAC/B;AACA,sCAAa,QAAQ,KAAK,GAAG,UAAU,cAAYA,MAAA,KAAK,QAAL,gBAAAA,IAAU,eAAc,SAAS;AAYpF,qCAAY,KAAK,MAAM,OAAO,GAAG,EAAE;AACnC,wCAAe,WAAW,KAAK,WAAW,MAAM,IAC5C,OAAO,OAAO,KAAK,gBAAgB,KAAK,UAAU,IAAI,cAAc,KAChE,KAAK,UAAU,MACjB;AAAA;AAAA,EAfN,QAAQ,IAAI;AACR,QAAI,GAAG,kBAAkB,UAAU;AAC/B,SAAG,OAAO,GAAG,OAAO,KAAK,EAAE,CAAC;AAC5B;AAAA,IACJ;AACA,OAAG,KAAK,GAAG,OAAO,KAAK,EAAE,CAAC;AAC1B,OAAG,KAAK,mBAAmB,KAAK,cAAc,GAAG;AAAA,EACrD;AAAA,EACA,IAAI,KAAK;AACL,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA,EAMA,IAAI,MAAM;AACN,WAAO,KAAK,gBAAgB,KAAK,EAAE,SAAS,QAAQ;AAAA,EACxD;AAAA,EACA,WAAW;AACP,WAAO,KAAK,GAAG,SAAS;AAAA,EAC5B;AACJ;;;ACvFO,IAAM,sBAAsB,cAAc;AAAA,EAC7C,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,gBAAgB;AAAA,EAChB,MAAM;AAAA,IACF,OAAO;AAAA,MACH,WAAW,UAAQ,+BAA+B,IAAI,KAAK,uBAAuB,IAAI;AAAA,IAC1F;AAAA,EACJ;AAAA,EACA,WAAW,CAAAC,YAAU,OAAOA,YAAW,WAAW,EAAE,OAAO,oBAAoBA,OAAM,EAAE,IACjF,OAAOA,YAAW,aAAa,EAAE,OAAOA,QAAO,IAC3C,OAAOA,QAAO,UAAU,WACtB,EAAE,GAAGA,SAAQ,OAAO,oBAAoBA,QAAO,KAAK,EAAE,IACpDA;AAAA,EACd,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQA,MAAK,cACtB,uBAAuBA,MAAK,WAAW,IACrC,kBAAkBA,MAAK,MAAM,IAAI;AAAA,IACvC,QAAQ,UAAQ,qBAAqB,IAAI;AAAA,EAC7C;AAAA,EACA,eAAe;AAAA,IACX,OAAO,CAAC,GAAG,MAAM,mBAAmB,EAAE,OAAO,EAAE,KAAK,IAAI,IAClD,mBAAmB,EAAE,OAAO,EAAE,KAAK,IAAI,IACnC,SAAS,KAAK,SAAS,GAAG,CAAC;AAAA,IACrC,QAAQ,CAAC,OAAO,QAAQ,QAAQ,OAAO,WAAW,WAC9C,QACE,SAAS,KAAK,UAAU,IAAI,EAAE,SAAS,OAAO,KAAK,MAAM;AAAA,EACnE;AACJ,CAAC;AACM,IAAM,YAAN,cAAwB,SAAS;AAAA,EAAjC;AAAA;AACH,uCAAc,+BAA+B,KAAK,KAAK;AACvD,iDAAwB,KAAK,KAAK;AAClC,6CAAoB,mBAAmB,KAAK,qBAAqB;AACjE,4CAAmB,KAAK,KAAK,iBAAiB;AAC9C,uCAAc,gBAAgB,KAAK,MAAM,SAAS;AAClD,0CAAiB,UAAQ,gBAAgB,KAAK;AAC9C,sCAAa,KAAK,MAAM;AACxB,kCAAS;AAAA;AACb;;;AC1CA,IAAIC,qBAAwD,SAAU,SAAS,cAAc,OAAO;AAChG,MAAI,WAAW,UAAU,SAAS;AAClC,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,YAAQ,WAAW,aAAa,CAAC,EAAE,KAAK,SAAS,KAAK,IAAI,aAAa,CAAC,EAAE,KAAK,OAAO;AAAA,EAC1F;AACA,SAAO,WAAW,QAAQ;AAC9B;AACA,IAAIC,gBAA8C,SAAU,MAAM,cAAc,YAAY,WAAW,cAAc,mBAAmB;AACpI,WAAS,OAAO,GAAG;AAAE,QAAI,MAAM,UAAU,OAAO,MAAM,WAAY,OAAM,IAAI,UAAU,mBAAmB;AAAG,WAAO;AAAA,EAAG;AACtH,MAAI,OAAO,UAAU,MAAM,MAAM,SAAS,WAAW,QAAQ,SAAS,WAAW,QAAQ;AACzF,MAAI,SAAS,CAAC,gBAAgB,OAAO,UAAU,QAAQ,IAAI,OAAO,KAAK,YAAY;AACnF,MAAI,aAAa,iBAAiB,SAAS,OAAO,yBAAyB,QAAQ,UAAU,IAAI,IAAI,CAAC;AACtG,MAAI,GAAG,OAAO;AACd,WAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,KAAK;AAC7C,QAAI,UAAU,CAAC;AACf,aAAS,KAAK,UAAW,SAAQ,CAAC,IAAI,MAAM,WAAW,CAAC,IAAI,UAAU,CAAC;AACvE,aAAS,KAAK,UAAU,OAAQ,SAAQ,OAAO,CAAC,IAAI,UAAU,OAAO,CAAC;AACtE,YAAQ,iBAAiB,SAAU,GAAG;AAAE,UAAI,KAAM,OAAM,IAAI,UAAU,wDAAwD;AAAG,wBAAkB,KAAK,OAAO,KAAK,IAAI,CAAC;AAAA,IAAG;AAC5K,QAAI,UAAU,GAAG,WAAW,CAAC,GAAG,SAAS,aAAa,EAAE,KAAK,WAAW,KAAK,KAAK,WAAW,IAAI,IAAI,WAAW,GAAG,GAAG,OAAO;AAC7H,QAAI,SAAS,YAAY;AACrB,UAAI,WAAW,OAAQ;AACvB,UAAI,WAAW,QAAQ,OAAO,WAAW,SAAU,OAAM,IAAI,UAAU,iBAAiB;AACxF,UAAI,IAAI,OAAO,OAAO,GAAG,EAAG,YAAW,MAAM;AAC7C,UAAI,IAAI,OAAO,OAAO,GAAG,EAAG,YAAW,MAAM;AAC7C,UAAI,IAAI,OAAO,OAAO,IAAI,EAAG,cAAa,QAAQ,CAAC;AAAA,IACvD,WACS,IAAI,OAAO,MAAM,GAAG;AACzB,UAAI,SAAS,QAAS,cAAa,QAAQ,CAAC;AAAA,UACvC,YAAW,GAAG,IAAI;AAAA,IAC3B;AAAA,EACJ;AACA,MAAI,OAAQ,QAAO,eAAe,QAAQ,UAAU,MAAM,UAAU;AACpE,SAAO;AACX;AAOA,IAAM,kBAAkB;AAAA,EACpB,GAAG,mBAAmB,OAAO;AAAA,EAC7B;AACJ;AACO,IAAM,sBAAsB,cAAc;AAAA,EAC7C,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,gBAAgB;AAAA,EAChB,MAAM;AAAA,IACF,SAAS,CAAC;AAAA,IACV,UAAU;AAAA,MACN,OAAO;AAAA,MACP,OAAO,CAACC,SAAQ,QAAQ;AACpB,cAAM,WAAWA,QAAO,IAAI,YAAU,IAAI,EAAE,KAAK,iBAAiB,MAAM,CAAC;AACzE,YAAI,CAAC,IAAI,OAAO;AACZ,mBAAS,KAAK,CAAC,GAAG,MAAO,EAAE,YAAY,EAAE,YAAY,KAAK,CAAE;AAChE,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,WAAW,CAAAA,YAAW,QAAQA,OAAM,IAAI,EAAE,UAAUA,QAAO,IAAIA;AAAA,EAC/D,QAAQ,CAAC,OAAO,MAAM;AAClB,UAAM,kBAAkB,eAAe,KAAK;AAC5C,QAAI,gBAAgB,WAAW;AAC3B,aAAO,gBAAgB,CAAC;AAC5B,QAAI,gBAAgB,WAAW,MAAM,SAAS;AAC1C;AACJ,WAAO,EAAE,KAAK,SAAS;AAAA,MACnB,GAAG;AAAA,MACH,UAAU;AAAA,IACd,GAAG,EAAE,YAAY,KAAK,CAAC;AAAA,EAC3B;AAAA,EACA,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQ,iBAAiBA,MAAK,SAAS,IAAI,YAAU,OAAO,WAAW,CAAC;AAAA,IACrF,UAAU,SAAO;AACb,YAAM,SAAS,QAAQ,IAAI,QAAQ,YAAY;AAC/C,YAAM,mBAAmB,OAAO,QAAQ,MAAM,EAAE,IAAI,CAAC,CAAC,MAAM,MAAM,MAAM;AACpE,cAAM,iBAAiB,CAAC;AACxB,eAAO,QAAQ;AAAA;AAAA;AAAA,UAGf,aAAa,gBAAgB,YAAY,QAAQ;AAAA,SAAC;AAClD,cAAM,WAAW,iBAAiB,cAAc;AAGhD,cAAM,SAAS,OAAO,MAAM,OAAK,EAAE,WAAW,OAAO,CAAC,EAAE,MAAM,IAC1D,OAAO,CAAC,EAAE,SACR,UAAU,OAAO,CAAC,EAAE,IAAI;AAC9B,eAAO,GAAG,QAAQ,GAAG,IAAI,GAAG,WAAW,QAAQ,GAAG,UAAU,SAAS,MAAM,GAAG;AAAA,MAClF,CAAC;AACD,aAAO,iBAAiB,gBAAgB;AAAA,IAC5C;AAAA,IACA,SAAS,SAAO,IAAI;AAAA,IACpB,SAAS,SAAO,IAAI;AAAA,EACxB;AAAA,EACA,eAAe;AAAA,IACX,OAAO,CAAC,GAAG,GAAG,QAAQ;AAClB,UAAI,EAAE,YAAY,EAAE,SAAS;AAEzB,eAAO,SAAS,KAAK,YAAY,GAAG,CAAC;AAAA,MACzC;AACA,UAAI;AACJ,UAAI,EAAE,SAAS;AACX,YAAI,EAAE;AACF,iBAAO,SAAS,KAAK,yBAAyB,GAAG,CAAC;AACtD,yBAAiB,kBAAkB,EAAE,UAAU,EAAE,UAAU,GAAG;AAC9D,YAAI,0BAA0B;AAC1B,yBAAe,OAAO;AAAA,MAC9B;AAEI,yBAAiB,kBAAkB,EAAE,UAAU,EAAE,UAAU,GAAG;AAClE,UAAI,0BAA0B;AAC1B,eAAO;AACX,aAAO,IAAI,EAAE,OAAO,EAAE,WAAW,EAAE,UAC/B;AAAA,QACI,UAAU;AAAA,QACV,SAAS;AAAA,MACb,IACE,EAAE,UAAU,eAAe,CAAC;AAAA,IACtC;AAAA,IACA,GAAG,6BAA6B,SAAS,CAAC,GAAG,GAAG,QAAQ;AACpD,YAAM,WAAW,kBAAkB,EAAE,UAAU,CAAC,CAAC,GAAG,GAAG;AACvD,UAAI,oBAAoB;AACpB,eAAO;AACX,UAAI,SAAS,WAAW;AACpB,eAAO,SAAS,CAAC;AACrB,aAAO,IAAI,EAAE,OAAO,EAAE,UAAU,EAAE,UAAU,SAAS,KAAK,IAAI,EAAE,SAAS,CAAC;AAAA,IAC9E,CAAC;AAAA,EACL;AACJ,CAAC;AACD,IAAI,aAAa,MAAM;AAlIvB,MAAAC;AAmII,MAAI,cAAc;AAClB,MAAI,6BAA6B,CAAC;AAClC,MAAI;AACJ,SAAOA,MAAA,cAAwB,YAAY;AAAA,IAApC;AAAA;AAOH,sCAAWJ,mBAAkB,MAAM,0BAA0B,GAAG,KAAK,SAAS,WAAW;AACzF,uCAAY,KAAK,SAAS,WAAW,KACjC,KAAK,SAAS,CAAC,EAAE,QAAQ,KAAK,KAC9B,KAAK,SAAS,CAAC,EAAE,QAAQ,IAAI;AACjC,0CAAe,KAAK,SAAS,OAAO,CAAC,MAAM,EAAE,QAAQ,MAAM,CAAC;AAC5D,0CAAe,KAAK,aAAa;AACjC,8CAAmB,KAAK,eAAe,mBAAmB,KAAK,YAAY,IAAI;AAC/E,wCAAa,KAAK,UAAU,UACtB,KAAK,YAAY,YACb,KAAK,SAAS,IAAI,YAAU,OAAO,kBAAkB,EAAE,KAAK,KAAK;AAC3E,4CAAiB,CAAC,MAAM,QAAQ,KAAK,SAAS,KAAK,OAAK,EAAE,eAAe,MAAM,GAAG,CAAC;AACnF,2CAAgB,CAAC,MAAM,QAAQ;AAC3B,cAAM,SAAS,CAAC;AAChB,iBAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAAK;AAC3C,cAAI,WAAW;AACf,eAAK,SAAS,CAAC,EAAE,cAAc,MAAM,GAAG;AACxC,cAAI,CAAC,IAAI,SAAS;AACd,mBAAO,IAAI,aAAa,KAAK,GAAG,IAAI,UAAU,EAAE,YAAY;AAChE,iBAAO,KAAK,IAAI,UAAU,EAAE,KAAK;AAAA,QACrC;AACA,YAAI,MAAM,EAAE,MAAM,SAAS,OAAO,CAAC;AAAA,MACvC;AAAA;AAAA,IACA,QAAQ,IAAI;AACR,UAAI,CAAC,KAAK;AAAA;AAAA,MAGL,KAAK,aAAa,WAAW,KAAK,SAAS,UACxC,KAAK,SAAS,WAAW;AAC7B,eAAO,KAAK,uBAAuB,EAAE;AAEzC,YAAM,YAAY,KAAK,aAAa,KAAK,OAAO,CAAC,KAAK,YAAY,MAAM,yBAAyB,SAAS,IAAI,GAAG,KAAK,aAAa,SAAS,WAAW,gBAAgB,MAAM;AAC7K,YAAM,QAAQ,KAAK,aAAa;AAChC,YAAM,WAAW,OAAO,KAAK,KAAK;AAClC,SAAG,MAAM,UAAU,SAAS,KAAK,MAAM;AACnC,mBAAW,KAAK,OAAO;AACnB,gBAAM,IAAI,MAAM,CAAC;AACjB,gBAAM,gBAAgB,MAAM,YAAY,YAAY,QAAQ,CAAC;AAC7D,aAAG,KAAK,GAAG,aAAa,YAAY,MAAM,OAAO,IAAI,GAAG,OAAO,CAAC,CAAC,EAAE;AAAA,QACvE;AACA,eAAO;AAAA,MACX,CAAC;AACD,UAAI,GAAG,kBAAkB,UAAU;AAC/B,WAAG,OAAO,KAAK;AACf;AAAA,MACJ;AACA,YAAM,WAAW,iBAAiB,KAAK,aAAa,SAAS,WACzD,SAAS,IAAI,OAAK,mBAAmB,EAAE,MAAM,GAAG,EAAE,CAAC,CAAC,IAClD,QAAQ;AACd,SAAG,KAAK;AAAA,aACP,KAAK,UAAU,QAAQ,CAAC;AAAA,WAC1B,SAAS;AAAA,iBACH,KAAK,UAAU,KAAK,aAAa,IAAI,CAAC;AAAA,GACpD;AAAA,IACK;AAAA,IACA,uBAAuB,IAAI;AACvB,UAAI,GAAG,kBAAkB,SAAS;AAC9B,WAAG,MAAM,UAAU,IAAI;AACvB,aAAK,SAAS,QAAQ,YAAU,GAC3B,KAAK,kBAAkB,EACvB,KAAK,GAAG,OAAO,MAAM,CAAC,EACtB,GAAG,mBAAmB,MAAM,GAAG,OAAO,wDAAwD,CAAC,EAC/F,KAAK,oCAAoC,CAAC;AAC/C,WAAG,KAAK,sCAAsC;AAAA,MAClD,OACK;AACD,aAAK,SAAS,QAAQ,YAAU,GAAG,GAAG,GAAG,GAAG,OAAO,MAAM,CAAC,IAAI,MAAM,GAAG,OAAO,IAAI,CAAC,CAAC;AACpF,WAAG,OAAO,KAAK;AAAA,MACnB;AAAA,IACJ;AAAA,IACA,WAAW;AACP,aAAO,KAAK,SAAS,OAAO,CAAC,QAAQ,WAAW,OAAO,IAAI,OAAO,SAAS,CAAC,GAAG,KAAK,EAAE,SAAS,QAAQ,GAAG;AAAA,IAC9G;AAAA,IACA,IAAI,qBAAqB;AAGrB,aAAO,KAAK,YAAY,YAAY,MAAM;AAAA,IAC9C;AAAA,IACA,eAAe;AACX,UAAI,KAAK,SAAS,SAAS;AACvB,eAAO;AACX,UAAI,KAAK,aAAa,WAAW,KAAK,SAAS,QAAQ;AACnD,cAAMK,SAAQ,UAAU,KAAK,cAAc,CAAC,GAAG,SAAS;AAAA,UACpD,GAAG,KAAK,eAAe;AAAA,UACvB;AAAA,QACJ,CAAC;AACD,eAAO;AAAA,UACH,MAAM,CAAC;AAAA,UACP,MAAM;AAAA,UACN,OAAAA;AAAA,QACJ;AAAA,MACJ;AACA,YAAM,mBAAmB,CAAC;AAC1B,eAAS,SAAS,GAAG,SAAS,KAAK,SAAS,SAAS,GAAG,UAAU;AAC9D,cAAM,IAAI,KAAK,SAAS,MAAM;AAC9B,iBAAS,SAAS,SAAS,GAAG,SAAS,KAAK,SAAS,QAAQ,UAAU;AACnE,gBAAM,IAAI,KAAK,SAAS,MAAM;AAC9B,gBAAM,SAAS,mBAAmB,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;AACjD,cAAI,EAAE,kBAAkB;AACpB;AACJ,qBAAW,EAAE,MAAAC,OAAM,MAAAC,OAAM,SAAS,KAAK,OAAO,MAAM;AAChD,gBAAI,CAAC,QAAQA,OAAM,iBAAiB;AAChC;AACJ,kBAAM,wBAAwB,GAAGD,KAAI,GAAGC,KAAI;AAC5C,gBAAI;AACJ,gBAAI;AACJ,gBAAIA,UAAS,UAAU;AACnB,4BAAc,IAAI,SAAS,EAAE,MAAM;AACnC,4BAAc,IAAI,SAAS,EAAE,MAAM;AAAA,YACvC,WACSA,UAAS,QAAQ;AACtB,4BAAc,SAAS,EAAE;AACzB,4BAAc,SAAS,EAAE;AAAA,YAC7B,OACK;AACD,qBAAO,mBAAmB,qDAAqDA,KAAI,GAAG;AAAA,YAC1F;AACA,gBAAI,CAAC,iBAAiB,qBAAqB,GAAG;AAC1C,+BAAiB,qBAAqB,IAAI;AAAA,gBACtC,CAAC,WAAW,GAAG,CAAC,CAAC;AAAA,gBACjB,CAAC,WAAW,GAAG,CAAC,CAAC;AAAA,cACrB;AACA;AAAA,YACJ;AACA,kBAAMF,SAAQ,iBAAiB,qBAAqB;AACpD,gBAAI,CAAC,QAAQ,aAAaA,MAAK;AAC3B,cAAAA,OAAM,WAAW,IAAI,CAAC,CAAC;AAAA,qBAClB,CAACA,OAAM,WAAW,EAAE,SAAS,CAAC;AACnC,cAAAA,OAAM,WAAW,EAAE,KAAK,CAAC;AAC7B,gBAAI,CAAC,QAAQ,aAAaA,MAAK;AAC3B,cAAAA,OAAM,WAAW,IAAI,CAAC,CAAC;AAAA,qBAClB,CAACA,OAAM,WAAW,EAAE,SAAS,CAAC;AACnC,cAAAA,OAAM,WAAW,EAAE,KAAK,CAAC;AAAA,UACjC;AAAA,QACJ;AAAA,MACJ;AACA,YAAM,wBAAwB,UAAU,gBAAgB,EACnD,KAAK,CAAC,GAAG,MAAM,OAAO,KAAK,EAAE,CAAC,CAAC,EAAE,SAAS,OAAO,KAAK,EAAE,CAAC,CAAC,EAAE,MAAM,EAClE,GAAG,EAAE;AACV,UAAI,CAAC;AACD,eAAO;AACX,YAAM,CAAC,WAAW,SAAS,IAAI;AAC/B,YAAM,CAAC,MAAM,IAAI,IAAI,qBAAqB,SAAS;AACnD,UAAI,kBAAkB,CAAC,GAAG,KAAK,QAAQ;AACvC,YAAM,QAAQ,UAAU,WAAW,CAAC,GAAG,iBAAiB;AACpD,cAAM,iBAAiB,CAAC;AACxB,0BAAkB,gBAAgB,OAAO,OAAK,CAAC,aAAa,SAAS,CAAC,CAAC;AACvE,mBAAW,UAAU,cAAc;AAC/B,gBAAM,SAAS,kBAAkB,MAAM,MAAM,MAAM;AAGnD,cAAI,WAAW;AACX,mBAAO,CAAC,GAAG,IAAI;AACnB,yBAAe,KAAK,MAAM;AAAA,QAC9B;AACA,cAAM,WAAW,eAAe,WAAW,IACvC,eAAe,CAAC,IACd,KAAK,EAAE,KAAK,SAAS,cAAc;AACzC,eAAO,OAAO,KAAK,gBAAgB,SAAS,cAAc;AAC1D,eAAO,CAAC,GAAG,QAAQ;AAAA,MACvB,CAAC;AACD,UAAI,gBAAgB,QAAQ;AACxB,cAAM,UAAU,KAAK,EAAE,KAAK,SAAS,iBAAiB;AAAA,UAClD,YAAY;AAAA,QAChB,CAAC;AACD,eAAO,OAAO,KAAK,gBAAgB,MAAM,QAAQ,cAAc;AAAA,MACnE;AACA,aAAO;AAAA,QACH;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ,IAlLI,MAAO;AACH,UAAM,YAAY,OAAO,WAAW,cAAc,OAAO,WAAW,OAAO,OAAO,YAAY,OAAO,QAAQ,KAAK,IAAI,IAAI;AAC1H,+BAA2B,CAAC,MAAM;AAClC,IAAAJ,cAAaG,KAAM,MAAM,0BAA0B,EAAE,MAAM,UAAU,MAAM,gBAAgB,QAAQ,OAAO,SAAS,OAAO,QAAQ,EAAE,KAAK,SAAO,kBAAkB,KAAK,KAAK,SAAO,IAAI,aAAa,GAAG,UAAU,UAAU,GAAG,MAAM,0BAA0B;AAC9P,QAAI,UAAW,QAAO,eAAeA,KAAM,OAAO,UAAU,EAAE,YAAY,MAAM,cAAc,MAAM,UAAU,MAAM,OAAO,UAAU,CAAC;AAAA,EAC1I,MANGA;AAoLX,GAAG;AAEH,IAAM,qBAAqB,CAAC,kBAAkB;AAAA,EAC1C,MAAM,aAAa;AAAA,EACnB,MAAM,aAAa;AAAA,EACnB,OAAO,UAAU,aAAa,OAAO,CAAC,GAAGI,UAAS;AAAA,IAC9C;AAAA,IACAA,UAAS,OAAOA,QACVA,MAAK,QAAQ,OAAO,KAAKA,MAAK,mBAAmBA,MAAK,mBAClDA,MAAK;AAAA,EACnB,CAAC;AACL;AACA,IAAM,mBAAmB,CAAC,iBAAiB;AACvC,MAAI,aAAa,WAAW;AACxB,WAAO;AACX,MAAI,aAAa,WAAW;AACxB,WAAO,aAAa,CAAC;AACzB,MAAK,aAAa,WAAW,KACzB,aAAa,CAAC,MAAM,WACpB,aAAa,CAAC,MAAM,UACnB,aAAa,CAAC,MAAM,UAAU,aAAa,CAAC,MAAM;AACnD,WAAO;AACX,MAAI,cAAc;AAClB,WAAS,IAAI,GAAG,IAAI,aAAa,SAAS,GAAG,KAAK;AAC9C,mBAAe,aAAa,CAAC;AAC7B,QAAI,IAAI,aAAa,SAAS;AAC1B,qBAAe;AAAA,EACvB;AACA,iBAAe,OAAO,aAAa,aAAa,SAAS,CAAC,CAAC;AAC3D,SAAO;AACX;AACO,IAAM,oBAAoB,CAAC,GAAG,GAAG,QAAQ;AAI5C,QAAM,aAAa,EAAE,IAAI,MAAM,CAAC,CAAC;AACjC,WAAS,SAAS,GAAG,SAAS,EAAE,QAAQ,UAAU;AAC9C,QAAI,gBAAgB,CAAC;AACrB,aAAS,SAAS,GAAG,SAAS,EAAE,QAAQ,UAAU;AAC9C,UAAI,WAAW,MAAM,MAAM,MAAM;AAG7B;AAAA,MACJ;AACA,UAAI,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,CAAC,GAAG;AAE7B,mBAAW,MAAM,IAAI;AACrB,wBAAgB,CAAC;AACjB;AAAA,MACJ;AACA,YAAM,qBAAqB,eAAe,EAAE,MAAM,GAAG,EAAE,MAAM,GAAG,GAAG;AACnE,UAAI,8BAA8B,UAAU;AAGxC;AAAA,MACJ;AACA,UAAI,mBAAmB,OAAO,EAAE,MAAM,CAAC,GAAG;AAItC,mBAAW,MAAM,EAAE,KAAK,EAAE,MAAM,CAAC;AACjC,wBAAgB,CAAC;AACjB;AAAA,MACJ;AACA,UAAI,mBAAmB,OAAO,EAAE,MAAM,CAAC,GAAG;AAItC,mBAAW,MAAM,IAAI;AAAA,MACzB,OACK;AAID,sBAAc,MAAM,IAAI;AAAA,MAC5B;AAAA,IACJ;AACA,eAAW,UAAU,eAAe;AAEhC,iBAAW,MAAM,EAAE,MAAM,IAAI,cAAc,MAAM;AAAA,IACrD;AAAA,EACJ;AAIA,QAAM,iBAAiB,WAAW;AAAA;AAAA,IAElC,CAAC,OAAO,OAAM,+BAAO,QAAQ,YAAU,OAAO,cAAa,EAAE,CAAC;AAAA,EAAC;AAC/D,SAAO,eAAe,WAAW,IAC7B,SAAS,KAAK,SAAS,GAAG,CAAC,IACzB;AACV;AACO,IAAM,iBAAiB,CAAC,EAAE,UAAU,QAAQ,MAAM;AACrD,MAAI,SAAS,SAAS;AAClB,WAAO;AACX,QAAM,oBAAoB,SAAS,IAAI,MAAM,IAAI;AACjD,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,aAAS,IAAI,IAAI,GAAG,IAAI,SAAS,UAAU,kBAAkB,CAAC,KAAK,kBAAkB,CAAC,GAAG,KAAK;AAC1F,UAAI,SAAS,CAAC,EAAE,OAAO,SAAS,CAAC,CAAC,GAAG;AAIjC,0BAAkB,CAAC,IAAI;AACvB;AAAA,MACJ;AACA,YAAM,eAAe,mBAAmB,SAAS,CAAC,EAAE,IAAI,SAAS,CAAC,EAAE,IAAI,SAAS,CAAC,EAAE,CAAC;AACrF,UAAI,wBAAwB;AACxB;AACJ,UAAI,aAAa,OAAO,SAAS,CAAC,EAAE,EAAE,GAAG;AAErC,0BAAkB,CAAC,IAAI,CAAC,CAAC;AAAA,MAC7B,WACS,aAAa,OAAO,SAAS,CAAC,EAAE,EAAE;AACvC,0BAAkB,CAAC,IAAI;AAAA,IAC/B;AAAA,EACJ;AACA,SAAO,SAAS,OAAO,CAAC,GAAG,MAAM,kBAAkB,CAAC,CAAC;AACzD;AACA,IAAM,oBAAoB;AAAA,EACtB,QAAQ;AAAA,EACR,MAAM;AACV;AACA,IAAM,uBAAuB,CAAC,QAAQ;AAClC,QAAM,gBAAgB,IAAI,YAAY,GAAG;AACzC,QAAM,aAAa,KAAK,MAAM,IAAI,MAAM,GAAG,gBAAgB,CAAC,CAAC;AAC7D,QAAM,aAAa,IAAI,MAAM,gBAAgB,CAAC;AAC9C,SAAO,CAAC,YAAY,UAAU;AAClC;AACO,IAAM,oBAAoB,CAAC,kBAAkB,MAAM,WAAW,OAAO,UAAU,CAAC,UAAU,OAAO,QAAQ;AAG5G,MAAI,aAAa,YACb,MAAM,WAAW,YACjB,KAAK,SAAS,IAAI,KAAK;AACvB,WAAO;AAGX,OAAK,qBAAqB,YACrB,aAAa,YAAY,IAAI,KAAK,WAAW,KAAK,WACnD,IAAI,KAAK,WAAW,KAAK,UACzB,IAAI,KAAK,MAAM,CAAC,SAAS,MAAM,YAAY,KAAK,CAAC,CAAC;AAClD,WAAO;AACX,SAAO;AACX,GAAG;AAAA,EACC,iBAAiB,CAAAA,UAAQA,MAAK,SAAS,WAAW,KAC9CA,MAAK,SAAS,YACdA,MAAK,SAAS;AACtB,CAAC;;;ACxcM,IAAM,qBAAqB,cAAc;AAAA,EAC5C,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,MAAM;AAAA,IACF,MAAM;AAAA,MACF,mBAAmB;AAAA,MACnB,WAAW,CAAAC,YAAUA,mBAAkB,OACnCA,QAAO,YAAY,IACjB,uBAAuBA,OAAM;AAAA,IACvC;AAAA,EACJ;AAAA,EACA,WAAW,CAAAA,YAAUA;AAAA,EACrB,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQ,UAAUA,MAAK,IAAI;AAAA,IACxC,SAAS,CAAC,EAAE,UAAU,OAAO,MAAM,GAAG,aAAa,SAAS,8BAA8B,QAAQ,oCAAoC,WAAW,QAAQ,SAAS,MAAM,GAAG;AAAA,EAC/K;AAAA,EACA,eAAe;AAAA,IACX,MAAM,CAAC,GAAG,MAAM,SAAS,KAAK,QAAQ,GAAG,CAAC;AAAA,IAC1C,GAAG,6BAA6B,QAAQ,CAAC,GAAG,MAAM,EAAE,OAAO,EAAE,IAAI,IAAI,IAAK,SAAS,KAAK,iBAAiB,GAAG,EAAE,QAAQ,cAAc,IAChI,EAAE,SAAS,KAAK,iBAAe,CAAC,YAAY,OAAO,EAAE,IAAI,CAAC,IACxD,CAAC,CAAE;AAAA,EACb;AACJ,CAAC;AACM,IAAM,WAAN,cAAuB,SAAS;AAAA,EAAhC;AAAA;AACH,yCAAgB,KAAK,KAAK;AAC1B,2CAAkB,OAAO,KAAK,SAAS,YAAY,KAAK,gBAAgB,OACpE,KAAK,UAAU,KAAK,aAAa,IAC/B,KAAK;AACX,uCAAc,gBAAgB,KAAK,IAAI;AACvC,6CAAoB,qBAAqB,KAAK,MAAM,KAAK,eAAe;AACxE,4CAAmB,qBAAqB,KAAK,MAAM,KAAK,iBAAiB,SAAS;AAClF,sCAAa,UAAU,KAAK,IAAI;AAChC,kCAAS,SAAS,KAAK,IAAI;AAC3B,0CAAiB,KAAK,gBAAgB,OAClC,UAAQ,gBAAgB,QAAQ,KAAK,YAAY,MAAM,KAAK,gBAC1D,UAAQ,SAAS,KAAK;AAAA;AAChC;AACA,IAAM,uBAAuB,CAAC,MAAM,iBAAiB,YAAY;AAC7D,MAAI,gBAAgB,MAAM;AACtB,UAAM,YAAY,kDAAkD,eAAe;AACnF,WAAO,UAAU,KAAK,SAAS,MAAM;AAAA,EACzC;AACA,SAAO,QAAQ,UAAU,MAAM,GAAG,MAAM,eAAe;AAC3D;;;AC3CO,IAAM,sBAAsB,cAAc;AAAA,EAC7C,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,oBAAoB;AAAA,EACpB,MAAM;AAAA,IACF,WAAW;AAAA,MACP,OAAO;AAAA,MACP,OAAO,CAACC,SAAQ,QAAQ;AACpB,cAAM,MAAM,IAAI,EAAE,OAAOA,OAAM;AAC/B,YAAI,CAAC,IAAI,QAAQ,IAAI,EAAE,SAAS,WAAW,GAAG;AAC1C,iBAAO,gBAAgB,+BAA+B,IAAI,UAAU,CAAC;AAAA,QACzE;AACA,cAAM,qBAAqB,IAAI,SAAS,OAAO,CAAC,MAAM,EAAE,QAAQ,MAAM,CAAC;AACvE,YAAI,mBAAmB,QAAQ;AAC3B,iBAAO,gBAAgB,6BAA6B,mBAAmB,IAAI,OAAK,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC;AAAA,QACvG;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,IACA,OAAO;AAAA,MACH,OAAO;AAAA,MACP,OAAO,CAACA,SAAQ,QAAQ,IAAI,EAAE,OAAOA,OAAM;AAAA,IAC/C;AAAA,EACJ;AAAA,EACA,WAAW,CAAAA,YAAUA;AAAA,EACrB,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQ,IAAIA,MAAK,UAAU,UAAU,MAAMA,MAAK,MAAM,WAAW;AAAA,EAClF;AAAA,EACA,eAAe;AAAA,IACX,OAAO,CAAC,GAAG,GAAG,QAAQ;AAClB,UAAI,EAAE,UAAU,OAAO,EAAE,SAAS,GAAG;AACjC,cAAM,oBAAoB,eAAe,EAAE,OAAO,EAAE,OAAO,GAAG;AAC9D,cAAM,QAAQ,6BAA6B,WACvC,IAAI,EAAE,SAAS,MAAM,MACnB;AACN,eAAO,IAAI,EAAE,KAAK,SAAS,EAAE,WAAW,EAAE,WAAW,MAAM,CAAC;AAAA,MAChE;AAEA,UAAI,EAAE,UAAU,QAAQ,EAAE,SAAS,KAAK,EAAE,MAAM,SAAS,EAAE,KAAK;AAC5D,eAAO;AAEX,UAAI,EAAE,UAAU,QAAQ,EAAE,SAAS,KAAK,EAAE,MAAM,SAAS,EAAE,KAAK;AAC5D,eAAO;AAEX,aAAO;AAAA,IACX;AAAA,EACJ;AACJ,CAAC;AACM,IAAM,YAAN,cAAwB,eAAe;AAAA,EAAvC;AAAA;AACH,wCAAe,KAAK,EAAE,SAAS,OAAO;AACtC,sCAAa,IAAI,KAAK,UAAU,UAAU,MAAM,KAAK,MAAM,UAAU;AACrE,0CAAiB,CAAC,MAAM,QAAQ,2BAA2B,IAAI,EAAE,MAAM,WAAS;AAC5E,UAAI,KAAK,UAAU,eAAe,MAAM,CAAC,GAAG,GAAG,GAAG;AAE9C,mCAAK,KAAK,KAAK,MAAM,CAAC;AACtB,cAAM,UAAU,KAAK,MAAM,eAAe,MAAM,CAAC,GAAG,GAAG;AACvD,mCAAK,KAAK;AACV,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX,CAAC;AACD,yCAAgB,CAAC,MAAM,QAAQ,2BAA2B,IAAI,EAAE,QAAQ,WAAS;AAC7E,UAAI,KAAK,UAAU,eAAe,MAAM,CAAC,GAAG,GAAG,GAAG;AAC9C,YAAI,KAAK,KAAK,MAAM,CAAC,CAAC;AACtB,aAAK,MAAM,cAAc,MAAM,CAAC,GAAG,GAAG;AACtC,YAAI,KAAK,IAAI;AAAA,MACjB;AAAA,IACJ,CAAC;AAAA;AAAA,EACD,WAAW,QAAQ,KAAK;AACpB,QAAI,KAAK,KAAK,KAAK,SAAS;AAC5B,UAAM,SAAS,MAAM,WAAW,QAAQ,GAAG;AAC3C,QAAI,KAAK,IAAI;AACb,WAAO;AAAA,EACX;AAAA,EACA,UAAU;AAAA,EAEV;AACJ;AACO,IAAM,+BAA+B,CAAC,SAAS,cAAc,KAAK,KAAK,IAAI,CAAC;AAC5E,IAAM,iCAAiC,CAAC,gBAAgB,2BAA2B,WAAW;;;AChF9F,IAAM,iBAAiB,CAAC,GAAG,GAAG,QAAQ;AACzC,MAAI,EAAE,QAAQ,EAAE;AACZ,WAAO;AACX,QAAM,MAAM,EAAE;AACd,MAAI,QAAQ,eAAe,EAAE,OAAO,EAAE,OAAO,GAAG;AAChD,QAAM,OAAO,EAAE,YAAY,EAAE,WAAW,aAAa;AACrD,MAAI,iBAAiB,UAAU;AAC3B,QAAI,SAAS;AACT,cAAQ,IAAI,EAAE,SAAS,MAAM;AAAA;AAE7B,aAAO,MAAM,cAAc,EAAE,WAAW;AAAA,EAChD;AACA,MAAI,SAAS,YAAY;AACrB,WAAO,IAAI,EAAE,KAAK,YAAY;AAAA,MAC1B;AAAA,MACA;AAAA,IACJ,CAAC;AAAA,EACL;AACA,QAAM,sBAAsB,EAAE,WAAW,IACrC,EAAE,WAAW,IACT,EAAE,YAAY,EAAE,UACZ,EAAE,UACA,gBAAgB,0CAA0C,UAAU,EAAE,OAAO,CAAC,MAAM,UAAU,EAAE,OAAO,CAAC,EAAE,IAC9G,EAAE,UACN,EAAE,WAAW,IAAI,EAAE,UACf;AACV,SAAO,IAAI,EAAE,KAAK,YAAY;AAAA,IAC1B;AAAA,IACA;AAAA;AAAA,IAEA,SAAS;AAAA,EACb,CAAC;AACL;AACO,IAAM,WAAN,cAAuB,eAAe;AAAA,EAAtC;AAAA;AACH,oCAAW,KAAK,SAAS;AACzB,wCAAe,KAAK,EAAE,SAAS,OAAO;AACtC,yCAAgB,uBAAuB,KAAK,GAAG;AAC/C,uCAAc,OAAO,KAAK,QAAQ,WAAW,KAAK,MAAM,KAAK;AAO7D,8CAAqB;AAAA,MACjB,UAAQ;AACJ,aAAK,KAAK,GAAG,IAAI,KAAK;AACtB,eAAO;AAAA,MACX;AAAA,IACJ;AACA,uDAA8B,oBAAoB,KAAK,kBAAkB;AAIzE,0CAAiB,CAAC,MAAM,QAAQ;AAC5B,UAAI,KAAK,OAAO,MAAM;AAElB,mCAAK,KAAK,KAAK,KAAK;AACpB,cAAM,UAAU,KAAK,MAAM,eAAe,KAAK,KAAK,GAAG,GAAG,GAAG;AAC7D,mCAAK,KAAK;AACV,eAAO;AAAA,MACX;AACA,aAAO,CAAC,KAAK;AAAA,IACjB;AACA,yCAAgB,CAAC,MAAM,QAAQ;AAC3B,UAAI,KAAK,OAAO,MAAM;AAClB,YAAI,KAAK,KAAK,KAAK,GAAG;AACtB,aAAK,MAAM,cAAc,KAAK,KAAK,GAAG,GAAG,GAAG;AAC5C,YAAI,KAAK,IAAI;AAAA,MACjB,WACS,KAAK,QAAQ,UAAU;AAC5B,YAAI,MAAM,KAAK,YAAY;AAAA,eACtB,KAAK,QAAQ,UAAU,KAAK,KAAK,WAAW;AACjD,YAAI,YAAY,KAAK,kBAAkB;AAAA,IAC/C;AAAA;AAAA,EApCA,WAAW,QAAQ,KAAK;AACpB,QAAI,KAAK,KAAK,KAAK,GAAG;AACtB,UAAM,SAAS,MAAM,WAAW,QAAQ,GAAG;AAC3C,QAAI,KAAK,IAAI;AACb,WAAO;AAAA,EACX;AAAA,EAQA,aAAa;AACT,WAAO,aAAa;AAAA,EACxB;AAAA,EAsBA,QAAQ,IAAI;AACR,OAAG,GAAG,GAAG,KAAK,aAAa,YAAY,MAAM,GAAG,YAAY,KAAK,eAAe,OAAO,GAAG,KAAK,KAAK,GAAG,CAAC,IAAI,KAAK,KAAK,CAAC;AACvH,QAAI,KAAK,QAAQ,UAAU,GAAG;AAC1B,SAAG,KAAK,MAAM;AACV,YAAI,GAAG,kBAAkB;AACrB,iBAAO,GAAG,KAAK,aAAa,KAAK,oBAAoB,GAAG;AAAA;AAExD,iBAAO,GAAG,OAAO,KAAK;AAAA,MAC9B,CAAC;AAAA,IACL,WACS,GAAG,kBAAkB,WAAW,aAAa,MAAM;AACxD,SAAG,KAAK,MAAM,GAAG,KAAK,mBAAmB,KAAK,2BAA2B,GAAG,CAAC;AAAA,IACjF;AACA,QAAI,GAAG,kBAAkB;AACrB,SAAG,OAAO,IAAI;AAAA,EACtB;AACJ;;;AC7FO,IAAM,yBAAyB,cAAc;AAAA,EAChD,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,oBAAoB;AAAA,EACpB,MAAM;AAAA,IACF,KAAK,CAAC;AAAA,IACN,OAAO;AAAA,MACH,OAAO;AAAA,MACP,OAAO,CAACC,SAAQ,QAAQ,IAAI,EAAE,OAAOA,OAAM;AAAA,IAC/C;AAAA,IACA,SAAS;AAAA,MACL,mBAAmB;AAAA,IACvB;AAAA,EACJ;AAAA,EACA,WAAW,CAAAA,YAAUA;AAAA,EACrB,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQ,GAAGA,MAAK,WAAW,MAAMA,MAAK,MAAM,WAAW;AAAA,EACxE;AAAA,EACA,eAAe;AAAA,IACX,UAAU;AAAA,EACd;AACJ,CAAC;AACM,IAAM,eAAN,cAA2B,SAAS;AAAA,EAApC;AAAA;AACH,sCAAa,GAAG,KAAK,WAAW,MAAM,KAAK,MAAM,UAAU;AAAA;AAC/D;;;ACxBO,IAAM,eAAN,cAA2B,SAAS;AAAA,EAApC;AAAA;AACH,sCAAa,GAAG,KAAK,WAAW,KAAK,KAAK,MAAM,UAAU;AAC1D,wCAAe,OAAO,OAAO;AAAA,MACzB,MAAM;AAAA,MACN,yBAAyB,KAAK,MAAM;AAAA,MACpC,cAAc,CAAC,KAAK,GAAG;AAAA,IAC3B,CAAC;AACD,gDAAuB,oBAAoB,KAAK,YAAY;AAAA;AAChE;AACO,IAAM,yBAAyB,cAAc;AAAA,EAChD,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,oBAAoB;AAAA,EACpB,MAAM;AAAA,IACF,KAAK,CAAC;AAAA,IACN,OAAO;AAAA,MACH,OAAO;AAAA,MACP,OAAO,CAACC,SAAQ,QAAQ,IAAI,EAAE,OAAOA,OAAM;AAAA,IAC/C;AAAA,EACJ;AAAA,EACA,WAAW,CAAAA,YAAUA;AAAA,EACrB,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQ,GAAGA,MAAK,WAAW,KAAKA,MAAK,MAAM,WAAW;AAAA,IACnE,UAAU,SAAO,IAAI;AAAA,IACrB,QAAQ,MAAM;AAAA,EAClB;AAAA,EACA,eAAe;AAAA,IACX,UAAU;AAAA,IACV,UAAU;AAAA,EACd;AACJ,CAAC;;;AC3BD,IAAM,mCAAmC;AAAA,EACrC,OAAO;AAAA,EACP,OAAO,CAACC,SAAQ,QAAQA,QAAO,WAAW;AAAA;AAAA;AAAA,IAGtC;AAAA,MACEA,QAAO,IAAI,aAAW,IAAI,EAAE,OAAO,OAAO,CAAC;AACrD;AACO,IAAM,yBAAyB,cAAc;AAAA,EAChD,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,gBAAgB;AAAA,EAChB,MAAM;AAAA,IACF,QAAQ;AAAA,IACR,WAAW;AAAA,IACX,UAAU;AAAA,MACN,OAAO;AAAA,MACP,OAAO,CAACA,SAAQ,QAAQ,IAAI,EAAE,OAAOA,SAAQ,GAAG;AAAA,IACpD;AAAA,IACA,mBAAmB;AAAA;AAAA;AAAA;AAAA,MAIf,OAAO,SAAQ,QAAQ,IAAI,SAAY;AAAA,IAC3C;AAAA,IACA,SAAS;AAAA,EACb;AAAA,EACA,WAAW,CAAAA,YAAU;AAhCzB,QAAAC,KAAAC;AAiCQ,QAAI,OAAOF,YAAW;AAClB,aAAO,EAAE,UAAUA,QAAO;AAC9B,QAAI,cAAcA,WACd,YAAYA,WACZ,eAAeA,WACf,aAAaA,WACb,uBAAuBA,SAAQ;AAC/B,WAAIC,MAAAD,QAAO,YAAP,gBAAAC,IAAgB,QAAQ;AACxB,YAAI,CAACD,QAAO;AACR,iBAAO,gBAAgB,6BAA6B;AACxD,aAAIE,MAAAF,QAAO,cAAP,gBAAAE,IAAkB;AAClB,iBAAO,gBAAgB,+BAA+B;AAAA,MAC9D;AACA,UAAIF,QAAO,qBAAqB,CAACA,QAAO,UAAU;AAC9C,eAAO,gBAAgB,mEAAmE;AAAA,MAC9F;AACA,aAAOA;AAAA,IACX;AACA,WAAO,EAAE,UAAUA,QAAO;AAAA,EAC9B;AAAA,EACA,QAAQ,CAAC,KAAK,MAAM;AArDxB,QAAAC,KAAAC,KAAA;AAsDQ,QAAI,oBAAoB,IAAI,qBAAqB;AACjD,UAAM,WAASD,MAAA,IAAI,WAAJ,gBAAAA,IAAY,YAAW,CAAC;AACvC,UAAM,aAAWC,MAAA,IAAI,cAAJ,gBAAAA,IAAe,YAAW,CAAC;AAC5C,UAAM,YAAU,SAAI,YAAJ,mBAAa,YAAW,CAAC;AACzC,QAAI,IAAI,UAAU;AAEd,cAAO,cAAS,GAAG,EAAE,MAAd,mBAAiB,OAAO,IAAI;AAC/B,iBAAS,IAAI;AACjB,UAAI,SAAS,WAAW,GAAG;AAMvB,gBAAO,YAAO,GAAG,EAAE,MAAZ,mBAAe,OAAO,IAAI,WAAW;AACxC,iBAAO,IAAI;AACX;AAAA,QACJ;AAAA,MACJ;AAKA,cAAO,aAAQ,CAAC,MAAT,mBAAY,OAAO,IAAI,WAAW;AACrC,gBAAQ,MAAM;AACd;AAAA,MACJ;AAAA,IACJ,WACS,SAAS,WAAW,GAAG;AAG5B,aAAO,KAAK,GAAG,QAAQ,OAAO,CAAC,CAAC;AAAA,IACpC;AACA;AAAA;AAAA,MAEA,sBAAsB,IAAI;AAAA,MAErB,IAAI,UAAU,IAAI,OAAO,WAAW,OAAO;AAAA,MAAS;AAErD,aAAO,EAAE,KAAK,YAAY;AAAA,QACtB,GAAG;AAAA;AAAA,QAEH;AAAA,QACA;AAAA,QACA,WAAW;AAAA,QACX;AAAA,MACJ,GAAG,EAAE,YAAY,KAAK,CAAC;AAAA,IAC3B;AAAA,EACJ;AAAA,EACA,UAAU;AAAA,IACN,aAAa,CAAAC,UAAQ;AACjB,UAAIA,MAAK;AACL,eAAO,GAAGA,MAAK,SAAS,kBAAkB;AAC9C,YAAM,mBAAmBA,MAAK,MACzB,IAAI,aAAW,QAAQ,SAAS,cAAc,GAAG,QAAQ,KAAK,kBAAkB,MAC/E,QAAQ,SAAS,aACf,MAAM,QAAQ,KAAK,kBAAkB,OACnC,QAAQ,KAAK,UAAU,EAC5B,KAAK,IAAI;AACd,aAAO,IAAI,gBAAgB;AAAA,IAC/B;AAAA,EACJ;AAAA,EACA,eAAe;AAAA,IACX,UAAU,CAAC,GAAG,GAAG,QAAQ;AACrB,YAAM,YAAY,oBAAoB;AAAA,QAClC,GAAG,EAAE;AAAA,QACL,GAAG,EAAE;AAAA,QACL,UAAU,IAAI,SAAS,CAAC,CAAC;AAAA,QACzB,QAAQ,CAAC;AAAA,QACT,eAAe,CAAC;AAAA,QAChB;AAAA,MACJ,CAAC;AACD,YAAM,iBAAiB,UAAU,SAAS,QAAQ,IAC9C,CAAC,WAAW,GAAG,UAAU,aAAa,IACpC,UAAU;AAChB,aAAQ,eAAe,WAAW,IAAI,UAAU,WAC1C,eAAe,WAAW,IACxB,IAAI,EAAE,KAAK,YAAY,qBAAqB,eAAe,CAAC,EAAE,MAAM,CAAC,IACnE,IAAI,EAAE,KAAK,SAAS,eAAe,IAAI,YAAU;AAAA,QAC/C,OAAO;AAAA,QACP,UAAU,qBAAqB,MAAM,MAAM;AAAA,MAC/C,EAAE,CAAC;AAAA,IACf;AAAA;AAAA;AAAA;AAAA;AAAA,EAKJ;AACJ,CAAC;AACM,IAAM,eAAN,cAA2B,eAAe;AAAA,EAA1C;AAAA;AACH,wCAAe,KAAK,EAAE,SAAS,MAAM;AACrC,kCAAS,KAAK,MAAM,UAAU,CAAC;AAC/B,qCAAY,KAAK,MAAM,aAAa,CAAC;AACrC,uCAAc,CAAC,GAAG,KAAK,QAAQ,GAAG,KAAK,SAAS;AAChD,mCAAU,KAAK,MAAM,WAAW,CAAC;AACjC,0CAAiB,KAAK,YAAY,SAAS,KAAK,QAAQ,WAAW;AACnE,6CAAoB,KAAK,MAAM,qBAAqB;AACpD,qCAAY,KAAK,OAAO,SAAS,KAAK,oBAAoB,KAAK,QAAQ;AACvE,yCAAgB,KAAK,cAAc,IAAI,OAAO,KAAK,EAAE,KAAK,aAAa,KAAK,SAAS;AACrF,qCAAY,KAAK,WAAW,OAAO,KAAK,YAAY,KAAK,UAAU;AACnE,yCAAgB,KAAK,cAAc,OAAO,OAAO,KAAK,EAAE,KAAK,aAAa,KAAK,SAAS;AACxF,2CAAkB,KAAK,gBACnB,KAAK,gBACD,CAAC,KAAK,eAAe,KAAK,aAAa,IACrC,CAAC,KAAK,aAAa,IACvB,KAAK,gBAAgB,CAAC,KAAK,aAAa,IACpC,CAAC;AAWX;AAAA,0CAAiB,CAAC,MAAM,QAAQ;AAC5B,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ;AAC7B,YAAI,CAAC,KAAK,aAAa,MAAM,CAAC,EAAE,eAAe,KAAK,CAAC,GAAG,GAAG;AACvD,iBAAO;AACf,aAAO;AAAA,IACX;AACA,yCAAgB,CAAC,MAAM,QAAQ;AAC3B,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAClC,YAAI,KAAK,KAAK,CAAC;AACf,aAAK,aAAa,MAAM,CAAC,EAAE,cAAc,KAAK,CAAC,GAAG,GAAG;AACrD,YAAI,KAAK,IAAI;AAAA,MACjB;AAAA,IACJ;AA4BA,iCAAQ,qBAAqB,KAAK,KAAK;AAEvC;AAAA,sCAAa,KAAK;AAAA;AAAA,EApDlB,aAAa,MAAM,OAAO;AACtB,QAAI,QAAQ,KAAK,YAAY;AACzB,aAAO,KAAK,YAAY,KAAK;AACjC,UAAM,oBAAoB,KAAK,SAAS,KAAK,QAAQ;AACrD,QAAI,SAAS;AACT,aAAO,KAAK,QAAQ,QAAQ,iBAAiB;AACjD,WAAQ,KAAK,YACT,mBAAmB,sCAAsC,KAAK,OAAO,IAAI,EAAE;AAAA,EACnF;AAAA;AAAA,EAgBA,QAAQ,IAAI;AACR,SAAK,OAAO,QAAQ,CAACA,OAAM,MAAM,GAAG,YAAY,GAAG,CAAC,IAAI,QAAQ,CAAC,KAAKA,KAAI,CAAC;AAC3E,SAAK,UAAU,QAAQ,CAACA,OAAM,MAAM;AAChC,YAAM,YAAY,GAAG,IAAI,KAAK,OAAO,MAAM;AAC3C,SAAG,GAAG,GAAG,SAAS,OAAO,GAAG,IAAI,WAAW,MAAM,GAAG,kBAAkB,WAAW,GAAG,OAAO,IAAI,IAAI,GAAG,OAAO,CAAC;AAC9G,SAAG,YAAY,WAAW,QAAQ,SAAS,KAAKA,KAAI;AAAA,IACxD,CAAC;AACD,QAAI,KAAK,UAAU;AACf,UAAI,KAAK,QAAQ,QAAQ;AACrB,WAAG,MAAM,qBAAqB,GAAG,GAAG,IAAI,UAAU,KAAK,QAAQ,SAAS,KAAK,KAAK,QAAQ,MAAM,KAAK,EAAE,EAAE;AAAA,MAC7G;AACA,SAAG,IAAI,OAAO,KAAK,QAAQ,SAAS,sBAAsB,aAAa,IAAI,MAAM,GAAG,YAAY,KAAK,WAAW,KAAK,QAAQ,GAAG,KAAK,YAAY,MAAM;AACvJ,WAAK,QAAQ,QAAQ,CAACA,OAAM,MAAM;AAC9B,cAAM,gBAAgB,uBAAuB,CAAC;AAC9C,WAAG,YAAY,eAAe,QAAQ,aAAa,KAAKA,KAAI;AAAA,MAChE,CAAC;AAAA,IACL;AACA,QAAI,GAAG,kBAAkB;AACrB,SAAG,OAAO,IAAI;AAAA,EACtB;AAAA,EACA,WAAW,QAAQ,KAAK;AACpB,QAAI,KAAK,KAAK,KAAK,EAAE,SAAS,yBAAyB,GAAG;AAC1D,UAAM,SAAS,MAAM,WAAW,QAAQ,GAAG;AAC3C,QAAI,KAAK,IAAI;AACb,WAAO;AAAA,EACX;AAIJ;AACA,IAAM,uBAAuB,CAAC,UAAU;AAvNxC,MAAAF,KAAAC,KAAA;AAwNI,QAAM,QAAQ,CAAC;AACf,GAAAD,MAAA,MAAM,WAAN,gBAAAA,IAAc,QAAQ,CAAAE,UAAQ,MAAM,KAAK,EAAE,MAAM,UAAU,MAAAA,MAAK,CAAC;AACjE,GAAAD,MAAA,MAAM,cAAN,gBAAAA,IAAiB,QAAQ,CAAAC,UAAQ,MAAM,KAAK,EAAE,MAAM,aAAa,MAAAA,MAAK,CAAC;AACvE,MAAI,MAAM;AACN,UAAM,KAAK,EAAE,MAAM,YAAY,MAAM,MAAM,SAAS,CAAC;AACzD,cAAM,YAAN,mBAAe,QAAQ,CAAAA,UAAQ,MAAM,KAAK,EAAE,MAAM,WAAW,MAAAA,MAAK,CAAC;AACnE,SAAO;AACX;AACA,IAAM,uBAAuB,CAAC,UAAU,MAAM,OAAO,CAAC,QAAQA,UAAS;AACnE,MAAIA,MAAK,SAAS;AACd,WAAO,WAAWA,MAAK;AAAA;AAEvB,WAAOA,MAAK,IAAI,IAAI,OAAO,OAAOA,MAAK,IAAI,GAAGA,MAAK,IAAI;AAC3D,SAAO;AACX,GAAG,CAAC,CAAC;AACE,IAAM,kCAAkC;AACxC,IAAM,gCAAgC;AAC7C,IAAM,sBAAsB,CAAC,MAAM;AAzOnC,MAAAF,KAAAC;AA0OI,QAAM,CAAC,OAAO,GAAG,KAAK,IAAI,EAAE;AAC5B,QAAM,CAAC,OAAO,GAAG,KAAK,IAAI,EAAE;AAC5B,MAAI,CAAC,SAAS,CAAC;AACX,WAAO;AACX,QAAM,gBAAcD,MAAA,MAAM,GAAG,EAAE,MAAX,gBAAAA,IAAc,UAAS;AAC3C,QAAM,gBAAcC,MAAA,MAAM,GAAG,EAAE,MAAX,gBAAAA,IAAc,UAAS;AAC3C,QAAM,OAAO,MAAM,SAAS,YAAY,MAAM,SAAS,WAAW,WAC5D,MAAM,SAAS,eAAe,MAAM,SAAS;AAAA;AAAA;AAAA;AAAA,IAI3C,eAAe,cACX,WACE;AAAA,MACJ,MAAM,SAAS,aAAa,MAAM,SAAS,YAAY,YACnD;AACd,MAAI,MAAM,SAAS,YAAY,MAAM,SAAS,cAAc,aAAa;AACrE,UAAM,sBAAsB,oBAAoB;AAAA,MAC5C,GAAG;AAAA,MACH,eAAe,CAAC;AAAA,MAChB,GAAG,MAAM,IAAI,cAAY,EAAE,GAAG,SAAS,MAAM,SAAS,EAAE;AAAA,IAC5D,CAAC;AACD,QAAI,oBAAoB,SAAS,QAAQ;AACrC,QAAE,cAAc,KAAK,mBAAmB;AAAA,EAChD,WACS,MAAM,SAAS,YACpB,MAAM,SAAS,cACf,aAAa;AACb,UAAM,sBAAsB,oBAAoB;AAAA,MAC5C,GAAG;AAAA,MACH,eAAe,CAAC;AAAA,MAChB,GAAG,MAAM,IAAI,cAAY,EAAE,GAAG,SAAS,MAAM,SAAS,EAAE;AAAA,IAC5D,CAAC;AACD,QAAI,oBAAoB,SAAS,QAAQ;AACrC,QAAE,cAAc,KAAK,mBAAmB;AAAA,EAChD;AACA,QAAM,SAAS,eAAe,MAAM,MAAM,MAAM,MAAM,EAAE,GAAG;AAC3D,MAAI,kBAAkB,UAAU;AAC5B,QAAI,SAAS,YAAY,SAAS,WAAW;AACzC,QAAE,SAAS,IAAI,OAAO;AAAA;AAAA,QAEtB,SAAS,WAAW,GAAG,EAAE,OAAO,MAAM,KAAK,IAAI,MAAM,SAAS,CAAC;AAAA,MAAE,CAAC;AAClE,QAAE,SAAS,CAAC,GAAG,EAAE,QAAQ,EAAE,MAAM,MAAM,EAAE,IAAI,EAAE,SAAS,MAAM,IAAI,CAAC;AAAA,IACvE,WACS,SAAS,aAAa;AAI3B,aAAO;AAAA,IACX,OACK;AAID,aAAO,oBAAoB;AAAA,QACvB,GAAG;AAAA,QACH,eAAe,CAAC;AAAA;AAAA;AAAA,QAGhB,GAAG,MAAM,IAAI,cAAY,EAAE,GAAG,SAAS,MAAM,SAAS,EAAE;AAAA,QACxD,GAAG,MAAM,IAAI,cAAY,EAAE,GAAG,SAAS,MAAM,SAAS,EAAE;AAAA,MAC5D,CAAC;AAAA,IACL;AAAA,EACJ;AAEI,MAAE,SAAS,CAAC,GAAG,EAAE,QAAQ,EAAE,MAAM,MAAM,OAAO,CAAC;AACnD,QAAM,aAAa,EAAE,EAAE;AACvB,QAAM,aAAa,EAAE,EAAE;AACvB,MAAI,MAAM,SAAS,cACd,cAAc,eACV,MAAM,SAAS,cAAc,eAAe;AACjD,MAAE,IAAI;AACV,MAAI,MAAM,SAAS,cACd,cAAc,eACV,MAAM,SAAS,cAAc,eAAe;AACjD,MAAE,IAAI;AACV,SAAO,oBAAoB,CAAC;AAChC;;;ACtTO,IAAM,oBAAoB;AAC1B,IAAM,6BAA6B,oBAAoB,iBAAiB;;;ACF/E,IAAIE,qBAAwD,SAAU,SAAS,cAAc,OAAO;AAChG,MAAI,WAAW,UAAU,SAAS;AAClC,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,YAAQ,WAAW,aAAa,CAAC,EAAE,KAAK,SAAS,KAAK,IAAI,aAAa,CAAC,EAAE,KAAK,OAAO;AAAA,EAC1F;AACA,SAAO,WAAW,QAAQ;AAC9B;AACA,IAAIC,gBAA8C,SAAU,MAAM,cAAc,YAAY,WAAW,cAAc,mBAAmB;AACpI,WAAS,OAAO,GAAG;AAAE,QAAI,MAAM,UAAU,OAAO,MAAM,WAAY,OAAM,IAAI,UAAU,mBAAmB;AAAG,WAAO;AAAA,EAAG;AACtH,MAAI,OAAO,UAAU,MAAM,MAAM,SAAS,WAAW,QAAQ,SAAS,WAAW,QAAQ;AACzF,MAAI,SAAS,CAAC,gBAAgB,OAAO,UAAU,QAAQ,IAAI,OAAO,KAAK,YAAY;AACnF,MAAI,aAAa,iBAAiB,SAAS,OAAO,yBAAyB,QAAQ,UAAU,IAAI,IAAI,CAAC;AACtG,MAAI,GAAG,OAAO;AACd,WAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,KAAK;AAC7C,QAAI,UAAU,CAAC;AACf,aAAS,KAAK,UAAW,SAAQ,CAAC,IAAI,MAAM,WAAW,CAAC,IAAI,UAAU,CAAC;AACvE,aAAS,KAAK,UAAU,OAAQ,SAAQ,OAAO,CAAC,IAAI,UAAU,OAAO,CAAC;AACtE,YAAQ,iBAAiB,SAAU,GAAG;AAAE,UAAI,KAAM,OAAM,IAAI,UAAU,wDAAwD;AAAG,wBAAkB,KAAK,OAAO,KAAK,IAAI,CAAC;AAAA,IAAG;AAC5K,QAAI,UAAU,GAAG,WAAW,CAAC,GAAG,SAAS,aAAa,EAAE,KAAK,WAAW,KAAK,KAAK,WAAW,IAAI,IAAI,WAAW,GAAG,GAAG,OAAO;AAC7H,QAAI,SAAS,YAAY;AACrB,UAAI,WAAW,OAAQ;AACvB,UAAI,WAAW,QAAQ,OAAO,WAAW,SAAU,OAAM,IAAI,UAAU,iBAAiB;AACxF,UAAI,IAAI,OAAO,OAAO,GAAG,EAAG,YAAW,MAAM;AAC7C,UAAI,IAAI,OAAO,OAAO,GAAG,EAAG,YAAW,MAAM;AAC7C,UAAI,IAAI,OAAO,OAAO,IAAI,EAAG,cAAa,QAAQ,CAAC;AAAA,IACvD,WACS,IAAI,OAAO,MAAM,GAAG;AACzB,UAAI,SAAS,QAAS,cAAa,QAAQ,CAAC;AAAA,UACvC,YAAW,GAAG,IAAI;AAAA,IAC3B;AAAA,EACJ;AACA,MAAI,OAAQ,QAAO,eAAe,QAAQ,UAAU,MAAM,UAAU;AACpE,SAAO;AACX;AAQA,IAAI,iBAAiB,MAAM;AAzC3B,MAAAC,KAAAC,KAAA;AA0CI,MAAI,cAAc;AAClB,MAAI,6BAA6B,CAAC;AAClC,MAAI;AACJ,SAAO,mBAA4B,YAAY;AAAA,IAAxC;AAAA;AAOH,2CAAgBH,mBAAkB,MAAM,0BAA0B,GAAG,KAAK,EAAE,SAAS,OAAO;AAC5F,6CAAkB,KAAK,SAAS,QAAQ,OAAK,EAAE,mBAAmB,CAAC,CAAC;AACpE,mCAAQ,KAAK,WACT,KAAK,WACD,CAAC,GAAG,KAAK,UAAU,GAAG,KAAK,QAAQ,IACjC,KAAK,WACT,KAAK,YAAY,CAAC;AACxB,wCAAa,UAAU,KAAK,OAAO,CAAC,GAAGI,UAAS,CAACA,MAAK,KAAKA,KAAI,CAAC;AAChE,iDAAsB,oBAAoB,KAAK,UAAU;AACzD,wCAAa,qBAAqB,IAAI;AACtC,mDAAsBF,MAAA,KAAK,aAAL,gBAAAA,IAAe,IAAI,CAAAE,UAAQA,MAAK,SAAQ,CAAC;AAC/D,mDAAsBD,MAAA,KAAK,aAAL,gBAAAA,IAAe,IAAI,CAAAC,UAAQA,MAAK,SAAQ,CAAC;AAC/D,yCAAc;AAAA,QACV,GAAG,KAAK;AAAA,QACR,GAAG,KAAK;AAAA,MACZ;AAQA,wCAAa,KAAK,eAAe,UAAa,KAAK,UAAU;AAoB7D,4CAAiB,CAAC,MAAM,QAAQ,KAAK,UAAU,UAAU,MAAM,GAAG;AAClE,2CAAgB,CAAC,MAAM,QAAQ,KAAK,UAAU,SAAS,MAAM,GAAG;AAChE,uCAAY,CAAC,eAAe,MAAM,QAAQ;AACtC,cAAM,cAAa,2BAAK,sBAAqB;AAC7C,iBAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AACxC,cAAI,kBAAkB,UAAU;AAC5B,gBAAI,CAAC,KAAK,MAAM,CAAC,EAAE,eAAe,MAAM,GAAG;AACvC,qBAAO;AAAA,UACf,OACK;AACD,iBAAK,MAAM,CAAC,EAAE,cAAc,MAAM,GAAG;AACrC,gBAAI,IAAI,YAAY,IAAI,oBAAoB;AACxC,qBAAO;AAAA,UACf;AAAA,QACJ;AACA,YAAI,KAAK,UAAU;AACf,cAAI,kBAAkB,UAAU;AAC5B,gBAAI,CAAC,KAAK,SAAS,eAAe,MAAM,GAAG;AACvC,qBAAO;AAAA,UACf,OACK;AACD,iBAAK,SAAS,cAAc,MAAM,GAAG;AACrC,gBAAI,IAAI,YAAY,IAAI,oBAAoB;AACxC,qBAAO;AAAA,UACf;AAAA,QACJ;AACA,YAAI,CAAC,KAAK;AACN,iBAAO;AACX,cAAM,OAAO,OAAO,KAAK,IAAI;AAC7B,aAAK,KAAK,GAAG,OAAO,sBAAsB,IAAI,CAAC;AAC/C,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAClC,gBAAM,IAAI,KAAK,CAAC;AAChB,cAAI,UAAU;AACd,cAAI,KAAK,OAAO;AACZ,uBAAWA,SAAQ,KAAK,OAAO;AAC3B,kBAAIA,MAAK,UAAU,eAAe,GAAG,GAAG,GAAG;AACvC,oBAAI,kBAAkB,UAAU;AAC5B,6CAAK,KAAK,KAAK;AACf,wBAAM,SAASA,MAAK,MAAM,eAAe,KAAK,CAAC,GAAG,GAAG;AACrD,6CAAK,KAAK;AACV,sBAAI,CAAC;AACD,2BAAO;AAAA,gBACf,OACK;AACD,sBAAI,KAAK,KAAK,CAAC;AACf,kBAAAA,MAAK,MAAM,cAAc,KAAK,CAAC,GAAG,GAAG;AACrC,sBAAI,KAAK,IAAI;AACb,sBAAI,IAAI,YAAY,IAAI,oBAAoB;AACxC,2BAAO;AAAA,gBACf;AACA,0BAAU;AAAA,cACd;AAAA,YACJ;AAAA,UACJ;AACA,cAAI,KAAK,YAAY;AACjB,kCAAY,KAAK,KAAK;AACtB,kCACI,KAAK,aAAa,UACd,OAAO,MAAM,YACb,kBAAkB,KAAK,CAAC;AAChC,gBAAI,CAAC,SAAS;AACV,kBAAI,kBAAkB;AAClB,uBAAO;AACX,kBAAI,KAAK,eAAe;AACpB,oBAAI,MAAM,EAAE,UAAU,WAAW,QAAQ,MAAM,cAAc,CAAC,CAAC,EAAE,CAAC;AAAA,mBACjE;AACD,oBAAI,YAAY;AAAA,kBACZ,CAAAC,UAAQ;AACJ,2BAAOA,MAAK,CAAC;AACb,2BAAOA;AAAA,kBACX;AAAA,gBACJ,CAAC;AAAA,cACL;AACA,kBAAI,IAAI;AACJ,uBAAO;AAAA,YACf;AAAA,UACJ;AACA,qCAAK,KAAK;AAAA,QACd;AACA,eAAO;AAAA,MACX;AAAA;AAAA,IA3GA,QAAQ;AApEhB,UAAAH;AAqEY,UAAI,WAAW,KAAK,EAAE,MAAM,KAAK,WAAW,EAAE;AAC9C,OAAAA,MAAA,KAAK,UAAL,gBAAAA,IAAY,QAAQ,CAAC,EAAE,WAAW,MAAM,MAAM;AAC1C,mBAAW,SAAS,OAAO,MAAM,QAAQ;AAAA,MAC7C;AACA,aAAO,KAAK,EAAE,KAAK,SAAS,QAAQ;AAAA,IACxC;AAAA,IAEA,QAAQ,MAAM;AACV,aAAO,KAAK,EAAE,KAAK,aAAa,cAAc,KAAK,OAAO,IAAI,CAAC;AAAA,IACnE;AAAA,IACA,MAAM,GAAG;AACL,YAAM,QAAQ,kCAAkC,cAAc,KAAK,OAAO,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;AACtF,UAAI,EAAE;AACF,cAAM,WAAW,OAAO,MAAM,UAAU,EAAE,QAAQ;AACtD,UAAI,EAAE;AACF,cAAM,WAAW,OAAO,MAAM,UAAU,EAAE,QAAQ;AACtD,UAAI,EAAE;AACF,cAAM,QAAQ,OAAO,MAAM,OAAO,EAAE,KAAK;AAC7C,UAAI,EAAE;AACF,cAAM,WAAW,EAAE;AACvB,UAAI,EAAE;AACF,cAAM,aAAa,EAAE;AAAA;AAErB,eAAO,MAAM;AACjB,aAAO,KAAK,EAAE,KAAK,aAAa,KAAK;AAAA,IACzC;AAAA,IAkFA,QAAQ,IAAI;AACR,UAAI,GAAG,kBAAkB;AACrB,WAAG,qBAAqB;AAC5B,WAAK,MAAM,QAAQ,UAAQ;AACvB,WAAG,MAAM,IAAI;AACb,YAAI,GAAG,kBAAkB;AACrB,aAAG,iBAAiB;AAAA,MAC5B,CAAC;AACD,UAAI,KAAK,UAAU;AACf,WAAG,MAAM,KAAK,QAAQ;AACtB,YAAI,GAAG,kBAAkB;AACrB,aAAG,iBAAiB;AAAA,MAC5B;AACA,UAAI,KAAK,YAAY;AACjB,WAAG,MAAM,QAAQ,mBAAmB;AACpC,WAAG,KAAK,kDAAkD;AAC1D,WAAG,IAAI,mBAAmB,MAAM,KAAK,uBAAuB,EAAE,CAAC;AAAA,MACnE;AACA,UAAI,GAAG,kBAAkB;AACrB,WAAG,OAAO,IAAI;AAAA,IACtB;AAAA,IACA,uBAAuB,IAAI;AArMnC,UAAAA,KAAAC;AAsMY,SAAG,MAAM,KAAK,SAAS;AACvB,UAAI,KAAK;AACL,WAAG,IAAI,WAAW,KAAK;AAC3B,OAAAD,MAAA,KAAK,UAAL,gBAAAA,IAAY,QAAQ,CAAAE,UAAQ;AACxB,WAAG,GAAG,GAAG,GAAG,OAAOA,MAAK,WAAW,EAAE,KAAK,KAAK,MAAM,SAAS,CAAC,CAAC,IAAI,MAAM;AACtE,aAAG,YAAY,KAAK,WAAWA,MAAK,KAAK;AACzC,cAAI,KAAK;AACL,eAAG,IAAI,WAAW,IAAI;AAC1B,iBAAO;AAAA,QACX,CAAC;AAAA,MACL;AACA,UAAI,KAAK,YAAY;AACjB,cAAID,MAAA,KAAK,UAAL,gBAAAA,IAAY,YAAW;AACvB,aAAG,KAAK,oBAAoB,KAAK,mBAAmB,EAAE;AAC1D,YAAI,KAAK,UAAU;AACf,aAAG,KAAK,wCAAwC,0BAA0B,UAAU;AAAA,QACxF;AACA,WAAG,GAAG,YAAY,MAAM;AACpB,cAAI,GAAG,kBAAkB;AACrB,mBAAO,GAAG,OAAO,KAAK;AAC1B,iBAAO,KAAK,eAAe,WACvB,GACK,KAAK,qEAAqE,EAC1E,GAAG,gBAAgB,MAAM,GAAG,OAAO,CAAC,IACvC,GAAG,KAAK,4DAA4D;AAAA,QAC9E,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AAAA,EACJ,IArLI,MAAO;AACH,UAAM,YAAY,OAAO,WAAW,cAAc,OAAO,WAAW,OAAO,OAAO,YAAY,OAAO,QAAQ,KAAK,IAAI,IAAI;AAC1H,wBAAoB,CAAC,MAAM;AAC3B,IAAAF,cAAa,IAAM,MAAM,mBAAmB,EAAE,MAAM,UAAU,MAAM,SAAS,QAAQ,OAAO,SAAS,OAAO,QAAQ,EAAE,KAAK,SAAO,WAAW,KAAK,KAAK,SAAO,IAAI,MAAM,GAAG,UAAU,UAAU,GAAG,MAAM,0BAA0B;AAClO,QAAI,UAAW,QAAO,eAAe,IAAM,OAAO,UAAU,EAAE,YAAY,MAAM,cAAc,MAAM,UAAU,MAAM,OAAO,UAAU,CAAC;AAAA,EAC1I,MANG;AAuLX,GAAG;AAEH,IAAM,gBAAgB,CAAC,OAAO,SAAS;AACnC,QAAM,SAAS,EAAE,GAAG,MAAM;AAC1B,OAAK,QAAQ,OAAK;AACd,QAAI,OAAO,UAAU;AACjB,aAAO,WAAW,OAAO,SAAS,OAAO,OAAK,OAAO,MAAM,aAAa,CAAC,EAAE,OAAO,EAAE,GAAG,IAAI,MAAM,EAAE,GAAG;AAAA,IAC1G;AACA,QAAI,OAAO,UAAU;AACjB,aAAO,WAAW,OAAO,SAAS,OAAO,OAAK,OAAO,MAAM,aAAa,CAAC,EAAE,OAAO,EAAE,GAAG,IAAI,MAAM,EAAE,GAAG;AAAA,IAC1G;AACA,QAAI,OAAO,SAAS,OAAO,MAAM,YAAY;AAGzC,aAAO,QAAQ,OAAO,MAAM,OAAO,OAAK,CAAC,EAAE,UAAU,QAAQ,CAAC,CAAC;AAAA,IACnE;AAAA,EACJ,CAAC;AACD,SAAO;AACX;AACA,IAAM,yBAAyB,CAAC,oBAAoB,CAACK,UAAS;AAvP9D,MAAAC,KAAAC;AAwPI,MAAIF,MAAK,MAAM,UAAUA,MAAK,OAAO;AACjC,UAAM,UAAQC,MAAAD,MAAK,UAAL,gBAAAC,IAAY,IAAI,YAAW,CAAC;AAC1C,IAAAD,MAAK,MAAM,QAAQ,CAAAA,UAAQ,MAAM,KAAKA,MAAK,eAAe,CAAC,CAAC;AAC5D,QAAIA,MAAK;AACL,YAAM,KAAK,mBAAmBA,MAAK,UAAU,EAAE;AACnD,UAAM,2BAA2B,KAAK,MAAM,KAAK,IAAI,CAAC;AACtD,WAAOA,MAAK,WACR,GAAG,wBAAwB,MAAMA,MAAK,SAAS,WAAW,KACxD;AAAA,EACV;AACA,WAAOE,MAAAF,MAAK,aAAL,gBAAAE,IAAe,gBAAe;AACzC;AACA,IAAM,wBAAwB,uBAAuB,aAAa;AAClE,IAAM,uBAAuB,uBAAuB,YAAY;AACzD,IAAM,0BAA0B,cAAc;AAAA,EACjD,MAAM;AAAA,EACN,oBAAoB;AAAA,EACpB,WAAW,CAAAC,YAAUA;AAAA,EACrB,MAAM;AAAA,IACF,UAAU;AAAA,MACN,OAAO;AAAA,MACP,OAAO,oBAAoB,UAAU;AAAA,IACzC;AAAA,IACA,UAAU;AAAA,MACN,OAAO;AAAA,MACP,OAAO,oBAAoB,UAAU;AAAA,IACzC;AAAA,IACA,OAAO;AAAA,MACH,OAAO;AAAA,MACP,OAAO,oBAAoB,OAAO;AAAA,IACtC;AAAA,IACA,UAAU;AAAA,MACN,OAAO;AAAA,MACP,OAAO,oBAAoB,UAAU;AAAA,IACzC;AAAA,IACA,YAAY;AAAA,MACR,OAAO,cAAa,aAAa,WAAW,SAAY;AAAA,IAC5D;AAAA,EACJ;AAAA,EACA,UAAU;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACA,eAAe;AAAA,IACX,WAAW,CAAC,GAAG,GAAG,QAAQ;AACtB,YAAM,SAAS,EAAE,GAAG,EAAE,MAAM;AAC5B,YAAM,SAAS,EAAE,GAAG,EAAE,MAAM;AAC5B,UAAI,EAAE,YAAY;AACd,cAAM,OAAO,EAAE,MAAM;AACrB,cAAM,gBAAgB,EAAE,oBAAoB,OAAO,OAAK,CAAC,KAAK,OAAO,CAAC,CAAC;AACvE,YAAI,cAAc,QAAQ;AACtB,iBAAO,SAAS,KAAK,YAAY,IAAI,EAAE,SAAS,MAAM,KAAK,EAAE,WAAW,cAAc,CAAC,CAAC,EAAE,KAAK,EAAE,cAAc,cAAc,CAAC,CAAC;AAAA,QACnI;AACA,YAAI,OAAO;AACP,iBAAO,WAAW,OAAO,SAAS,OAAO,OAAK,KAAK,OAAO,EAAE,GAAG,CAAC;AACpE,YAAI,OAAO,OAAO;AACd,iBAAO,QAAQ,OAAO,MAAM,QAAQ,OAAK;AACrC,gBAAI,EAAE,UAAU,QAAQ,IAAI;AACxB,qBAAO;AACX,kBAAM,eAAe,mBAAmB,MAAM,EAAE,WAAW,IAAI,CAAC;AAChE,gBAAI,wBAAwB;AACxB,qBAAO,CAAC;AACZ,kBAAM,aAAa,eAAe,cAAc,EAAE,OAAO,IAAI,CAAC;AAC9D,gBAAI,WAAW,UAAU;AACrB,qBAAO,WACH,OAAO,WACH,CAAC,GAAG,OAAO,UAAU,GAAG,WAAW,QAAQ,IACzC,WAAW;AAAA,YACzB;AACA,mBAAO,WAAW,SAAS,CAAC;AAAA,UAChC,CAAC;AAAA,QACL;AAAA,MACJ;AACA,UAAI,EAAE,YAAY;AACd,cAAM,OAAO,EAAE,MAAM;AACrB,cAAM,gBAAgB,EAAE,oBAAoB,OAAO,OAAK,CAAC,KAAK,OAAO,CAAC,CAAC;AACvE,YAAI,cAAc,QAAQ;AACtB,iBAAO,SAAS,KAAK,YAAY,EAAE,WAAW,cAAc,CAAC,CAAC,EAAE,OAAO,IAAI,EAAE,SAAS,MAAM,GAAG,EAAE,cAAc,cAAc,CAAC,CAAC;AAAA,QACnI;AACA,YAAI,OAAO;AACP,iBAAO,WAAW,OAAO,SAAS,OAAO,OAAK,KAAK,OAAO,EAAE,GAAG,CAAC;AACpE,YAAI,OAAO,OAAO;AACd,iBAAO,QAAQ,OAAO,MAAM,QAAQ,OAAK;AACrC,gBAAI,EAAE,UAAU,QAAQ,IAAI;AACxB,qBAAO;AACX,kBAAM,eAAe,mBAAmB,MAAM,EAAE,WAAW,IAAI,CAAC;AAChE,gBAAI,wBAAwB;AACxB,qBAAO,CAAC;AACZ,kBAAM,aAAa,eAAe,cAAc,EAAE,OAAO,IAAI,CAAC;AAC9D,gBAAI,WAAW,UAAU;AACrB,qBAAO,WACH,OAAO,WACH,CAAC,GAAG,OAAO,UAAU,GAAG,WAAW,QAAQ,IACzC,WAAW;AAAA,YACzB;AACA,mBAAO,WAAW,SAAS,CAAC;AAAA,UAChC,CAAC;AAAA,QACL;AAAA,MACJ;AACA,YAAM,YAAY,CAAC;AACnB,UAAI,EAAE,cAAc,EAAE,YAAY;AAC9B,kBAAU,aACN,EAAE,eAAe,YAAY,EAAE,eAAe,WAC1C,WACE;AAAA,MACd;AACA,aAAO,qBAAqB;AAAA,QACxB,MAAM;AAAA,QACN;AAAA,QACA,GAAG,mBAAmB,MAAM;AAAA,QAC5B,GAAG,mBAAmB,MAAM;AAAA,QAC5B,OAAO,CAAC;AAAA,QACR;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AACJ,CAAC;AAEM,IAAM,iBAAiB,CAAC,WAAW,OAAO,MAAM;AACnD,QAAM,CAAC,oBAAoB,qBAAqB,IAAI,WAAW,UAAU,UAAU,CAAC,MAAM,EAAE,QAAQ,MAAM,CAAC;AAC3G,MAAI,CAAC,mBAAmB;AACpB,WAAO,EAAE,OAAO,EAAE,KAAK,SAAS,EAAE,WAAW,MAAM,CAAC,EAAE;AAC1D,QAAM,aAAa,CAAC;AACpB,aAAW,WAAW,mBAAmB,IAAI,OAAK,EAAE,KAAK,YAAY,EAAE,KAAK,EAAE,MAAM,MAAM,CAAC,CAAC;AAC5F,MAAI,sBAAsB,QAAQ;AAC9B,eAAW,QAAQ,EAAE,KAAK,SAAS;AAAA,MAC/B,WAAW;AAAA,MACX;AAAA,IACJ,CAAC;AAAA,EACL;AACA,SAAO;AACX;;;AC1WO,IAAM,4BAA4B;AAAA,EACrC,GAAG;AAAA,EACH,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,cAAc;AAAA,EACd,SAAS;AAAA,EACT,OAAO;AAAA,EACP,WAAW;AAAA,EACX,UAAU;AAAA,EACV,UAAU;AAAA,EACV,OAAO;AAAA,EACP,UAAU;AAAA,EACV,WAAW;AACf;AACO,IAAM,oBAAoB;AAAA,EAC7B,GAAG;AAAA,EACH,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,cAAc;AAAA,EACd,SAAS;AAAA,EACT,OAAO;AAAA,EACP,WAAW;AAAA,EACX,UAAU;AAAA,EACV,UAAU;AAAA,EACV,OAAO;AAAA,EACP,UAAU;AAAA,EACV,WAAW;AACf;;;ACjDO,IAAM,aAAN,cAAyB,YAAY;AAAA;AAAA,EAExC,KAAK,OAAO,IAAI;AACZ,WAAO;AAAA,EACX;AACJ;;;ACFO,IAAM,eAAe,CAACC,SAAQ,iBAAiB;AAClD,QAAM,OAAO,qBAAqBA,OAAM;AACxC,MAAI,gBAAgB,CAAC,aAAa,SAAS,IAAI,GAAG;AAC9C,WAAO,gBAAgB,gBAAgB,IAAI,qBAAqB,YAAY,EAAE;AAAA,EAClF;AACA,SAAO;AACX;AACA,IAAM,uBAAuB,CAACA,YAAW;AACrC,UAAQ,OAAOA,SAAQ;AAAA,IACnB,KAAK;AACD,aAAOA,QAAO,CAAC,MAAM,MAAM,UAAU;AAAA,IACzC,KAAK;AACD,aAAO,WAAWA,SAAQ,MAAM,IAAIA,QAAO,OAAO;AAAA,IACtD,KAAK,UAAU;AAEX,UAAIA,YAAW;AACX;AACJ,UAAI,YAAYA;AACZ,eAAO;AACX,UAAI,cAAcA,WAAU,QAAQA,OAAM;AACtC,eAAO;AACX,UAAI,UAAUA;AACV,eAAO;AACX,UAAI,WAAWA;AACX,eAAO;AACX,YAAM,aAAa,OAAO,KAAKA,OAAM;AACrC,UAAI,WAAW,WAAW,KAAK,WAAW,KAAK,OAAK,KAAK,cAAc;AACnE,eAAO;AACX,UAAI,WAAWA;AACX,eAAO;AACX,UAAI,YAAYA;AACZ,eAAO;AAAA,IACf;AAAA,EACJ;AACA,SAAO,gBAAgB,GAAG,UAAUA,OAAM,CAAC,6BAA6B;AAC5E;AACA,IAAM,YAAY,CAAC;AACnB,IAAM,yBAAyB,CAAC,iBAAiB,QAAQ,YAAY,IACjE,aAAa,IAAI,CAAAC,UAAQA,MAAK,eAAe,IAC3C,aAAa;AACZ,IAAM,YAAY,CAAC,MAAM,QAAQ;AACpC,QAAM,OAAO,0BAA0B,IAAI;AAC3C,QAAM,QAAQ,CAAC;AAGf,QAAM,gBAAgB,UAAU,IAAI,MAAM,EAAE,KAAK,CAAC,CAAC,IAAI,GAAG,CAAC,IAAI,MAAM,WAAW,IAAI,IAChF,WAAW,IAAI,IAAI,iBAAiB,IAAI,IAAI,iBAAiB,IAAI,IAC3D,IACJ,WAAW,IAAI,IAAI,KACf,OAAO,OAAO,KACV,CAAC;AACf,QAAM,WAAW,CAAC;AAClB,aAAW,SAAS,eAAe;AAC/B,UAAM,IAAI,MAAM,CAAC;AACjB,UAAM,UAAU,KAAK,KAAK,CAAC;AAC3B,QAAI,CAAC;AACD,aAAO,gBAAgB,OAAO,CAAC,oBAAoB,IAAI,SAAS;AACpE,UAAM,IAAI,QAAQ,QAAQ,QAAQ,MAAM,MAAM,CAAC,GAAG,GAAG,IAAI,MAAM,CAAC;AAChE,QAAI,MAAM,UAAU,MAAM,UAAa,QAAQ;AAC3C,YAAM,CAAC,IAAI;AAAA,EACnB;AACA,QAAM,UAAU,UAAU,KAAK;AAC/B,MAAIC,QAAO,CAAC;AACZ,MAAI,WAAW,CAAC;AAChB,UAAQ,QAAQ,CAAC,CAAC,GAAG,CAAC,MAAM;AACxB,UAAM,eAAe;AACrB,UAAM,UAAU,KAAK,KAAK,CAAC;AAC3B,UAAM,YAAY,QAAQ,cACrB,QAAQ,QAAQ,yBAAyB;AAC9C,IAAAA,MAAK,CAAC,IAAI,UAAU,YAAY;AAChC,QAAI,QAAQ,OAAO;AACf,UAAI,QAAQ,YAAY;AACpB,iBAAS,KAAK,GAAG,YAAY;AAAA;AAE7B,iBAAS,KAAK,YAAY;AAAA,IAClC;AACA,QAAI,CAAC,QAAQ;AACT,eAAS,CAAC,IAAIA,MAAK,CAAC;AAAA,EAC5B,CAAC;AACD,MAAI,KAAK,cAAc;AACnB,IAAAA,QAAO,KAAK,aAAaA,KAAI;AAC7B,eAAW,KAAK,aAAa,QAAQ;AAAA,EACzC;AACA,MAAI,kBAAkBA;AACtB,QAAM,kBAAkB,OAAO,KAAK,eAAe;AACnD,MAAI,gBAAgB,WAAW,KAC3B,gBAAgB,CAAC,MAAM,KAAK,gBAAgB;AAC5C,sBAAkB,gBAAgB,KAAK,cAAc;AACrD;AAAA;AAAA,MAEA,UAAU,iBAAiB,QAAQ;AAAA,MAE/B,OAAO,KAAKA,KAAI,EAAE,WAAW;AAAA,MAAG;AAEhC,MAAAA,QAAO;AACP,iBAAW;AAAA,IACf;AAAA,EACJ;AACA,QAAM,YAAY,KAAK,UAAU,EAAE,MAAM,GAAGA,MAAK,CAAC;AAClD,MAAI,IAAI,UAAU;AACd,cAAU,SAAS,IAAI,IAAI;AAC3B,WAAO,IAAI;AAAA,EACf;AACA,QAAM,WAAW,KAAK,UAAU,EAAE,MAAM,GAAG,SAAS,CAAC;AACrD,MAAI,KAAK,UAAU,CAAC,IAAI,YAAY;AAChC,UAAM,UAAU,KAAK,OAAO,OAAO,IAAI,CAAC;AACxC,QAAI,SAAS;AACT,UAAI,mBAAmB;AACnB,eAAO,QAAQ,MAAM;AAIzB,UAAI,IAAI;AACJ,gBAAQ,UAAR,QAAQ,QAAU,IAAI;AAG1B,aAAO;AAAA,IACX;AAAA,EACJ;AAGA,MAAI,UAAU,SAAS;AACnB,WAAO,UAAU,SAAS;AAC9B,QAAM,cAAc;AAAA,IAChB,IAAI,IAAI;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAMA;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,GAAG,IAAI;AAAA,EACX;AACA,MAAI,IAAI;AACJ,gBAAY,QAAQ,IAAI;AAC5B,aAAW,KAAK,OAAO;AACnB,QAAI,MAAM,iBAAiB,MAAM,QAAQ,MAAM;AAC3C,kBAAY,CAAC,IAAI,MAAM,CAAC;AAAA,EAChC;AACA,QAAMD,QAAO,IAAI,kBAAkB,IAAI,EAAE,WAAW;AACpD,YAAU,SAAS,IAAIA;AACvB,SAAOA;AACX;;;ACtJO,IAAM,eAAN,cAA2B,iBAAiB;AAAA,EAI/C,YAAY,eAAe;AACvB,UAAM,QAAQ,KAAK;AAJvB;AACA,gCAAO,CAAC;AACR,yCAAgB,CAAC;AAGb,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,OAAOE,OAAM,MAAM;AACf,UAAM,OAAM,6BAAM,QAAO,KAAK;AAC9B,QAAI,KAAK,mBAAmBA,KAAI;AAC5B,aAAO,GAAG,KAAK,UAAUA,OAAM,IAAI,CAAC,IAAI,GAAG,KAAK,KAAK,GAAG;AAC5D,WAAO,GAAG,KAAK,UAAUA,OAAM,IAAI,CAAC,IAAI,GAAG;AAAA,EAC/C;AAAA,EACA,UAAUA,OAAM,MAAM;AAClB,UAAM,eAAc,6BAAM,SAAQ,KAAK;AACvC,UAAM,OAAO,QAAQA,MAAK,EAAE,GAAG,WAAW;AAC1C,YAAO,6BAAM,QAAO,GAAG,IAAI,SAAS,6BAAM,IAAI,MAAM;AAAA,EACxD;AAAA,EACA,mBAAmBA,OAAM;AACrB,WAAO,KAAK,kBAAkB,WAAWA,MAAK;AAAA,EAClD;AAAA,EACA,uBAAuB;AACnB,WAAO,KAAK,MAAM,cAAc,uBAAuB;AAAA,EAC3D;AAAA,EACA,eAAe;AACX,WAAO,KAAK,GAAG,sCAAsC,MAAM,KAAK,OAAO,CAAC;AAAA,EAC5E;AAAA,EACA,mBAAmB;AACf,WAAO,KAAK,GAAG,sDAAsD,MAAM,KAAK,OAAO,CAAC;AAAA,EAC5F;AAAA,EACA,YAAY,eAAe,kBAAkBA,OAAM;AAC/C,UAAM,kBAAkB,KAAK,mBAAmBA,KAAI;AACpD,QAAI;AACA,WAAK,KAAK,GAAG,KAAK,GAAG,cAAc,aAAa,GAAG;AACvD,SAAK,MAAMA,OAAM;AAAA,MACb,KAAK;AAAA,IACT,CAAC;AACD,QAAI;AACA,WAAK,KAAK,GAAG,KAAK,GAAG,aAAa;AACtC,WAAO;AAAA,EACX;AAAA,EACA,MAAMA,OAAM,MAAM;AACd,WAAO,KAAK,kBAAkB,WAC1B,KAAK,GAAG,IAAI,KAAK,OAAOA,OAAM,IAAI,CAAC,IAAI,MAAM,KAAK,OAAO,KAAK,CAAC,IAC7D,KAAK,KAAK,KAAK,OAAOA,OAAM,IAAI,CAAC;AAAA,EAC3C;AAAA,EACA,YAAY,MAAM;AACd,WAAO,GAAG,IAAI,IAAI,KAAK,SAAS,KAAK,IAAI,CAAC;AAAA,EAAO,KAAK,IAAI;AAAA;AAAA,EAC9D;AACJ;;;ACnDA,IAAIC,qBAAwD,SAAU,SAAS,cAAc,OAAO;AAChG,MAAI,WAAW,UAAU,SAAS;AAClC,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,YAAQ,WAAW,aAAa,CAAC,EAAE,KAAK,SAAS,KAAK,IAAI,aAAa,CAAC,EAAE,KAAK,OAAO;AAAA,EAC1F;AACA,SAAO,WAAW,QAAQ;AAC9B;AACA,IAAIC,gBAA8C,SAAU,MAAM,cAAc,YAAY,WAAW,cAAc,mBAAmB;AACpI,WAAS,OAAO,GAAG;AAAE,QAAI,MAAM,UAAU,OAAO,MAAM,WAAY,OAAM,IAAI,UAAU,mBAAmB;AAAG,WAAO;AAAA,EAAG;AACtH,MAAI,OAAO,UAAU,MAAM,MAAM,SAAS,WAAW,QAAQ,SAAS,WAAW,QAAQ;AACzF,MAAI,SAAS,CAAC,gBAAgB,OAAO,UAAU,QAAQ,IAAI,OAAO,KAAK,YAAY;AACnF,MAAI,aAAa,iBAAiB,SAAS,OAAO,yBAAyB,QAAQ,UAAU,IAAI,IAAI,CAAC;AACtG,MAAI,GAAG,OAAO;AACd,WAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,KAAK;AAC7C,QAAI,UAAU,CAAC;AACf,aAAS,KAAK,UAAW,SAAQ,CAAC,IAAI,MAAM,WAAW,CAAC,IAAI,UAAU,CAAC;AACvE,aAAS,KAAK,UAAU,OAAQ,SAAQ,OAAO,CAAC,IAAI,UAAU,OAAO,CAAC;AACtE,YAAQ,iBAAiB,SAAU,GAAG;AAAE,UAAI,KAAM,OAAM,IAAI,UAAU,wDAAwD;AAAG,wBAAkB,KAAK,OAAO,KAAK,IAAI,CAAC;AAAA,IAAG;AAC5K,QAAI,UAAU,GAAG,WAAW,CAAC,GAAG,SAAS,aAAa,EAAE,KAAK,WAAW,KAAK,KAAK,WAAW,IAAI,IAAI,WAAW,GAAG,GAAG,OAAO;AAC7H,QAAI,SAAS,YAAY;AACrB,UAAI,WAAW,OAAQ;AACvB,UAAI,WAAW,QAAQ,OAAO,WAAW,SAAU,OAAM,IAAI,UAAU,iBAAiB;AACxF,UAAI,IAAI,OAAO,OAAO,GAAG,EAAG,YAAW,MAAM;AAC7C,UAAI,IAAI,OAAO,OAAO,GAAG,EAAG,YAAW,MAAM;AAC7C,UAAI,IAAI,OAAO,OAAO,IAAI,EAAG,cAAa,QAAQ,CAAC;AAAA,IACvD,WACS,IAAI,OAAO,MAAM,GAAG;AACzB,UAAI,SAAS,QAAS,cAAa,QAAQ,CAAC;AAAA,UACvC,YAAW,GAAG,IAAI;AAAA,IAC3B;AAAA,EACJ;AACA,MAAI,OAAQ,QAAO,eAAe,QAAQ,UAAU,MAAM,UAAU;AACpE,SAAO;AACX;AAUO,IAAM,gBAAgB,OAAO,OAAO,UAAU,2BAA2B,CAAC,MAAM,mBAAmB;AAAA,EACtG;AAAA,EACA,eAAe;AACnB,CAAC,GAAG;AAAA,EACA,SAAS,UAAU;AAAA,EACnB,kBAAkB;AAAA,EAClB,mBAAmB;AACvB,CAAC;AACD,IAAM,mBAAmB;AAAA,EACrB;AAAA,EACA;AACJ;AACO,IAAM,eAAe,CAAC,MAAM,cAAc;AAC7C,MAAI,CAAC;AACD,WAAO;AACX,QAAM,SAAS,aAAa,MAAM,SAAS;AAC3C,mBAAiB,QAAQ,OAAK;AAC1B,QAAI,EAAE,KAAK;AACP,aAAO,OAAO,CAAC;AAAA,EACvB,CAAC;AACD,SAAO;AACX;AACO,IAAM,gBAAgB,CAAC,WAAW,aAAa,aAAa,eAAe,YAAY,GAAG,MAAM;AACvG,IAAM,mBAAmB,CAACC,YAAW,QAAQA,OAAM,IAAIA,UACjD,cAAcA,WAAU,QAAQA,QAAO,QAAQ,IAAIA,QAAO,WACtD;AACV,IAAM,+BAA+B,CAAC,UAAU,WAAW,gBAAgB,gBAAgB,MAAM,sBAAsB,QAAQ,aAAa;AACrI,IAAM,2BAA2B,CAAC,UAAU,IAAI,KAAK,4BAA4B,KAAK;AAC7F,IAAM,qBAAqB,CAAC;AAC5B,IAAM,YAAY,CAAC;AACnB,IAAI,aAAa;AACjB,IAAM,aAAa,CAAC;AACpB,IAAI,gBAAgB,MAAM;AA3E1B,MAAAC,KAAAC;AA4EI,MAAI,6BAA6B,CAAC;AAClC,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,SAcKD,MAAA,SAdEC,MAAA,MAAmB;AAAA,IAkCtB,YAGA,KAAK,QAAQ;AA1Bb,oCAASJ,mBAAkB,MAAM,0BAA0B;AAC3D;AACA,gCAAK,IAAI,EAAE,UAAU;AACrB,0BAACG,KAAW;AACZ,4CAAiB,CAAC;AAClB,wCAAa,CAAC;AACd,yCAAc,CAAC;AACf,kCAAO,CAAC;AACR;AACA,qCAAU,CAAC;AACX,sCAAW;AAiEX,6CAAkB,CAAC;AAanB,mCAAS,CAAC,OAAO,YAAY,SAAS;AAnL9C,YAAAA;AAoLY,YAAI,OAAO,OAAO,UAAU,WAAW,QAAQ,aAAa,YAAY,KAAK;AAC7E,YAAID,UAAS;AACb,YAAI,OAAOA,OAAM,KAAKA,QAAO,SAAS;AAClC,iBAAOA,QAAO,UAAU,IAAI;AAChC,YAAI,SAAS,WAAW,EAAC,6BAAM,aAAY;AACvC,gBAAM,aAAa,KAAK,YAAY,qBAAqBA,OAAM,EAAE,KAAK;AACtE,UAAAA,UAAS;AACT,iBAAO,WAAW;AAAA,QACtB,WACS,SAAS,WAAW,UAAUA,SAAQ,QAAQ,GAAG;AACtD,gBAAM,WAAW,iBAAiBA,OAAM;AACxC,eAAI,qCAAU,YAAW,GAAG;AACxB,YAAAA,UAAS,SAAS,CAAC;AACnB,mBAAO,aAAaA,OAAM;AAAA,UAC9B;AAAA,QACJ;AACA,cAAM,OAAO,0BAA0B,IAAI;AAC3C,cAAM,qBAAmBC,MAAA,KAAK,cAAL,gBAAAA,IAAA,WAAiBD,aAAWA;AAGrD,YAAI,OAAO,gBAAgB,GAAG;AAC1B,iBAAO,iBAAiB,SAAS,OAC7B,iBAAiB,UAAU,IAAI,IAC7B,6BAA6B,MAAM,iBAAiB,IAAI;AAAA,QAClE;AACA,cAAM,UAAS,6BAAM,UAAS;AAC9B,oEAA+B;AAC/B,cAAMG,MAAK,GAAG,MAAM,GAAG,EAAE,mBAAmB,MAAM,CAAC;AACnD,cAAMC,QAAO,UAAU,MAAM;AAAA,UACzB,GAAG;AAAA,UACH,IAAAD;AAAA,UACA,GAAG;AAAA,UACH,QAAQ;AAAA,QACZ,CAAC,EAAE,UAAU,IAAI;AACjB,kBAAUA,GAAE,IAAIC;AAChB,YAAI,KAAK,UAAU;AAGf,cAAI,CAAC,KAAK,eAAe;AACrB,8BAAkBA,MAAK,UAAU;AAAA,QACzC,OACK;AAGD,iBAAO,OAAO,KAAK,gBAAgBA,MAAK,cAAc;AAAA,QAC1D;AACA,eAAOA;AAAA,MACX,GAAI,KAAK,IAAI;AAsDb;AACA;AApKI,WAAK,SAAS,UAAU,CAAC;AACzB,WAAK,iBAAiB,cAAc,MAAM;AAC1C,WAAK,gBAAgB,OAAO,KAAK,GAAG,EAAE,OAAO,OAAK;AAC9C,YAAI,EAAE,CAAC,MAAM,KAAK;AACd,gBAAM,OAAO,EAAE,MAAM,CAAC;AACtB,cAAI,QAAQ,KAAK;AACb,4BAAgB,yBAAyB,IAAI,CAAC;AAClD,eAAK,QAAQ,IAAI,IAAI,IAAI,CAAC;AAC1B,iBAAO;AAAA,QACX;AACA,YAAI,KAAK,KAAK;AACV,0BAAgB,yBAAyB,CAAC,CAAC;AAC/C,aAAK,QAAQ,CAAC,IAAI,IAAI,CAAC;AACvB,eAAO;AAAA,MACX,CAAC;AACD,UAAI,KAAK,SAAS;AAEd,aAAK,QAAQ,OAAO;AAEpB,aAAK,cAAc,UAAU,KAAK,QAAQ,aAAa,CAAC,OAAO,eAAe;AAAA,UAC1E;AAAA,UACA,WAAW,YAAY,MAAM,IACzB,WAAW,UAAU,IAAI,IACvB;AAAA,QACV,CAAC;AAAA,MACL;AACA,iBAAW,KAAK,EAAE,IAAI;AAAA,IAC1B;AAAA;AAAA,IAtCA,IAAI,WAAW;AACX,aAAOF,IAAa;AAAA,IACxB;AAAA,IAEA,IAAI,UAAU;AACV,aAAO,KAAK,YAAY;AAAA,IAC5B;AAAA,IAiCA,IAAI,MAAM;AACN,aAAO;AAAA,IACX;AAAA,IACA,OAAO,KAAK,MAAM;AACd,aAAO,KAAK,KAAK,aAAa,GAAG,GAAG,KAAK,IAAI;AAAA,IACjD;AAAA,IACA,WAAW,KAAK;AACZ,aAAO;AAAA,IACX;AAAA,IACA,MAAM,QAAQ,MAAM;AAChB,YAAM,eAAe,CAAC;AACtB,iBAAW,SAAS;AAChB,YAAI,CAAC,aAAa,SAAS,KAAK;AAC5B,uBAAa,KAAK,KAAK;AAC/B,YAAM,WAAW,aAAa,IAAI,UAAQ,KAAK,KAAK,QAAQ,EAAE,KAAK,GAAG,IAAI,CAAC;AAC3E,aAAO,KAAK,KAAK,SAAS,UAAU;AAAA,QAChC,GAAG;AAAA,QACH,YAAY;AAAA,MAChB,CAAC;AAAA,IACL;AAAA,IAEA,cAAc,SAAS,gBAAgB;AACnC,UAAI,CAAC,gBAAgB;AACjB,2BAAmB,cAAnB,mBAAmB,YAAc;AACjC,yBAAiB,YAAY,EAAE,mBAAmB,SAAS;AAAA,MAC/D;AACA,YAAME,QAAO,KAAK,KAAK,SAAS;AAAA,QAC5B,OAAO;AAAA,QACP;AAAA,MACJ,GAAG,EAAE,YAAY,KAAK,CAAC;AACvB,WAAK,gBAAgB,KAAKA,KAAI;AAC9B,aAAOA;AAAA,IACX;AAAA,IAkDA,UAAU,KAAK,MAAM;AACjB,aAAO,KAAK,OAAO,KAAK,IAAI;AAAA,IAChC;AAAA,IACA,YAAY,MAAM;AACd,aAAQ,KAAK,iBAAiB,IAAI,KAC9B,gBAAgB,yBAAyB,IAAI,CAAC;AAAA,IACtD;AAAA,IACA,iBAAiB,MAAM;AACnB,YAAM,SAAS,KAAK,0BAA0B,IAAI;AAClD,UAAI,WAAW,QAAQ,SAAS;AAC5B;AACJ,aAAO;AAAA,IACX;AAAA,IACA,0BAA0B,MAAM;AAC5B,YAAM,aAAa,KAAK,aAAa,IAAI;AACzC,UAAI,WAAW,YAAY,QAAQ;AAC/B,eAAO,gBAAgB,mCAAmC,IAAI,CAAC;AACnE,aAAO;AAAA,IACX;AAAA,IACA,aAAa,KAAK;AACd,aAAO;AAAA,IACX;AAAA,IACA,aAAa,MAAM;AACf,YAAM,aAAa,KAAK,oBAAoB,IAAI;AAChD,aAAO,OAAO,eAAe,WACzB,KAAK,KAAK,SAAS,EAAE,OAAO,WAAW,GAAG,EAAE,YAAY,KAAK,CAAC,IAC5D;AAAA,IACV;AAAA,IACA,oBAAoB,MAAM;AACtB,YAAMC,UAAS,KAAK,YAAY,IAAI;AACpC,UAAIA;AACA,eAAOA;AACX,UAAI,MAAM,KAAK,QAAQ,IAAI;AAC3B,UAAI,CAAC;AACD,eAAO,KAAK,qBAAqB,IAAI;AACzC,YAAM,KAAK,aAAa,GAAG;AAC3B,UAAI,WAAW,KAAK,SAAS;AACzB,eAAQ,KAAK,YAAY,IAAI,IAAI,kCAAkC,GAAG;AAC1E,UAAI,WAAW,KAAK,QAAQ;AACxB,eAAQ,KAAK,YAAY,IAAI,IAAI;AACrC,WAAK,YAAY,IAAI,IAAI;AACzB,aAAQ,KAAK,YAAY,IAAI,IAAI,KAAK,UAAU,GAAG;AAAA,IACvD;AAAA;AAAA,IAEA,qBAAqB,MAAM;AACvB,aAAO,gBAAgB,KAAK,SAAS,IAAI;AAAA,IAC7C;AAAA,IACA,UAAU,OAAO;AACb,aAAO,IAAI,WAAW,UAAU,KAAK,OAAO,GAAG,KAAK,GAAG,CAAC,OAAO,UAAU;AAAA,QACrE,IAAI,KAAK;AAAA,QACT;AAAA,MACJ,CAAC,CAAC;AAAA,IACN;AAAA,IAGA,UAAU,OAAO;AACb,UAAI,CAAC,KAAK,UAAU;AAChB,aAAK,WAAW,CAAC;AACjB,mBAAW,QAAQ,KAAK,eAAe;AACnC,gBAAM,aAAa,KAAK,aAAa,IAAI;AACzC,cAAI,WAAW,YAAY,MAAM,GAAG;AAChC,uBAAW,WACN,OAAO,CAACD,UAASA,MAAK,QAAQ,OAAO,CAAC,EACtC,QAAQ,eAAa;AACtB,qBAAO,OAAO,UAAU,gBAAgB,UAAU,WAAW,cAAc;AAC3E,yBAAW,WAAW,QAAQ,SAAO;AACjC,oBAAI,UAAU,MAAM,IAAI;AACpB,yBAAO,OAAO,IAAI,gBAAgB,UAAU,cAAc;AAAA,cAClE,CAAC;AAAA,YACL,CAAC;AAAA,UACL;AACA,eAAK,SAAS,IAAI,IAAI;AAAA,QAC1B;AACA,aAAK,gBAAgB,QAAQ,CAAAA,UAAQA,MAAK,UAAU;AACpD,aAAK,uBAAuB,oBAAoB,MAAM,KAAK,QAAQ;AAEnE,eAAO,OAAO,KAAK,MAAM,UAAU,KAAK,sBAAsB,CAAC,GAAG,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,GAAG,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC;AACjH,eAAO,OAAO,KAAK,aAAa,KAAK,oBAAoB;AACzD,YAAI,KAAK,OAAO;AACZ,iBAAO,OAAOF,IAAa,UAAU,KAAK,oBAAoB;AAClE,aAAK,aAAa,OAAO,OAAO,KAAK,cAAc;AACnD,YAAI,CAAC,KAAK,eAAe;AACrB,4BAAkB,KAAK,UAAU;AACrC,aAAK,WAAW;AAAA,MACpB;AACA,YAAM,gBAAgB,MAAM,SAAS,QAAQ,KAAK;AAClD,aAAO,IAAI,WAAW,UAAU,eAAe,CAAC,GAAG,SAAS;AAAA,QACxD;AAAA,QACA,KAAK,SAAS,IAAI;AAAA,MACtB,CAAC,CAAC;AAAA,IACN;AAAA,IACA,QAAQ,MAAM;AACV,aAAO,KAAK,OAAO,EAAE,IAAI;AAAA,IAC7B;AAAA,EACJ,IAjPI,MAAO;AACH,UAAM,YAAY,OAAO,WAAW,cAAc,OAAO,WAAW,uBAAO,OAAO,IAAI,IAAI;AAC1F,yBAAqB,CAAC,KAAK;AAC3B,6BAAyB,CAAC,KAAK;AAC/B,wBAAoB,CAAC,KAAK;AAC1B,IAAAH,cAAaG,KAAM,MAAM,oBAAoB,EAAE,MAAM,UAAU,MAAM,UAAU,QAAQ,OAAO,SAAS,OAAO,QAAQ,EAAE,KAAK,SAAO,YAAY,KAAK,KAAK,SAAO,IAAI,OAAO,GAAG,UAAU,UAAU,GAAG,MAAM,0BAA0B;AACtO,IAAAH,cAAaG,KAAM,MAAM,wBAAwB,EAAE,MAAM,UAAU,MAAM,cAAc,QAAQ,OAAO,SAAS,OAAO,QAAQ,EAAE,KAAK,SAAO,gBAAgB,KAAK,KAAK,SAAO,IAAI,WAAW,GAAG,UAAU,UAAU,GAAG,MAAM,0BAA0B;AACtP,IAAAH,cAAaG,KAAM,MAAM,mBAAmB,EAAE,MAAM,UAAU,MAAM,SAAS,QAAQ,OAAO,SAAS,OAAO,QAAQ,EAAE,KAAK,SAAO,WAAW,KAAK,KAAK,SAAO,IAAI,MAAM,GAAG,UAAU,UAAU,GAAG,MAAM,0BAA0B;AAClO,QAAI,UAAW,QAAO,eAAeA,KAAM,OAAO,UAAU,EAAE,YAAY,MAAM,cAAc,MAAM,UAAU,MAAM,OAAO,UAAU,CAAC;AAAA,EAC1I;AAAA;AAAA;AAAA,EAeA,cAzBGA,KAyBI,YAAW,CAAC,IAKnB,cA9BGA,KA8BI,YA9BJA;AAmPX,GAAG;AAEH,IAAM,kBAAkB,CAAC,MAAM,SAAS;AACpC,QAAM,WAAW,KAAK,QAAQ,GAAG;AACjC,MAAI,aAAa;AACb;AACJ,QAAM,YAAY,KAAK,MAAM,GAAG,QAAQ;AACxC,QAAM,eAAe,KAAK,SAAS;AAGnC,MAAI,iBAAiB;AACjB;AACJ,MAAI,CAAC,WAAW,cAAc,QAAQ;AAClC,WAAO,gBAAgB,4BAA4B,SAAS,CAAC;AACjE,QAAM,WAAW,KAAK,MAAM,WAAW,CAAC;AACxC,QAAM,aAAa,aAAa,QAAQ;AAGxC,MAAI,eAAe,QAAW;AAC1B,QAAI,WAAW,YAAY,QAAQ;AAC/B,aAAO,gBAAgB,YAAY,QAAQ;AAC/C,WAAO,gBAAgB,yBAAyB,IAAI,CAAC;AAAA,EACzD;AACA,MAAI,WAAW,YAAY,MAAM,KAAK,WAAW,YAAY,SAAS;AAClE,WAAO;AACX,qBAAmB,oCAAoC,IAAI,MAAM,UAAU,UAAU,CAAC,EAAE;AAC5F;AACO,IAAM,cAAc,CAAC,SAAS,WAAW,IAAI,UAAU,SAAS,MAAM;AACtE,IAAM,YAAY;AAClB,IAAM,OAAO,IAAI,UAAU,CAAC,CAAC;AAC7B,IAAM,SAAS,KAAK;AACpB,IAAM,OAAO,KAAK;AAClB,IAAM,aAAa,KAAK;AACxB,IAAM,QAAQ,KAAK;AACnB,IAAM,YAAY,KAAK,IAAI;AAC3B,IAAM,UAAU,KAAK,IAAI;AACzB,IAAM,gBAAgB,KAAK,IAAI;AAC/B,IAAM,WAAW,KAAK,IAAI;AAajC,IAAM,sBAAsB,CAAC,GAAG,YAAY;AACxC,QAAM,SAAS,CAAC;AAChB,aAAW,KAAK,SAAS;AACrB,UAAM,IAAI,QAAQ,CAAC;AACnB,QAAI,WAAW,GAAG,QAAQ,GAAG;AACzB,YAAM,mBAAmB,oBAAoB,GAAG,CAAC;AACjD,YAAM,sBAAsB,UAAU,kBAAkB,CAAC,QAAQ,WAAW,CAAC,GAAG,CAAC,IAAI,MAAM,IAAI,MAAM,CAAC;AACtG,aAAO,OAAO,QAAQ,mBAAmB;AAAA,IAC7C,WACS,WAAW,GAAG,SAAS;AAC5B,aAAO,CAAC,IAAI;AAAA,aACP,WAAW,GAAG,MAAM;AACzB,aAAO,CAAC,IAAI;AAAA;AAEZ,yBAAmB,+BAA+B,UAAU,CAAC,CAAC,EAAE;AAAA,EACxE;AACA,SAAO;AACX;AACO,IAAM,2BAA2B,CAAC,UAAU,IAAI,KAAK;AACrD,IAAM,8BAA8B,CAAC,SAAS,IAAI,IAAI;AACtD,IAAM,qCAAqC,CAAC,SAAS,2BAA2B,IAAI;AACpF,IAAM,oBAAoB,CAAC,eAAe;AAC7C,QAAM,qBAAqB,aAAa,UAAU;AAClD,aAAWI,SAAQ,YAAY;AAC3B,QAAIA,MAAK,KAAK;AAEV;AAAA,IACJ;AACA,IAAAA,MAAK,MAAM;AACX,IAAAA,MAAK,iBACD,mBAAmB,GAAGA,MAAK,EAAE,QAAQ,EAAE,KAAK,kBAAkB;AAClE,QAAIA,MAAK,OAAO,KAAK,CAACA,MAAK,uBAAuB;AAG9C,MAAAA,MAAK,SAASA,MAAK;AAAA,IACvB;AACA,IAAAA,MAAK,gBACD,mBAAmB,GAAGA,MAAK,EAAE,OAAO,EAAE,KAAK,kBAAkB;AAAA,EACrE;AACJ;AACA,IAAM,eAAe,CAAC,eAAe,IAAI,iBAAiB,EACrD,MAAM,UAAU,QAAM;AACvB,aAAW,QAAQ,CAAAA,UAAQ;AACvB,UAAM,iBAAiB,IAAI,aAAa,QAAQ,EAAE,OAAO;AACzD,IAAAA,MAAK,QAAQ,cAAc;AAC3B,UAAM,gBAAgB,IAAI,aAAa,OAAO,EAAE,OAAO;AACvD,IAAAA,MAAK,QAAQ,aAAa;AAC1B,OAAG,KAAK,GAAG,eAAe,YAAY,GAAGA,MAAK,EAAE,QAAQ,CAAC,GAAG,EAAE,KAAK,GAAG,cAAc,YAAY,GAAGA,MAAK,EAAE,OAAO,CAAC,GAAG;AAAA,EACzH,CAAC;AACD,SAAO;AACX,CAAC,EACI,QAAQ,EAAE;;;ACvaR,IAAM,aAAa,YAAY;AAAA,EAClC,KAAK,CAAC;AAAA,EACN,QAAQ;AAAA;AAAA,EAER,SAAS,CAAC,EAAE,MAAM,MAAM,GAAG,EAAE,MAAM,KAAK,CAAC;AAAA,EACzC,OAAO,EAAE,MAAM,MAAM;AAAA,EACrB,OAAO,CAAC;AAAA,EACR,MAAM,EAAE,MAAM,KAAK;AAAA,EACnB,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM,EAAE,MAAM,KAAK;AAAA,EACnB,SAAS,CAAC;AAAA,EACV,MAAM,EAAE,MAAM,OAAU;AAAA,EACxB,WAAW,EAAE,MAAM,OAAU;AACjC,GAAG,EAAE,mBAAmB,MAAM,kBAAkB,KAAK,CAAC,EAAE,OAAO;;;ACbxD,IAAM,mBAAmB,YAAY;AAAA,EACxC,iBAAiB,CAAC,UAAU,KAAK;AAAA,EACjC,aAAa,CAAC,UAAU,QAAQ;AAAA,EAChC,0BAA0B,EAAE,QAAQ,UAAU,OAAO,kBAAkB;AAC3E,GAAG;AAAA,EACC,mBAAmB;AAAA,EACnB,kBAAkB;AACtB,CAAC,EAAE,OAAO;AAEV,KAAK,KAAK,SAAS;AAAA,EACf,UAAU;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,EAAE,MAAM,KAAK;AAAA,IACb,EAAE,MAAM,MAAM;AAAA,IACd,EAAE,MAAM,KAAK;AAAA,IACb,EAAE,MAAM,OAAU;AAAA,EACtB;AACJ,GAAG,EAAE,UAAU,KAAK,KAAK,gBAAgB,CAAC,GAAG,EAAE,YAAY,KAAK,CAAC,EAAE,CAAC;;;ACxB7D,IAAM,YAAY,YAAY;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ,GAAG,EAAE,mBAAmB,MAAM,kBAAkB,KAAK,CAAC,EAAE,OAAO;;;ACZ/D,IAAM,sBAAsB;AAI5B,IAAM,iBAAiB;AACvB,IAAM,sBAAsB,CAACC,UAAS,CAAC,OAAO,MAAM,CAACA,KAAI;AACzD,IAAM,yBAAyB,CAAC,WAAW,KAAK,MAAM;AAC/C,IAAM,sBAAsB,CAAC,MAAM,SAAS;AAC/C,MAAI,EAAC,6BAAM,SAAQ;AACf,UAAM,SAAS,IAAI,KAAK,IAAI;AAC5B,WAAO,oBAAoB,MAAM,IAAI,SAAS;AAAA,EAClD;AACA,MAAI,KAAK,WAAW,WAAW;AAC3B,WAAO,eAAe,KAAK,IAAI,IAC3B,IAAI,KAAK,IAAI,IACX,uBAAuB,SAAS;AAAA,EAC1C;AACA,QAAM,YAAY,KAAK,MAAM,mBAAmB;AAEhD,QAAM,YAAY,KAAK,UAAU,CAAC,EAAE,MAAM;AAC1C,QAAM,cAAc,YAAY,KAAK,OAAO,MAAM,SAAS,IAAI,CAAC,KAAK,MAAM;AAC3E,MAAI,UAAU,WAAW,YAAY;AACjC,WAAO,uBAAuB,KAAK,MAAM;AAC7C,QAAM,cAAc,CAAC;AACrB,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AACzC,QAAI,UAAU,CAAC,EAAE,WAAW,YAAY,CAAC,EAAE;AAAA,IAEvC,EAAE,YAAY,CAAC,EAAE,WAAW,KAAK,UAAU,CAAC,EAAE,WAAW;AACzD,aAAO,uBAAuB,KAAK,MAAM;AAC7C,gBAAY,YAAY,CAAC,EAAE,CAAC,CAAC,IAAI,UAAU,CAAC;AAAA,EAChD;AACA,QAAMA,QAAO,oBAAI,KAAK,GAAG,YAAY,CAAC,IAAI,YAAY,CAAC,IAAI,YAAY,CAAC,EAAE;AAC1E,MAAI,GAAGA,MAAK,QAAQ,CAAC,OAAO,YAAY;AACpC,WAAOA;AACX,SAAO,uBAAuB,KAAK,MAAM;AAC7C;;;AClCO,IAAM,cAAc,CAAC,OAAO,gBAAgB,KAAK,WAAW;AAAA,EAC/D,QAAQ;AAAA,EACR,OAAO;AAAA,IACH,MAAM,MAAM;AAAA,IACZ,OAAO,MAAM;AAAA,IACb;AAAA,EACJ;AACJ,CAAC;;;ACJD,IAAM,SAAS,KAAK,WAAW;AAAA,EAC3B,IAAI,YAAY,yBAAyB,8BAA8B;AAAA,EACvE,QAAQ,CAAC,MAAM,OAAO,WAAW,CAAC;AACtC,CAAC;AACD,IAAM,UAAU,KAAK,WAAW;AAAA,EAC5B,IAAI,YAAY,0BAA0B,8BAA8B;AAAA,EACxE,QAAQ,CAAC,GAAG,QAAQ;AAChB,QAAI,CAAC,oBAAoB,CAAC;AACtB,aAAO,IAAI,MAAM,8BAA8B;AACnD,UAAM,SAAS,OAAO,SAAS,CAAC;AAChC,WAAO,OAAO,cAAc,MAAM,IAAI,SAAU,IAAI,MAAM,4EAA4E;AAAA,EAC1I;AACJ,CAAC;AACD,IAAM,MAAM,KAAK,WAAW;AAAA,EACxB,IAAI;AAAA,EACJ,QAAQ,CAAC,GAAG,QAAQ;AAChB,QAAI;AACA,aAAO,IAAI,IAAI,CAAC;AAAA,IACpB,QACM;AACF,aAAO,IAAI,MAAM,aAAa;AAAA,IAClC;AAAA,EACJ;AACJ,CAAC;AACD,IAAM,OAAO,KAAK,WAAW;AAAA,EACzB,IAAI;AAAA,EACJ,QAAQ,CAAC,GAAG,QAAQ;AAChB,QAAI;AACA,aAAO,KAAK,MAAM,CAAC;AAAA,IACvB,QACM;AACF,aAAO,IAAI,MAAM,qBAAqB;AAAA,IAC1C;AAAA,EACJ;AACJ,CAAC;AACD,IAAM,OAAO,KAAK,WAAW;AAAA,EACzB,IAAI;AAAA,EACJ,QAAQ,CAAC,GAAG,QAAQ;AAChB,UAAM,SAAS,oBAAoB,CAAC;AACpC,WAAO,OAAO,WAAW,WAAW,IAAI,MAAM,MAAM,IAAI;AAAA,EAC5D;AACJ,CAAC;AACM,IAAM,UAAU,YAAY;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ,CAAC,EAAE,OAAO;;;ACnDH,IAAM,cAAc,CAAC,oBAAoB;AAC5C,QAAM,YAAY,gBAAgB,QAAQ,UAAU,EAAE;AACtD,MAAI,MAAM;AACV,MAAI;AACJ,MAAI;AACJ,MAAI,eAAe;AACnB,WAAS,IAAI,UAAU,SAAS,GAAG,KAAK,GAAG,KAAK;AAC5C,YAAQ,UAAU,UAAU,GAAG,IAAI,CAAC;AACpC,aAAS,OAAO,SAAS,OAAO,EAAE;AAClC,QAAI,cAAc;AACd,gBAAU;AACV,UAAI,UAAU;AACV,eAAQ,SAAS,KAAM;AAAA;AAEvB,eAAO;AAAA,IACf;AAEI,aAAO;AACX,mBAAe,CAAC;AAAA,EACpB;AACA,SAAO,CAAC,EAAE,MAAM,OAAO,IAAI,YAAY;AAC3C;AAEO,IAAM,oBAAoB;;;ACrBjC,IAAM,cAAc;AACpB,IAAM,cAAc,IAAI,WAAW,UAAU,WAAW;AACxD,IAAM,cAAc,IAAI,OAAO,IAAI,WAAW,GAAG;AAC1C,IAAM,OAAO,YAAY,aAAa,sBAAsB;AACnE,IAAM,cAAc;AACpB,IAAM,cAAc,IAAI,OAAO,QACrB,WAAW,WAAW,WAAW,UACjC,WAAW,WAAW,WAAW,KAAK,WAAW,UACjD,WAAW,YAAY,WAAW,MAAM,WAAW,gBACnD,WAAW,aAAa,WAAW,UAAU,WAAW,MAAM,WAAW,gBACzE,WAAW,aAAa,WAAW,UAAU,WAAW,MAAM,WAAW,gBACzE,WAAW,aAAa,WAAW,UAAU,WAAW,MAAM,WAAW,gBACzE,WAAW,aAAa,WAAW,UAAU,WAAW,MAAM,WAAW,sBACnE,WAAW,UAAU,WAAW,QAAQ,WAAW,oCACrC;AACvB,IAAM,OAAO,YAAY,aAAa,sBAAsB;AAC5D,IAAM,KAAK,KAAK,WAAW,CAAC,MAAM,IAAI,CAAC;;;ACd9C,IAAMC,OAAM,KAAK,WAAW;AAAA,EACxB,QAAQ;AAAA,EACR,WAAW;AAAA,IACP,WAAW,CAAC,MAAM;AACd,UAAI;AACA,YAAI,IAAI,CAAC;AAAA,MACb,QACM;AACF,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX;AAAA,IACA,aAAa;AAAA,EACjB;AACJ,CAAC;AAED,IAAM,eAAe;AACrB,IAAM,QAAQ,YAAY,cAAc,eAAe;AACvD,IAAM,cAAc;AAEpB,IAAM,OAAO,YAAY,aAAa,cAAc;AACpD,IAAM,gBAAgB;AAEtB,IAAM,SAAS,YAAY,eAAe,oDAAoD;AAC9F,IAAM,aAAa,KAAK,WAAW;AAAA,EAC/B,QAAQ;AAAA,EACR,OAAO;AAAA,IACH,MAAM,kBAAkB;AAAA,IACxB,aAAa;AAAA,EACjB;AAAA,EACA,WAAW;AAAA,IACP,WAAW;AAAA,IACX,aAAa;AAAA,EACjB;AACJ,CAAC;AACM,IAAM,aAAa,YAAY;AAAA,EAClC,OAAO,YAAY,eAAe,cAAc;AAAA,EAChD,cAAc,YAAY,iBAAiB,6BAA6B;AAAA,EACxE,QAAQ,YAAY,SAAS,iBAAiB;AAAA,EAC9C,WAAW,YAAY,YAAY,wBAAwB;AAAA,EAC3D,WAAW,YAAY,YAAY,wBAAwB;AAAA,EAC3D;AAAA,EACA;AAAA,EACA;AAAA,EACA,KAAAA;AAAA,EACA;AAAA,EACA;AAAA,EACA,SAAS;AAAA,IACL,QAAQ;AAAA,IACR,SAAS;AAAA,EACb;AACJ,GAAG,EAAE,mBAAmB,KAAK,CAAC,EAAE,OAAO;;;ACjDhC,IAAM,mBAAmB,YAAY;AAAA,EACxC,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,OAAO;AAAA;AAEX,CAAC;AACD,aAAa,UAAU,iBAAiB;AACjC,IAAM,eAAe,iBAAiB,OAAO;;;ACfpD,IAAAC,KAAAC;AAEO,IAAM,UAAN,eAAsBA,MAAA,UAIxBD,MAAA,SAJwBC,KAAS;AAAA,EAKlC,YAAY,QAAQ,KAEpB,GAAG;AACC,UAAM,IAAI,SAAS;AAMf;AACA,aAAO,EAAE,UAAU,GAAG;AAAA,IAC1B,CAAC;AAfL;AACA;AACA;AACA,wBAACD,KAAW;AAaR,SAAK,SAAS;AACd,SAAK,MAAM;AACX,SAAK,IAAI;AAAA,EACb;AACJ;;;ACvBO,IAAM,oBAAoB,CAAC,OAAO,MAAM;AAAE,GAAG,KAAK,CAAC;;;ACCnD,IAAM,UAAN,MAAM,SAAQ;AAAA,EAGjB,YAAY,KAAK;AAFjB;AACA;AAEI,SAAK,QAAQ,CAAC,GAAG,GAAG;AACpB,SAAK,IAAI;AAAA,EACb;AAAA;AAAA,EAEA,QAAQ;AACJ,WAAQ,KAAK,MAAM,KAAK,GAAG,KAAK;AAAA,EACpC;AAAA,EACA,IAAI,YAAY;AACZ,WAAQ,KAAK,MAAM,KAAK,CAAC,KAAK;AAAA,EAClC;AAAA,EACA,IAAI,gBAAgB;AAChB,WAAO,KAAK,MAAM,KAAK,IAAI,CAAC,KAAK;AAAA,EACrC;AAAA,EACA,IAAI,SAAS;AACT,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA,EACA,WAAW,WAAW;AAClB,QAAI,UAAU;AACd,WAAO,KAAK,WAAW;AACnB,UAAI,UAAU,MAAM,OAAO,GAAG;AAC1B,YAAI,QAAQ,QAAQ,SAAS,CAAC,MAAM,SAAQ;AACxC,oBAAU,QAAQ,MAAM,GAAG,EAAE;AAAA;AAE7B;AAAA,MACR;AACA,iBAAW,KAAK,MAAM;AAAA,IAC1B;AACA,WAAO;AAAA,EACX;AAAA,EACA,2BAA2B;AACvB,SAAK,wBAAwB;AAC7B,WAAO,KAAK,WAAW,SAAQ,qBAAqB;AAAA,EACxD;AAAA,EACA,0BAA0B;AACtB,WAAO,KAAK,WAAW,SAAQ,wBAAwB;AAAA,EAC3D;AAAA,EACA,YAAY,GAAG;AACX,SAAK,IAAI,IAAI,IAAI,KAAK,SAAS,IAAI;AAAA,EACvC;AAAA,EACA,IAAI,WAAW;AACX,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,KAAK,MAAM,MAAM,KAAK,GAAG,KAAK,MAAM,EAAE,KAAK,EAAE;AAAA,EACxD;AAAA,EACA,IAAI,UAAU;AACV,WAAO,KAAK,MAAM,MAAM,GAAG,KAAK,CAAC,EAAE,KAAK,EAAE;AAAA,EAC9C;AAAA,EACA,WAAW,OAAO,KAAK;AACnB,WAAO,KAAK,MAAM,MAAM,OAAO,GAAG,EAAE,KAAK,EAAE;AAAA,EAC/C;AAAA,EACA,YAAY,MAAM;AACd,WAAO,KAAK,cAAc;AAAA,EAC9B;AAAA,EACA,cAAc,QAAQ;AAClB,WAAO,KAAK,aAAa;AAAA,EAC7B;AACJ;AAAA,CACC,SAAUE,UAAS;AAChB,EAAAA,SAAQ,wBAAwB,CAAC,YAAY,QAAQ,aAAaA,SAAQ;AAC1E,EAAAA,SAAQ,2BAA2B,CAAC,YAAY,EAAE,QAAQ,aAAaA,SAAQ;AAC/E,EAAAA,SAAQ,mBAAmB;AAAA,IACvB,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,EACT;AACA,EAAAA,SAAQ,uBAAuB;AAAA,IAC3B,KAAK;AAAA,IACL,KAAK;AAAA,IACL,IAAI;AAAA,EACR;AACA,EAAAA,SAAQ,cAAc;AACtB,EAAAA,SAAQ,mBAAmB;AAAA,IACvB,KAAK;AAAA,IACL,MAAM;AAAA,IACN,KAAM;AAAA,EACV;AACA,EAAAA,SAAQ,wBAAwB,CAAC,WAAW,cAAc,cAAc,MACpE,UAAU,CAAC,MAAM;AAAA;AAAA;AAAA,IAGb,UAAU,CAAC,MAAM;AAAA,MAEf,UAAU,UAAU,MAAM,MACxB,QAAQ,UAAU,UAAU,EAAE,CAAC,GAAGA,SAAQ,gBAAgB,IAEhE,cAAc;AACxB,GAAG,YAAY,UAAU,CAAC,EAAE;;;AChGrB,IAAM,qBAAqB,CAAC,KAAK,QAAQ;AAHhD,MAAAC;AAII,MAAI;AACJ,QAAM,YAAY,CAAC;AAKnB,QAAM,gBAAgB,2BAA2B,GAAG,EAAE,IAAI,UAAU;AACpE,QAAIA,MAAA,cAAc,CAAC,MAAf,gBAAAA,IAAkB,UAAS,OAAO;AAGlC,UAAM,cAAc,cAAc,MAAM;AACxC,UAAM,aAAa,IAAI,EAAE,MAAM,YAAY,OAAO,GAAG;AACrD,QAAI,CAAC,WAAW,QAAQ,cAAc,KAAK,CAAC,WAAW,WAAW;AAC9D,aAAO,gBAAgB,8BAA8B,OAAO,YAAY,UAAU,WAC9E,YAAY,QACV,UAAU,YAAY,KAAK,CAAC,CAAC;AAAA,IACvC;AACA,aAAS,WAAW;AAAA,EACxB;AACA,aAAW,SAAS,eAAe;AAC/B,QAAI,MAAM,SAAS;AACf,aAAO,gBAAgB,qBAAqB;AAChD,QAAI,MAAM,SAAS,KAAK;AACpB,UAAI,MAAM,UAAU,YAChB,MAAM,UAAU,YAChB,MAAM,UAAU;AAChB,wBAAgB,sCAAsC,MAAM,KAAK,CAAC;AACtE,gBAAU,aAAa,MAAM;AAC7B;AAAA,IACJ;AACA,QAAI,MAAM,SAAS,SAAS;AAExB,YAAM,MAAM,IAAI,EAAE,MAAM,MAAM,KAAK,GAAG;AACtC,YAAM,QAAQ,IAAI,EAAE,MAAM,MAAM,OAAO,GAAG;AAC1C,YAAM,sBAAsB,eAAe,KAAK,OAAO,IAAI,CAAC;AAC5D,UAAI,oBAAoB,UAAU;AAC9B,kBAAU,WAAW,OAAO,UAAU,UAAU,oBAAoB,QAAQ;AAAA,MAChF;AACA,UAAI,oBAAoB;AACpB,kBAAU,QAAQ,OAAO,UAAU,OAAO,oBAAoB,KAAK;AAAA,IAC3E,OACK;AACD,YAAM,QAAQ,IAAI,EAAE,MAAM,MAAM,OAAO,GAAG;AAC1C,YAAM,QAAQ,EAAE,KAAK,MAAM,KAAK,MAAM;AACtC,UAAI,MAAM,YAAY,OAAO;AACzB,cAAM,MAAM,MAAM,MAAM,OAAO;AAC/B,YAAI,eAAe;AACf,0BAAgB,oBAAoB,UAAU,MAAM,GAAG,CAAC,IAAI,GAAG,EAAE;AACrE,cAAM,OAAO,MAAM,OAAO;AAC1B,cAAM,UAAU,MAAM;AAAA,MAC1B;AACA,gBAAU,MAAM,IAAI,IAAI,OAAO,UAAU,MAAM,IAAI,GAAG,KAAK;AAAA,IAC/D;AAAA,EACJ;AACA,QAAM,gBAAgB,IAAI,EAAE,KAAK,aAAa,SAAS;AACvD,SAAO,IAAI,EAAE,OAAO;AAAA,IAChB,QAAQ;AAAA,IACR,YAAW,iCAAQ,MAAM,mBAAkB;AAAA,EAC/C,CAAC;AACL;AACO,IAAM,wCAAwC,CAAC,WAAW,iEAAiE,UAAU,MAAM,CAAC;AAC5I,IAAM,wBAAwB;AAC9B,IAAM,aAAa,CAAC,CAAC,KAAK,KAAK,MAAM;AACxC,QAAM,YAAY,SAAS,GAAG;AAC9B,MAAI,QAAQ,KAAK,KAAK,MAAM,CAAC,MAAM,KAAK;AACpC,QAAI,UAAU,SAAS;AACnB,sBAAgB,4BAA4B;AAChD,WAAO;AAAA,MACH,MAAM;AAAA,MACN,KAAK,UAAU;AAAA,MACf,OAAO,MAAM,CAAC;AAAA,MACd,SAAS,MAAM,CAAC;AAAA,IACpB;AAAA,EACJ;AACA,SAAO;AAAA,IACH,MAAM,UAAU;AAAA,IAChB,KAAK,UAAU;AAAA,IACf;AAAA,IACA,SAAS;AAAA,EACb;AACJ;AAEO,IAAM,+BAA+B;AAC5C,IAAM,WAAW,CAAC,QAAQ,OAAO,QAAQ,WAAW,EAAE,MAAM,YAAY,IAAI,IACtE,IAAI,GAAG,EAAE,MAAM,MACb,IAAI,GAAG,EAAE,MAAM,QAAQ,cACnB,EAAE,MAAM,YAAY,KAAK,GAAG,IAAI,MAAM,GAAG,EAAE,CAAC,IAAI,IAC9C;AAAA,EACE,MAAM;AAAA,EACN,KAAK,IAAI,MAAM,GAAG,EAAE;AACxB,IACF,IAAI,CAAC,MAAM,OAAO,IAAI,GAAG,EAAE,MAAM,MAC/B,EAAE,MAAM,SAAS,KAAK,IAAI,MAAM,GAAG,EAAE,EAAE,IACrC,IAAI,CAAC,MAAM,QAAQ,eAAe,IAAI,CAAC,MAAM,OAAO,IAAI,GAAG,EAAE,MAAM,MACjE,EAAE,MAAM,YAAY,KAAK,IAAI,MAAM,CAAC,EAAE,IACpC,QAAQ,SAAS,QAAQ,MAAM,EAAE,MAAM,KAAK,IAAI,IAC5C;AAAA,EACE,MAAM;AAAA,EACN,KAAK,QAAQ,UAAU,QACjB,QAAQ,QAAQ,MACZ;AACd;AACb,IAAM,gCAAgC,CAAC,QAAQ,8DAA8D,GAAG;;;ACzGhH,IAAM,uCAAuC,CAAC,QAAQ,wDAAwD,IAAI,MAAM,CAAC,CAAC;;;ACD1H,IAAM,iBAAiB;AAAA,EAC1B,KAAK;AAAA,EACL,MAAM;AACV;AACO,IAAM,iBAAiB;AAAA,EAC1B,KAAK;AAAA,EACL,MAAM;AACV;AAQO,IAAM,sBAAsB;AAAA,EAC/B,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AACV;AACO,IAAM,kCAAkC,CAAC,cAAc,cAAe,cAAc,KAAK,KAAK,WAAW,SAAS,EAAG;AACrH,IAAM,4BAA4B,CAAC,gBAAgB,WAAW,WAAW;AACzE,IAAM,wBAAwB,CAAC,KAAK,eAAe,oEAAoE,UAAU,GAAG,GAAG;AACvI,IAAM,mCAAmC,CAAC,eAAe,yEAAyE,UAAU;AAC5I,IAAM,iCAAiC,CAAC,WAAW,gBAAgB,OAAO,eAAe,yDAAyD,SAAS,GAAG,oBAAoB,cAAc,CAAC,KAAK,KAAK,GAAG,oBAAoB,UAAU,CAAC;;;ACzB7O,IAAM,mBAAmB,CAAC,MAAM,QAAQ,MAAM,kBAAkB,MAAM,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;AAC9F,IAAM,oBAAoB,CAAC,MAAM,QAAQ,GAAG,SAAS,aAAa;AAC9D,QAAM,WAAW,EAAE,oBAAoB;AAEvC,UAAQ,KAAK,SAAS,QAAQ,QAAQ,MAAM,GAAG,EAAE,CAAC;AAClD,WAAS,KAAK,SAAS,IAAI;AAC3B,MAAI,SAAS,cAAc,KAAK;AAC5B,QAAI,SAAS,WAAW,OAAO,QAAQ;AACnC,aAAO;AAAA,QACH,QAAQ;AAAA,QACR,WAAW,SAAS,QAAQ;AAAA,MAChC;AAAA,IACJ;AACA,WAAO,SAAS,MAAM,+BAA+B,MAAM,QAAQ,OAAO,CAAC;AAAA,EAC/E;AACA,MAAI,SAAS,cAAc;AACvB,WAAO,kBAAkB,MAAM,QAAQ,GAAG,SAAS,QAAQ;AAC/D,SAAO,SAAS,MAAM,0BAA0B,GAAG,CAAC;AACxD;AACO,IAAM,iCAAiC,CAAC,MAAM,QAAQ,YAAY,GAAG,IAAI,IAAI,OAAO,KAAK,IAAI,CAAC,sBAAsB,OAAO,MAAM,cAAc,QAAQ,MAAM,GAAG,QAAQ,WAAW,IAAI,KAAK,KAAK,QAAQ,KAAK,IAAI,CAAC,EAAE;;;AChBrN,IAAM,kBAAkB,CAAC,MAAM;AAClC,QAAM,QAAQ,EAAE,QAAQ,yBAAyB;AACjD,MAAI,UAAU;AACV,MAAE,UAAU,OAAO;AAAA;AAEnB,MAAE,OAAO,iBAAiB,GAAG,KAAK;AAC1C;AACO,IAAM,4BAA4B,CAAC,MAAM,GAAG,MAAM;AACrD,IAAE,QAAQ,wBAAwB;AAClC,QAAM,YAAY,EAAE,QAAQ,MAAM;AAClC,MAAI,cAAc;AACd,WAAO,EAAE,MAAM,+BAA+B,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC;AACrE,QAAM,aAAa,iBAAiB,MAAM,EAAE,QAAQ,CAAC;AACrD,QAAM,iBAAiB,WAAW,UAAU;AAE5C,IAAE,QAAQ,YAAY,mBAAmB,IAAI,EAAE,QAAQ,SAAS,CAAC,cAAc;AAC/E,SAAO,EAAE,GAAG,WAAW,MAAM;AACjC;AACA,IAAM,mBAAmB,CAAC,GAAG,UAAU,oBAAoB,GAAG,KAAK,KAC/D,4BAA4B,GAAG,KAAK,KACpC,EAAE,MAAM,UAAU,KAAK,2BAA2B,CAAC,IAC7C,MAAM,CAAC,MAAM,MACX,qCAAqC,KAAK,IACxC,yBAAyB,KAAK,CAAC;AAC7C,IAAM,sBAAsB,CAAC,GAAG,UAAU;AA5B1C,MAAAC;AA6BI,OAAIA,MAAA,EAAE,IAAI,SAAN,gBAAAA,IAAa;AACb,WAAO,EAAE,IAAI,KAAK,KAAK,EAAE;AAC7B,QAAM,aAAa,EAAE,IAAI,EAAE,aAAa,KAAK;AAC7C,MAAI,sBAAsB;AACtB,WAAO;AACX,MAAI,eAAe;AACf;AACJ,MAAI,WAAW,YAAY,SAAS;AAChC,WAAO,0BAA0B,OAAO,YAAY,CAAC;AACzD,SAAO,gBAAgB,yBAAyB,UAAU,UAAU,CAAC,EAAE;AAC3E;AACA,IAAM,8BAA8B,CAAC,GAAG,UAAU;AAC9C,QAAM,cAAc,eAAe,OAAO,EAAE,QAAQ,KAAK,CAAC;AAC1D,MAAI,gBAAgB;AAChB,WAAO,EAAE,IAAI,EAAE,KAAK,QAAQ,EAAE,MAAM,YAAY,CAAC;AACrD,QAAM,cAAc,yBAAyB,KAAK;AAClD,MAAI,gBAAgB;AAChB,WAAO,EAAE,IAAI,EAAE,KAAK,QAAQ,EAAE,MAAM,YAAY,CAAC;AACzD;AACO,IAAM,6BAA6B,CAAC,MAAM;AAC7C,QAAM,WAAW,EAAE,iBAAiB;AACpC,SAAO,WACH,gCAAgC,UAAU,EAAE,QAAQ,SAAS,IAC3D,+BAA+B,EAAE,QAAQ,SAAS;AAC5D;AACO,IAAM,kCAAkC,CAAC,OAAO,YAAY,OAAO,UAAU,KAAK,6BAA6B,YAAY,YAAY,SAAS,MAAM,EAAE;AACxJ,IAAM,iCAAiC,CAAC,cAAc,yBAAyB,YAAY,YAAY,SAAS,MAAM,EAAE;;;ACpDxH,IAAM,aAAa,CAAC,KAAK,QAAQ,0BAA0B,KAAK,GAAG,KAAK,kBAAkB,KAAK,GAAG;AAClG,IAAM,oBAAoB,CAAC,KAAK,QAAQ;AAC3C,MAAI,YAAY,CAAC,CAAC,CAAC;AACnB,MAAI,IAAI;AACR,SAAO,IAAI,IAAI,QAAQ;AACnB,QAAI,SAAS;AACb,QAAI,WAAW;AACf,QAAI,IAAI,CAAC,MAAM,SAAS,IAAI,IAAI,SAAS,GAAG;AACxC,eAAS;AACT;AAAA,IACJ;AACA,UAAM,UAAU,IAAI,EAAE,MAAM,IAAI,CAAC,GAAG,GAAG;AACvC;AACA,QAAI,IAAI,CAAC,MAAM,KAAK;AAChB,UAAI;AACA,eAAO,gBAAgB,qBAAqB;AAChD,iBAAW;AACX;AAAA,IACJ;AACA,QAAI,QAAQ;AACR,UAAI,CAAC,QAAQ,QAAQ,UAAU,KAAK;AAChC,eAAO,gBAAgB,2BAA2B,QAAQ,UAAU,CAAC;AAIzE,kBAAY,UAAU,QAAQ;AAAA;AAAA,QAE9B,QAAQ,SAAS,IAAI,YAAU,mBAAmB,kCAAkC,IAAI,GAAG,MAAM,CAAC;AAAA,OAAC;AAAA,IACvG,OACK;AACD,kBAAY,UAAU,IAAI,UAAQ,cAAc,MAAM,WAAW,aAAa,YAAY,OAAO,CAAC;AAAA,IACtG;AAAA,EACJ;AACA,SAAO,IAAI,EAAE,IAAI,OAAO,UAAU,IAAI,eAAa;AAAA,IAC/C,OAAO;AAAA,IACP;AAAA,EACJ,EAAE,CAAC;AACP;AACA,IAAM,gBAAgB,CAAC,MAAM,MAAM,YAAY;AAC3C,UAAQ,MAAM;AAAA,IACV,KAAK;AACD,UAAI,KAAK;AAEL,eAAO,gBAAgB,2BAA2B;AACtD,UAAI,KAAK,UAAU;AAEf,aAAK,UAAU,OAAO,KAAK,SAAS,OAAO;AAAA,MAC/C,OACK;AAED,aAAK,SAAS,OAAO,KAAK,QAAQ,OAAO;AAAA,MAC7C;AACA,aAAO;AAAA,IACX,KAAK;AACD,UAAI,KAAK;AAEL,eAAO,gBAAgB,2BAA2B;AAEtD,WAAK,YAAY,OAAO,KAAK,WAAW,OAAO;AAC/C,aAAO;AAAA,IACX,KAAK;AAED,UAAI,KAAK;AACL,wBAAgB,sBAAsB;AAC1C,UAAI,KAAK,UAAU;AACf,YAAI,CAAC,KAAK,SAAS,OAAO,OAAO,GAAG;AAEhC,0BAAgB,sBAAsB;AAAA,QAC1C;AAAA,MAGJ,OACK;AAED,aAAK,WAAW,QAAQ;AAAA,MAC5B;AACA,aAAO;AAAA,EACf;AACJ;AACA,IAAM,qBAAqB,CAAC,MAAM,WAAW;AACzC,QAAM,SAAS,OAAO,qBAAqB,UAAU;AACrD,MAAI,CAAC,QAAQ;AAET,WAAO,cAAc,MAAM,YAAY,WAAW,OAAO;AAAA,EAC7D;AACA,SAAO,OAAO,QAAQ,CAAAC,UAAQ,cAAc,MAAM,YAAYA,KAAI,CAAC;AACnE,SAAO,UAAU,QAAQ,CAAAA,UAAQ,cAAc,MAAM,YAAYA,KAAI,CAAC;AACtE,SAAO,YAAY,cAAc,MAAM,YAAY,OAAO,QAAQ;AAClE,SAAO,QAAQ,QAAQ,CAAAA,UAAQ,cAAc,MAAM,YAAYA,KAAI,CAAC;AACpE,SAAO;AACX;AACA,IAAM,4BAA4B,CAAC,KAAK,QAAQ;AAC5C,QAAM,wBAAwB,sBAAsB,GAAG,IAAI,cAAc,IAAI,CAAC,CAAC,EAAE,KAAK,GAAG,IACnF,qBAAqB,GAAG,IAAI,gBAAgB,IAAI,CAAC,CAAC,EAAE,KAAK,GAAG,IACxD;AACV,SAAO;AACX;AACO,IAAM,6BAA6B,CAAC,YAAY,wCAAwC,OAAO;AAC/F,IAAM,yBAAyB;AAC/B,IAAM,8BAA8B;AACpC,IAAM,8BAA8B;AACpC,IAAM,wBAAwB;AAC9B,IAAM,kBAAkB,CAAC,KAAK,QAAQ,IAAI,EAAE,MAAM,IAAI,CAAC,GAAG,GAAG,EAAE,MAAM;AAC5E,IAAM,mBAAmB,CAAC,KAAK,QAAQ;AACnC,MAAI,IAAI,CAAC,MAAM;AACX,WAAO,gBAAgB,gCAAgC,IAAI,CAAC,GAAG,EAAE,CAAC;AACtE,QAAM,IAAI,IAAI,EAAE,MAAM,IAAI,CAAC,GAAG,GAAG;AACjC,QAAM,IAAI,IAAI,EAAE,MAAM,IAAI,CAAC,GAAG,GAAG;AACjC,SAAO,IAAI,CAAC,MAAM,MAAM,EAAE,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC;AAC7C;AACA,IAAM,kBAAkB,CAAC,KAAK,QAAQ,IAAI,EAAE,MAAM,IAAI,CAAC,GAAG,GAAG,EAAE,MAAM;AACrE,IAAM,uBAAuB,CAAC,QAAQ,gBAAgB,IAAI,CAAC,CAAC,MAAM;AAC3D,IAAM,kBAAkB,CAAC,KAAK,QAAQ;AACzC,MAAI,OAAO,IAAI,CAAC,MAAM,YAAY;AAC9B,WAAO,gBAAgB,0CAA0C,MAAM,IAAI,CAAC,CAAC,CAAC;AAAA,EAClF;AAEA,SAAO,IAAI,EAAE,MAAM,IAAI,CAAC,GAAG,GAAG,EAAE,KAAK,IAAI,CAAC,CAAC;AAC/C;AACO,IAAM,4CAA4C,CAAC,UAAU,UAAU,GAAG,aAAa,MAAM,WAAW,OAAO,8CAA8C,QAAQ,UAAU,OAAO,KAAK;AAC3L,IAAM,mBAAmB,CAAC,KAAK,QAAQ;AAC1C,MAAI,OAAO,IAAI,CAAC,MAAM,YAAY;AAC9B,WAAO,gBAAgB,0CAA0C,KAAK,IAAI,CAAC,CAAC,CAAC;AAAA,EACjF;AACA,SAAO,IAAI,EAAE,MAAM,IAAI,CAAC,GAAG,GAAG,EAAE,UAAU,aAAa,IAAI,CAAC,CAAC;AACjE;AACA,IAAM,sBAAsB,CAAC,KAAK,QAAQ,IAAI,EAAE,MAAM,IAAI,CAAC,GAAG,GAAG,EAAE,4BAA4B,IAAI,CAAC,CAAC;AACrG,IAAM,kBAAkB;AAAA,EACpB,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AACT;AACA,IAAM,gBAAgB;AAAA,EAClB,OAAO;AAAA,EACP,YAAY,CAAC,KAAK,QAAQ;AACtB,QAAI,OAAO,IAAI,CAAC,MAAM,YAAY;AAC9B,aAAO,gBAAgB,+BAA+B,qBAAqB,IAAI,CAAC,CAAC,CAAC,CAAC;AAAA,IACvF;AACA,UAAM,WAAW,IACZ,MAAM,CAAC,EACP,IAAI,UAAQ,OAAO,SAAS,aAC7B,IAAI,EAAE,KAAK,SAAS,EAAE,OAAO,KAAK,CAAC,IACjC,gBAAgB,+BAA+B,qBAAqB,IAAI,CAAC,CAAC,CAAC;AACjF,WAAO,SAAS,WAAW,IACvB,SAAS,CAAC,IACR,IAAI,EAAE,KAAK,SAAS,EAAE,SAAS,CAAC;AAAA,EAC1C;AAAA,EACA,OAAO,CAAC,KAAK,QAAQ,IAAI,EAAE,MAAM,IAAI,MAAM,CAAC,CAAC;AACjD;AACA,IAAM,wBAAwB,CAAC,QAAQ,cAAc,IAAI,CAAC,CAAC,MAAM;AAC1D,IAAM,iCAAiC,CAAC,WAAW,+DAA+D,MAAM;;;ACxJxH,IAAM,cAAc,CAAC,KAAK,QAAQ;AACrC,QAAM,aAAa,aAAa,GAAG;AACnC,UAAQ,YAAY;AAAA,IAChB,KAAK;AACD,UAAI,WAAW,KAAK,MAAM;AACtB,eAAO;AACX,aAAO,mBAAmB,KAAK,GAAG;AAAA,IACtC,KAAK;AACD,aAAO,WAAW,KAAK,GAAG;AAAA,IAC9B,KAAK;AACD,aAAO,IAAI,EAAE,KAAK,gBAAgB;AAAA,QAC9B,QAAQ;AAAA,QACR,OAAO;AAAA,MACX,GAAG,EAAE,YAAY,KAAK,CAAC;AAAA,IAC3B,KAAK,YAAY;AACb,YAAM,cAAc,QAAQ,GAAG,IAAI,IAAI,IAAI;AAC3C,UAAI,WAAW,aAAa,MAAM;AAC9B,eAAO;AACX,aAAO,gBAAgB,8BAA8B,UAAU,CAAC;AAAA,IACpE;AAAA,IACA;AACI,aAAO,gBAAgB,8BAA8B,cAAc,UAAU,GAAG,CAAC,CAAC;AAAA,EAC1F;AACJ;AACO,IAAM,gCAAgC,CAAC,WAAW,oDAAoD,MAAM;;;AC3B5G,IAAM,gBAAgB,CAAC,UAAU,OAAO,UAAU,YACrD,MAAM,CAAC,MAAM,QACZ,MAAM,CAAC,MAAM,OAAO,MAAM,CAAC,MAAM,QAClC,MAAM,GAAG,EAAE,MAAM,MAAM,CAAC;AACrB,IAAM,cAAc,CAAC,MAAM,EAAE,SAAS,MAAM;AAC5C,IAAM,2BAA2B,CAAC,YAAY,QAAQ,MAAM,GAAG,EAAE;AACjE,IAAM,0BAA0B,CAAC,WAAW,IAAI,MAAM;AACtD,IAAM,eAAe,CAAC,QAAQ,gBAAgB,eAAe,QAAQ,WAAW;AACvF,IAAM,iBAAiB,CAAC,QAAQ,gBAAgB;AAC5C,QAAM,mBAAmB,IAAI,KAAK,MAAM;AACxC,MAAI,YAAY,gBAAgB;AAC5B,WAAO;AACX,QAAM,cAAc,eAAe,MAAM;AACzC,MAAI,gBAAgB,QAAW;AAC3B,UAAM,mBAAmB,IAAI,KAAK,WAAW;AAC7C,QAAI,YAAY,gBAAgB;AAC5B,aAAO;AAAA,EACf;AACA,SAAO,cACH,gBAAgB,gBAAgB,OAAO,wBAAwB,MAAM,IAAI,WAAW,IAClF;AACV;;;AClBO,IAAM,aAAa,CAAC,GAAG,UAAU;AACpC,QAAM,aAAa,gBAAgB,GAAG,KAAK;AAC3C,MAAI,EAAE,KAAK,QAAQ,MAAM,GAAG;AACxB,QAAI,OAAO,EAAE,KAAK,SAAS,UAAU;AACjC,QAAE,gBAAgB,EAAE,KAAK,MAAM,UAAU;AACzC,QAAE,UAAU;AACZ;AAAA,IACJ;AACA,QAAI,EAAE,KAAK,gBAAgB,MAAM;AAC7B,YAAM,UAAU,KAAK,EAAE,KAAK,eAAe,EAAE,KAAK,KAAK,YAAY,CAAC;AACpE,QAAE,UAAU;AACZ,QAAE,gBAAgB,SAAS,UAAU;AACrC;AAAA,IACJ;AAAA,EACJ;AACA,SAAO,gBAAgB,GAAG,UAAU;AACxC;AACA,IAAM,qBAAqB;AAAA,EACvB,KAAK;AAAA,EACL,KAAK;AACT;AACO,IAAM,uBAAuB;AAAA,EAChC,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AACT;AACA,IAAM,kBAAkB,CAAC,GAAG,UAAU,EAAE,QAAQ,YAAY,GAAG,IAAI,GAAG,KAAK,GAAG,EAAE,QAAQ,MAAM,CAAC,KACzF,QAAQ,OAAO,kBAAkB,IAAI,QACjC,EAAE,MAAM,mBAAmB;AAE9B,IAAM,gBAAgB,CAAC,YAAY,OAAOC,OAAM,cAAc;AACjE,MAAIA,MAAK,QAAQ,WAAW,MAAM,GAAG;AACjC,QAAI,OAAO,UAAU,UAAU;AAC3B,aAAO,gBAAgB,yBAAyB,YAAY,OAAO,SAAS,CAAC;AAAA,IACjF;AACA,WAAQ,eAAe,OAAO,CAAC,OAAO,KAAK,IACrC,WAAW,CAAC,MAAM,MAAM,CAAC,KAAK,IAC1B,CAAC,KAAK;AAAA,EACpB;AACA,MAAIA,MAAK,QAAQ,iBAAiB,eAAe,GAAG;AAChD,QAAI,OAAO,UAAU,UAAU;AAC3B,aAAO,gBAAgB,yBAAyB,YAAY,OAAO,SAAS,CAAC;AAAA,IACjF;AACA,WAAQ,eAAe,OAAO,CAAC,aAAa,WAAW,IACjD,WAAW,CAAC,MAAM,MAAM,CAAC,WAAW,IAChC,CAAC,WAAW;AAAA,EAC1B;AACA,MAAIA,MAAK,QAAQ,UAAU,IAAI,GAAG;AAE9B,WAAQ,eAAe,OAAO,CAAC,SAAS,QAAQ,IAC1C,WAAW,CAAC,MAAM,MAAM,CAAC,OAAO,IAC5B,CAAC,QAAQ;AAAA,EACvB;AACA,SAAO,gBAAgB,wBAAwBA,MAAK,UAAU,CAAC;AACnE;AACO,IAAM,sBAAsB;AACnC,IAAM,sBAAsB,CAAC,eAAe;AAAA,EACxC,MAAM,cAAc,UAAU,KAAK,IAC/B,yBAAyB,UAAU,KAAK,IACtC,UAAU;AAAA,EAChB,WAAW,UAAU,WAAW,WAAW;AAC/C;AACO,IAAM,kBAAkB,CAAC,GAAG,eAAe;AAE9C,QAAM,eAAe,EAAE,UAAU;AACjC,QAAM,uBAAuB,EAAE,QAAQ;AACvC,IAAE,aAAa;AACf,QAAM,YAAY,EAAE,UAAU;AAG9B,QAAM,aAAa,EAAE,QAAQ,WAAW,sBAAsB,EAAE,QAAQ,QAAQ;AAChF,IAAE,OAAO;AACT,MAAI,CAAC,UAAU,QAAQ,MAAM,KACxB,OAAO,UAAU,SAAS,YAAY,EAAE,UAAU,gBAAgB;AACnE,WAAO,EAAE,MAAM,yBAAyB,YAAY,YAAY,OAAO,CAAC;AAC5E,QAAM,QAAQ,UAAU;AAExB,QAAM,YAAY,WAAW,WAAW;AAExC,aAAW,QAAQ,cAAc,YAAY,OAAO,UAAU,WAAW,QAAQ,YAAY,cAAc,OAAO;AAC9G,MAAE,cAAc,MAAM,EAAE,MAAM,OAAO,UAAU,CAAC;AACpD,MAAI,CAAC,EAAE,SAAS;AACZ;AAEJ,MAAI,CAAC,QAAQ,YAAY,cAAc;AACnC,WAAO,EAAE,MAAM,iCAAiC,UAAU,CAAC;AAC/D,QAAM,iBAAiB,cAAc,EAAE,SAAS,UAAU,YAAY,EAAE,SAAS,UAAU,OAAO,cAAc,MAAM;AACtH,IAAE,cAAc,eAAe,CAAC,GAAG,oBAAoB,EAAE,SAAS,SAAS,CAAC;AAC5E,IAAE,SAAS,YAAY;AAC3B;AACO,IAAM,2BAA2B,CAAC,YAAY,OAAO,cAAc,cAAc,cAAc,SAAS,oBAAoB,UAAU,IAAI,UAAU,YAAY,cAAc,SAAS,aAAa,UAAU,oCAAoC,KAAK;;;AC7FvP,IAAM,eAAe,CAAC,MAAM;AAC/B,QAAM,eAAe,EAAE,QAAQ,yBAAyB;AACxD,QAAM,UAAU,gBAAgB,cAAc;AAAA,IAC1C,aAAa,2BAA2B,YAAY;AAAA,EACxD,CAAC;AACD,MAAI,YAAY;AACZ,MAAE,MAAM,2BAA2B,CAAC,CAAC;AACzC,IAAE,OAAO,EAAE,KAAK,UAAU,WAAW,OAAO;AAChD;AACO,IAAM,6BAA6B,CAAC,YAAY,kEAAkE,OAAO;;;ACNzH,IAAM,gBAAgB,CAAC,MAAM;AAChC,QAAM,YAAY,EAAE,QAAQ,MAAM;AAClC,SAAQ,cAAc,KAAK,EAAE,SAAS,EAAE,IAClC,cAAc,MACZ,EAAE,QAAQ,MAAM,MAAM,MAClB,EAAE,QAAQ,EAAE,KAAK,MAAM,CAAC,IACtB,EAAE,MAAM,2BAA2B,IACvC,cAAc,OAAO,cAAc,MAAM,EAAE,iBAAiB,SAAS,IACjE,cAAc,MAAM,EAAE,cAAc,IAChC,QAAQ,sBAAsB,WAAW,EAAE,QAAQ,SAAS,IAC1D,EAAE,SAAS,SAAS,IAClB,QAAQ,WAAW,oBAAoB,IAAI,WAAW,GAAG,SAAS,IAC9D,cAAc,MAAM,aAAa,CAAC,IAC9B,cAAc,MAAM,cAAc,CAAC,IAC/B,EAAE,MAAM,gCAAgC,SAAS,CAAC;AACxF;AACO,IAAM,kCAAkC,CAAC,MAAM,WAAW,OAAO,IAAI,IAAI,wBAAwB,YAAY,eAAe,QAAQ,GAAG;AACvI,IAAM,8BAA8B;;;AClBpC,IAAM,qBAAqB,CAAC,QAAQ,oBAAoB,IAAI,QAAQ,GAAG,CAAC;AACxE,IAAM,+BAA+B;AAC5C,IAAM,sBAAsB,CAAC,YAAY;AACrC,QAAM,QAAQ,QAAQ,yBAAyB;AAC/C,MAAI,UAAU;AACV,oBAAgB,4BAA4B;AAChD,UAAQ,wBAAwB;AAChC,QAAM,oBAAoB,QAAQ,MAAM;AACxC,SAAQ,sBAAsB,KAAK,CAAC,KAAK,IACnC,sBAAsB,MAAM,CAAC,OAAO,GAAG,oBAAoB,OAAO,CAAC,IAC/D,gBAAgB,gCAAgC,mBAAmB,GAAG,CAAC;AACrF;;;ACZO,IAAM,gBAAgB,CAAC,GAAG,cAAc;AAC3C,QAAM,WAAW,EAAE,QAAQ,WAAW,wBAAwB,gBAAgB,SAAS,CAAC,CAAC;AACzF,MAAI,EAAE,QAAQ,cAAc;AACxB,WAAO,EAAE,MAAM,iCAAiC,UAAU,SAAS,CAAC;AAExE,IAAE,QAAQ,MAAM;AAChB,MAAI,cAAc,KAAK;AAEnB,QAAI,OAAO,QAAQ;AACnB,MAAE,OAAO,EAAE,IAAI,EAAE,KAAK,gBAAgB;AAAA,MAClC,QAAQ;AAAA,MACR,OAAO;AAAA,IACX,GAAG,EAAE,YAAY,KAAK,CAAC;AAAA,EAC3B,WACS,QAAQ,WAAW,cAAc;AACtC,MAAE,OAAO,EAAE,IAAI,EAAE,KAAK,QAAQ,EAAE,MAAM,SAAS,CAAC;AAAA,OAC/C;AACD,UAAMC,QAAO,aAAa,UAAU,wBAAwB,QAAQ,CAAC;AACrE,MAAE,OAAO,EAAE,IAAI,EAAE,KAAK,QAAQ,EAAE,MAAMA,OAAM,aAAa,SAAS,CAAC;AAAA,EACvE;AACJ;AACO,IAAM,iBAAiB;AAAA,EAC1B,KAAK;AAAA,EACL,KAAK;AACT;AACO,IAAM,gBAAgB;AAAA,EACzB,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AACT;AACO,IAAM,kBAAkB;AAAA,EAC3B,MAAM;AAAA,EACN,MAAM;AAAA,EACN,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AACT;AACO,IAAM,0BAA0B;AAAA,EACnC,KAAK,aAAW,QAAQ,cAAc;AAAA,EACtC,KAAK,aAAW,QAAQ,cAAc;AAAA,EACtC,KAAK,aAAW,QAAQ,cAAc;AAC1C;AACA,IAAM,4BAA4B;AAAA,EAC9B,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AACT;AACO,IAAM,mCAAmC,CAAC,UAAU,mBAAmB,GAAG,cAAc,GAAG,QAAQ,uBAAuB,0BAA0B,gBAAgB,cAAc,CAAC,CAAC;;;AC9CpL,IAAM,eAAe,CAAC,MAAM,EAAE,QAAQ,cAAc,KAAK,EAAE,MAAM,2BAA2B,CAAC,CAAC,IAC/F,EAAE,QAAQ,cAAc,MAAM,EAAE,aAAa,EAAE,gBAAgB,IAC3D,EAAE,QAAQ,cAAc,aAAa,IAAI,cAAc,GAAG,EAAE,QAAQ,MAAM,CAAC,IACvE,EAAE,QAAQ,cAAc,QAAQ,gBAAgB,IAC9C,aAAa,EAAE,aAAa,CAAC,IAC3B,EAAE,QAAQ,cAAc,MACtB,EAAE,QAAQ,iBAAiB,iBACvB,cAAc,GAAG,GAAG,EAAE,QAAQ,MAAM,CAAC,GAAG,EAAE,QAAQ,MAAM,CAAC,EAAE,IACzD,gBAAgB,CAAC,IACrB,gBAAgB,CAAC;;;ACVhC,IAAM,kBAAkB,CAAC,MAAM;AAClC,IAAE,aAAa;AACf,QAAM,SAAS,oBAAoB,CAAC,EAAE;AACtC,MAAI,CAAC,QAAQ;AACT,WAAO,mBAAmB,qDAAqD,EAAE,QAAQ,OAAO,GAAG;AAAA,EACvG;AACA,IAAE,QAAQ,wBAAwB;AAClC,MAAI,EAAE,QAAQ,WAAW;AAErB,oBAAgB,gCAAgC,EAAE,QAAQ,SAAS,CAAC;AAAA,EACxE;AACA,SAAO;AACX;AACO,IAAM,sBAAsB,CAAC,MAAM;AACtC,SAAO,EAAE,cAAc;AACnB,SAAK,CAAC;AACV,SAAO;AACX;AACA,IAAM,OAAO,CAAC,MAAM,EAAE,QAAQ,IAAI,EAAE,cAAc,IAAI,EAAE,aAAa;;;ACd9D,IAAM,eAAN,MAAM,cAAa;AAAA,EAatB,YAAY,KAAK,KAAK;AAZtB;AACA;AAEA;AAAA;AACA,oCAAW;AAAA,MACP,UAAU,CAAC;AAAA,MACX,WAAW;AAAA,MACX,cAAc;AAAA,MACd,OAAO;AAAA,IACX;AACA;AACA,kCAAS,CAAC;AAEN,SAAK,MAAM;AACX,SAAK,UAAU,IAAI,QAAQ,GAAG;AAAA,EAClC;AAAA,EACA,MAAM,SAAS;AACX,WAAO,gBAAgB,OAAO;AAAA,EAClC;AAAA,EACA,UAAU;AACN,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA,EACA,QAAQC,OAAM;AACV,SAAK,OAAOA;AAAA,EAChB;AAAA,EACA,YAAY;AACR,UAAM,QAAQ,KAAK;AACnB,SAAK,OAAO;AACZ,WAAO;AAAA,EACX;AAAA,EACA,iBAAiB,MAAM;AACnB,SAAK,OAAO,KAAK,KAAK,UAAU,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAAA,EACpD;AAAA,EACA,SAAS,WAAW;AAChB,QAAI,KAAK,OAAO;AACZ,aAAO,KAAK,MAAM,0BAA0B,GAAG,CAAC;AACpD,SAAK,iBAAiB;AACtB,SAAK,YAAY;AAAA,EACrB;AAAA,EACA,gBAAgB,OAAO,YAAY;AAC/B,UAAM,qBAAqB,oBAAoB,UAAU;AACzD,QAAI,CAAC,QAAQ,oBAAoB,cAAc;AAC3C,aAAO,KAAK,MAAM,iCAAiC,UAAU,CAAC;AAClE,QAAI,KAAK,SAAS,WAAW;AACzB,aAAO,KAAK,MAAM,+BAA+B,KAAK,SAAS,UAAU,OAAO,KAAK,SAAS,UAAU,YAAY,OAAO,kBAAkB,CAAC;AAAA,IAClJ;AACA,SAAK,SAAS,YAAY;AAAA,MACtB,YAAY;AAAA,MACZ;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,mBAAmB;AACf,SAAK,iBAAiB;AACtB,QAAI,KAAK,SAAS,OAAO;AACrB,WAAK,iBAAiB,GAAG;AACzB,WAAK,OAAO,KAAK,SAAS;AAAA,IAC9B,WACS,KAAK,SAAS,cAAc;AACjC,WAAK,iBAAiB,GAAG;AACzB,WAAK,OAAO,KAAK,SAAS;AAAA,IAC9B;AAEI,WAAK,cAAc;AAAA,EAC3B;AAAA,EACA,gBAAgB;AACZ,SAAK,iBAAiB;AACtB,UAAM,iBAAiB,KAAK,OAAO,IAAI;AACvC,QAAI,CAAC;AACD,aAAO,KAAK,MAAM,gCAAgC,KAAK,QAAQ,SAAS,CAAC;AAC7E,SAAK,WAAW;AAAA,EACpB;AAAA,EACA,UAAU,QAAQ;AACd,SAAK,SAAS,SAAS,KAAK,MAAM;AAAA,EACtC;AAAA,EACA,gBAAgB;AACZ,WAAO,KAAK,SAAS,SAAS,QAAQ;AAClC,YAAM,aAAa,KAAK,SAAS,SAAS,IAAI;AAC9C,WAAK,OACD,eAAe,UACX,KAAK,KAAK,MAAM,IACd,mBAAmB,sBAAsB,UAAU,GAAG;AAAA,IACpE;AAAA,EACJ;AAAA,EACA,iBAAiB,OAAO;AA1F5B,QAAAC,KAAAC;AA2FQ,SAAK,iBAAiB;AACtB,SAAK,cAAc;AACnB,UAAMF,QAAO,KAAK;AAClB,SAAK,SAAS,iBAAeC,MAAA,KAAK,SAAS,iBAAd,gBAAAA,IAA4B,IAAID,WAASA;AACtE,QAAI,UAAU,KAAK;AACf,WAAK,SAAS,UACVE,MAAA,KAAK,SAAS,UAAd,gBAAAA,IAAqB,GAAG,KAAK,SAAS,kBAClC,KAAK,SAAS;AACtB,WAAK,SAAS,eAAe;AAAA,IACjC;AACA,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,sBAAsB;AAClB,WAAO,oBAAoB,IAAI,cAAa,KAAK,QAAQ,WAAW,KAAK,GAAG,CAAC;AAAA,EACjF;AAAA,EACA,gBAAgB;AACZ,WAAO,cAAc,IAAI;AAAA,EAC7B;AAAA,EACA,eAAe;AACX,WAAO,aAAa,IAAI;AAAA,EAC5B;AAAA,EACA,mBAAmB;AACf,QAAI,KAAK,SAAS,WAAW;AACzB,aAAO,KAAK,MAAM,sBAAsB,KAAK,SAAS,UAAU,OAAO,KAAK,SAAS,UAAU,UAAU,CAAC;AAAA,IAC9G;AAAA,EACJ;AAAA,EACA,kBAAkB;AACd,SAAK,OAAO,KAAK,KAAK,QAAQ;AAC9B,SAAK,WAAW;AAAA,MACZ,UAAU,CAAC;AAAA,MACX,WAAW;AAAA,MACX,OAAO;AAAA,MACP,cAAc;AAAA,IAClB;AAAA,EACJ;AAAA,EACA,mBAAmB;AA9HvB,QAAAD;AA+HQ,aAAQA,MAAA,KAAK,SAAS,cAAd,gBAAAA,IAAyB,eAC7B,KAAK,SAAS,SAAS,GAAG,EAAE,MAC3B,KAAK,SAAS,eAAe,MACxB,KAAK,SAAS,QAAQ,MAClB;AAAA,EAClB;AAAA,EACA,eAAe;AACX,SAAK,QAAQ,MAAM;AACnB,WAAO;AAAA,EACX;AACJ;;;ACrIA,IAAM,wBAAwB,OAAO,OAAO;AAAA,EACxC,QAAQ;AACZ,CAAC;AACM,IAAM,gBAAN,cAA4B,SAAS;AAAA,EACxC,YAAY,GAAG;AACX,UAAM,IAAI,SAAS;AACf,UAAI,KAAK,WAAW,GAAG;AAEnB,eAAO,EAAE,UAAU,KAAK,CAAC,CAAC;AAAA,MAC9B;AACA,UAAI,KAAK,WAAW,KAChB,OAAO,KAAK,CAAC,MAAM,YACnB,KAAK,CAAC,EAAE,CAAC,MAAM,OACf,KAAK,CAAC,EAAE,GAAG,EAAE,MAAM,KAAK;AAGxB,cAAM,SAAS,mBAAmB,KAAK,CAAC,EAAE,MAAM,GAAG,EAAE,CAAC;AACtD,cAAM,MAAM,KAAK,CAAC;AAElB,eAAO,IAAI,QAAQ,QAAQ,KAAK,CAAC;AAAA,MACrC;AAIA,aAAO,EAAE,UAAU,IAAI;AAAA,IAC3B,GAAG,EAAE,MAAM,GAAG,QAAQ,sBAAsB,CAAC;AAAA,EACjD;AACJ;AACO,IAAM,OAAO;;;ACvBb,IAAM,QAAS,CAAC,KAAK,SAAS,CAAC,MAAM,IAAI,SAAS,KAAK,MAAM;AAC7D,IAAM,WAAN,cAAuB,aAAa;AAAA,EAEvC,YAAY,KAAK,QAAQ;AACrB,UAAM,UAAU,CAAC;AACjB,eAAW,KAAK,KAAK;AACjB,YAAM,YAAY,cAAc,CAAC;AACjC,cAAQ,UAAU,IAAI,IAClB,UAAU,OAAO;AAAA;AAAA,QAEb,IAAI,QAAQ,UAAU,QAAQ,IAAI,CAAC,GAAG,CAAC,CAAC;AAAA,UACtC,IAAI,CAAC;AAAA,IACnB;AACA,UAAM,SAAS,MAAM;AAXzB,sCAAa,CAAC;AAad,gCAAO,IAAI,cAAc,IAAI;AAC7B,iCAAQ,kBAAkB,IAAI;AAC9B,oCAAW,OAAO;AAAA,MACd,MAAM,KAAK;AAAA,IACf,IAAI,KAAK,IAAI;AACb,mCAAU,CAAC,QAAQ,KAAK,KAAK,IAAI;AAAA,EANjC;AAAA,EAOA,aAAa,KAAK;AACd,QAAI,QAAQ,GAAG,KAAK,CAAC,WAAW,KAAK,SAAS;AAC1C,aAAO,IAAI;AACf,WAAO;AAAA,EACX;AAAA,EACA,UAAU,KAAK;AAEX,WAAO,KAAK,MAAM,KAAK;AAAA,MACnB,GAAG;AAAA,MACH,MAAM,CAAC;AAAA;AAAA;AAAA,IAGX,CAAC,EAAE,UAAU,IAAI;AAAA,EACrB;AAAA,EACA,MAAM,KAAK,KAAK;AACZ,QAAI,OAAO,QAAQ,UAAU;AACzB,UAAI,IAAI,QAAQ,OAAO,KAAK,IAAI,IAAI,EAAE,MAAM,OAAK,CAAC,IAAI,SAAS,CAAC,CAAC,GAAG;AAGhE,eAAO,KAAK,YAAY,KAAK,GAAG;AAAA,MACpC;AACA,UAAI,CAAC,KAAK,WAAW,GAAG;AACpB,aAAK,WAAW,GAAG,IAAI,KAAK,YAAY,KAAK,GAAG;AACpD,aAAO,KAAK,WAAW,GAAG;AAAA,IAC9B;AACA,WAAO,UAAU,KAAK,QAAQ,IAC1B,YAAY,KAAK,GAAG,IAClB,gBAAgB,8BAA8B,SAAS,GAAG,CAAC,CAAC;AAAA,EACtE;AAAA,EACA,YAAY,KAAK,KAAK;AA3D1B,QAAAE;AA4DQ,WAAQ,KAAK,iBAAiB,GAAG,MAC3B,IAAI,SAAS,IAAI,OACfA,MAAA,KAAK,iBAAiB,IAAI,MAAM,GAAG,EAAE,CAAC,MAAtC,gBAAAA,IAAyC,YACzC,gBAAgB,IAAI,aAAa,KAAK,GAAG,CAAC;AAAA,EACtD;AACJ;AAEO,IAAM,gBAAgB,CAAC,MAAM;AAChC,QAAM,kBAAkB,EAAE,QAAQ,GAAG;AACrC,MAAI,oBAAoB,IAAI;AACxB,WAAO;AAAA,MACH,MAAM;AAAA,MACN,QAAQ,CAAC;AAAA,IACb;AAAA,EACJ;AACA,MAAI,EAAE,GAAG,EAAE,MAAM,KAAK;AAClB,oBAAgB,oEAAoE;AAAA,EACxF;AACA,SAAO;AAAA,IACH,MAAM,EAAE,MAAM,GAAG,eAAe;AAAA,IAChC,QAAQ,mBAAmB,EAAE,MAAM,kBAAkB,GAAG,EAAE,CAAC;AAAA,EAC/D;AACJ;;;AC/EO,IAAM,UAAU,MAAM,YAAY;AACzC,SAAS,UAAU,QAAQ;AACpB,IAAM,MAAM,QAAQ,OAAO;AAC3B,IAAM,OAAO,QAAQ;AACrB,IAAM,QAAQ,QAAQ;AACtB,IAAM,SAAS,QAAQ;AACvB,IAAM,UAAU,QAAQ;;;ACRxB,IAAM,SAAS;",
  "names": ["_a", "_a", "Hkt", "_a", "_b", "_a", "_b", "root", "_a", "_a", "_b", "node", "transformed", "_a", "_b", "schema", "root", "node", "_a", "_b", "schema", "node", "schema", "node", "greatestCommonDivisor", "root", "schema", "node", "schema", "node", "schema", "node", "schema", "node", "schema", "node", "schema", "node", "schema", "node", "schema", "node", "_a", "_b", "node", "schema", "kind", "_a", "schema", "node", "schema", "node", "_a", "node", "rawSchema", "schema", "schema", "node", "_a", "schema", "node", "__runInitializers", "__esDecorate", "schema", "node", "_a", "cases", "path", "kind", "node", "schema", "node", "schema", "node", "schema", "node", "schema", "node", "schema", "_a", "_b", "node", "__runInitializers", "__esDecorate", "_a", "_b", "node", "data", "node", "_a", "_b", "schema", "schema", "node", "json", "node", "__runInitializers", "__esDecorate", "schema", "_a", "_b", "id", "node", "cached", "node", "date", "url", "_a", "_b", "Scanner", "_a", "_a", "node", "root", "date", "root", "_a", "_b", "_a"]
}
