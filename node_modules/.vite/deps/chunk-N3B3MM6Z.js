import {
  HYDRATION_ANCHOR,
  HYDRATION_END,
  HYDRATION_ERROR,
  HYDRATION_START,
  PassiveDelegatedEvents,
  array_from,
  block,
  branch,
  current_component_context,
  current_effect,
  define_property,
  effect_root,
  flush_sync,
  get_proxied_value,
  hydration_failed,
  hydration_mismatch,
  is_array,
  lifecycle_double_unmount,
  pop,
  proxy,
  push,
  queue_micro_task,
  state_proxy_equality_mismatch,
  teardown,
  user_pre_effect,
  validate_component
} from "./chunk-LHNPR6KV.js";
import {
  DEV
} from "./chunk-PLGELRID.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-DWA4UIM3.js";

// node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/hydration.js
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
var hydrate_nodes = (
  /** @type {any} */
  null
);
var hydrate_start;
function set_hydrate_nodes(nodes) {
  hydrate_nodes = nodes;
  hydrate_start = nodes && nodes[0];
}
function hydrate_anchor(node) {
  var _a, _b;
  if (node.nodeType !== 8) {
    return node;
  }
  var current = (
    /** @type {Node | null} */
    node
  );
  if (
    /** @type {Comment} */
    current.data !== HYDRATION_START
  ) {
    return node;
  }
  var nodes = [];
  var depth = 0;
  while ((current = /** @type {Node} */
  current.nextSibling) !== null) {
    if (current.nodeType === 8) {
      var data = (
        /** @type {Comment} */
        current.data
      );
      if (data === HYDRATION_START) {
        depth += 1;
      } else if (data[0] === HYDRATION_END) {
        if (depth === 0) {
          hydrate_nodes = /** @type {import('#client').TemplateNode[]} */
          nodes;
          hydrate_start = /** @type {import('#client').TemplateNode} */
          nodes[0];
          return current;
        }
        depth -= 1;
      }
    }
    nodes.push(current);
  }
  let location;
  if (DEV) {
    const loc = (_b = (_a = node.parentNode) == null ? void 0 : _a.__svelte_meta) == null ? void 0 : _b.loc;
    if (loc) {
      location = `${loc.file}:${loc.line}:${loc.column}`;
    }
  }
  hydration_mismatch(location);
  throw HYDRATION_ERROR;
}

// node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes } = array_prototype;
  array_prototype.indexOf = function(item, from_index) {
    const index = indexOf.call(this, item, from_index);
    if (index === -1) {
      const test = indexOf.call(get_proxied_value(this), get_proxied_value(item), from_index);
      if (test !== -1) {
        state_proxy_equality_mismatch("array.indexOf(...)");
      }
    }
    return index;
  };
  array_prototype.lastIndexOf = function(item, from_index) {
    const index = lastIndexOf.call(this, item, from_index ?? this.length - 1);
    if (index === -1) {
      const test = lastIndexOf.call(
        get_proxied_value(this),
        get_proxied_value(item),
        from_index ?? this.length - 1
      );
      if (test !== -1) {
        state_proxy_equality_mismatch("array.lastIndexOf(...)");
      }
    }
    return index;
  };
  array_prototype.includes = function(item, from_index) {
    const has = includes.call(this, item, from_index);
    if (!has) {
      const test = includes.call(get_proxied_value(this), get_proxied_value(item), from_index);
      if (test) {
        state_proxy_equality_mismatch("array.includes(...)");
      }
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype.indexOf = indexOf;
    array_prototype.lastIndexOf = lastIndexOf;
    array_prototype.includes = includes;
  };
}
function strict_equals(a, b, equal = true) {
  if (a === b !== (get_proxied_value(a) === get_proxied_value(b))) {
    state_proxy_equality_mismatch(equal ? "===" : "!==");
  }
  return a === b === equal;
}
function equals(a, b, equal = true) {
  if (a == b !== (get_proxied_value(a) == get_proxied_value(b))) {
    state_proxy_equality_mismatch(equal ? "==" : "!=");
  }
  return a == b === equal;
}

// node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/operations.js
var $window;
var $document;
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  var element_prototype = Element.prototype;
  element_prototype.__click = void 0;
  element_prototype.__className = "";
  element_prototype.__attributes = null;
  element_prototype.__e = void 0;
  Text.prototype.__t = void 0;
  if (DEV) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
function empty() {
  return document.createTextNode("");
}
function child(node) {
  const child2 = node.firstChild;
  if (!hydrating) return child2;
  if (child2 === null) {
    return node.appendChild(empty());
  }
  return hydrate_anchor(child2);
}
function first_child(fragment, is_text) {
  var _a, _b;
  if (!hydrating) {
    return (
      /** @type {DocumentFragment} */
      fragment.firstChild
    );
  }
  if (is_text && ((_a = hydrate_start) == null ? void 0 : _a.nodeType) !== 3) {
    var text = empty();
    var dom = (
      /** @type {import('#client').TemplateNode[]} */
      /** @type {import('#client').Effect} */
      current_effect.dom
    );
    dom.unshift(text);
    (_b = hydrate_start) == null ? void 0 : _b.before(text);
    return text;
  }
  return hydrate_anchor(hydrate_start);
}
function sibling(node, is_text = false) {
  var next_sibling = (
    /** @type {import('#client').TemplateNode} */
    node.nextSibling
  );
  if (!hydrating) {
    return next_sibling;
  }
  var type = next_sibling.nodeType;
  if (type === 8 && /** @type {Comment} */
  next_sibling.data === HYDRATION_ANCHOR) {
    return sibling(next_sibling, is_text);
  }
  if (is_text && type !== 3) {
    var text = empty();
    var dom = (
      /** @type {import('#client').TemplateNode[]} */
      /** @type {import('#client').Effect} */
      current_effect.dom
    );
    dom.unshift(text);
    next_sibling == null ? void 0 : next_sibling.before(text);
    return text;
  }
  return hydrate_anchor(
    /** @type {Node} */
    next_sibling
  );
}
function clear_text_content(node) {
  node.textContent = "";
}
function create_element(name) {
  return document.createElement(name);
}

// node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/elements/events.js
function replay_events(dom) {
  if (!hydrating) return;
  if (dom.onload) {
    dom.removeAttribute("onload");
  }
  if (dom.onerror) {
    dom.removeAttribute("onerror");
  }
  const event2 = dom.__e;
  if (event2 !== void 0) {
    dom.__e = void 0;
    queueMicrotask(() => {
      if (dom.isConnected) {
        dom.dispatchEvent(event2);
      }
    });
  }
}
function create_event(event_name, dom, handler, options) {
  function target_handler(event2) {
    if (!options.capture) {
      handle_event_propagation(dom, event2);
    }
    if (!event2.cancelBubble) {
      return handler.call(this, event2);
    }
  }
  if (event_name.startsWith("pointer") || event_name === "wheel") {
    queue_micro_task(() => {
      dom.addEventListener(event_name, target_handler, options);
    });
  } else {
    dom.addEventListener(event_name, target_handler, options);
  }
  return target_handler;
}
function event(event_name, dom, handler, capture, passive) {
  var options = { capture, passive };
  var target_handler = create_event(event_name, dom, handler, options);
  if (dom === document.body || dom === window || dom === document) {
    teardown(() => {
      dom.removeEventListener(event_name, target_handler, options);
    });
  }
}
function delegate(events) {
  for (var i = 0; i < events.length; i++) {
    all_registered_events.add(events[i]);
  }
  for (var fn of root_event_handles) {
    fn(events);
  }
}
function handle_event_propagation(handler_element, event2) {
  var _a;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path = ((_a = event2.composedPath) == null ? void 0 : _a.call(event2)) || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  var path_idx = 0;
  var handled_at = event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  if (current_target === handler_element) return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated !== void 0 && !/** @type {any} */
        current_target.disabled) {
          if (is_array(delegated)) {
            var [fn, ...data] = delegated;
            fn.apply(current_target, [event2, ...data]);
          } else {
            delegated.call(current_target, event2);
          }
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    current_target = handler_element;
  }
}

// node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
var head_anchor;
function reset_head_anchor() {
  head_anchor = void 0;
}
function head(render_fn) {
  let previous_hydrate_nodes = null;
  let was_hydrating = hydrating;
  var anchor;
  if (hydrating) {
    previous_hydrate_nodes = hydrate_nodes;
    if (head_anchor === void 0) {
      head_anchor = /** @type {import('#client').TemplateNode} */
      document.head.firstChild;
    }
    while (head_anchor.nodeType !== 8 || /** @type {Comment} */
    head_anchor.data !== HYDRATION_START) {
      head_anchor = /** @type {import('#client').TemplateNode} */
      head_anchor.nextSibling;
    }
    head_anchor = /** @type {import('#client').TemplateNode} */
    hydrate_anchor(head_anchor);
    head_anchor = /** @type {import('#client').TemplateNode} */
    head_anchor.nextSibling;
  } else {
    anchor = document.head.appendChild(empty());
  }
  try {
    block(() => render_fn(anchor));
  } finally {
    if (was_hydrating) {
      set_hydrate_nodes(
        /** @type {import('#client').TemplateNode[]} */
        previous_hydrate_nodes
      );
    }
  }
}

// node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/render.js
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
var should_intro = true;
function set_should_intro(value) {
  should_intro = value;
}
function set_text(text, value) {
  const prev = text.__t ?? (text.__t = text.nodeValue);
  if (prev !== value) {
    text.nodeValue = text.__t = value;
  }
}
function slot(anchor, slot_fn, slot_props, fallback_fn) {
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn(anchor);
    }
  } else {
    slot_fn(anchor, slot_props);
  }
}
function mount(component, options) {
  if (DEV) {
    validate_component(component);
  }
  const anchor = options.anchor ?? options.target.appendChild(empty());
  return flush_sync(() => _mount(component, { ...options, anchor }), false);
}
function hydrate(component, options) {
  if (DEV) {
    validate_component(component);
  }
  const target = options.target;
  const previous_hydrate_nodes = hydrate_nodes;
  try {
    return flush_sync(() => {
      set_hydrating(true);
      var node = target.firstChild;
      while (node && (node.nodeType !== 8 || /** @type {Comment} */
      node.data !== HYDRATION_START)) {
        node = node.nextSibling;
      }
      if (!node) {
        throw HYDRATION_ERROR;
      }
      const anchor = hydrate_anchor(node);
      const instance = _mount(component, { ...options, anchor });
      set_hydrating(false);
      return instance;
    }, false);
  } catch (error) {
    if (error === HYDRATION_ERROR) {
      if (options.recover === false) {
        hydration_failed();
      }
      init_operations();
      clear_text_content(target);
      set_hydrating(false);
      return mount(component, options);
    }
    throw error;
  } finally {
    set_hydrating(!!previous_hydrate_nodes);
    set_hydrate_nodes(previous_hydrate_nodes);
    reset_head_anchor();
  }
}
function _mount(Component, { target, anchor, props = {}, events, context, intro = false }) {
  init_operations();
  const registered_events = /* @__PURE__ */ new Set();
  const bound_event_listener = handle_event_propagation.bind(null, target);
  const bound_document_event_listener = handle_event_propagation.bind(null, document);
  const event_handle = (events2) => {
    for (let i = 0; i < events2.length; i++) {
      const event_name = events2[i];
      if (!registered_events.has(event_name)) {
        registered_events.add(event_name);
        target.addEventListener(
          event_name,
          bound_event_listener,
          PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0
        );
        document.addEventListener(
          event_name,
          bound_document_event_listener,
          PassiveDelegatedEvents.includes(event_name) ? {
            passive: true
          } : void 0
        );
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  let component = void 0;
  const unmount2 = effect_root(() => {
    branch(() => {
      if (context) {
        push({});
        var ctx = (
          /** @type {import('#client').ComponentContext} */
          current_component_context
        );
        ctx.c = context;
      }
      if (events) {
        props.$$events = events;
      }
      should_intro = intro;
      component = Component(anchor, props) || {};
      should_intro = true;
      if (context) {
        pop();
      }
    });
    return () => {
      for (const event_name of registered_events) {
        target.removeEventListener(event_name, bound_event_listener);
        document.removeEventListener(event_name, bound_event_listener);
      }
      root_event_handles.delete(event_handle);
      mounted_components.delete(component);
    };
  });
  mounted_components.set(component, unmount2);
  return component;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component) {
  const fn = mounted_components.get(component);
  if (DEV && !fn) {
    lifecycle_double_unmount();
    console.trace("stack trace");
  }
  fn == null ? void 0 : fn();
}
function sanitize_slots(props) {
  const sanitized = { ...props.$$slots };
  if (props.children) sanitized.default = props.children;
  return sanitized;
}
async function append_styles(target, style_sheet_id, styles) {
  await Promise.resolve();
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = create_element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    const target2 = (
      /** @type {Document} */
      append_styles_to.head || append_styles_to
    );
    target2.appendChild(style);
  }
}
function get_root_for_style(node) {
  if (!node) return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return (
    /** @type {Document} */
    node.ownerDocument
  );
}

// node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
function asClassComponent(component) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options) {
      super({
        component,
        ...options
      });
    }
  };
}
var _events, _instance;
var Svelte4Component = class {
  /**
   * @param {import('svelte').ComponentConstructorOptions & {
   *  component: any;
   * 	immutable?: boolean;
   * 	hydrate?: boolean;
   * 	recover?: false;
   * }} options
   */
  constructor(options) {
    /** @type {any} */
    __privateAdd(this, _events);
    /** @type {Record<string, any>} */
    __privateAdd(this, _instance);
    const props = proxy({ ...options.props || {}, $$events: {} }, false);
    __privateSet(this, _instance, (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      props,
      context: options.context,
      intro: options.intro,
      recover: options.recover
    }));
    __privateSet(this, _events, props.$$events);
    for (const key of Object.keys(__privateGet(this, _instance))) {
      if (key === "$set" || key === "$destroy" || key === "$on") continue;
      define_property(this, key, {
        get() {
          return __privateGet(this, _instance)[key];
        },
        /** @param {any} value */
        set(value) {
          __privateGet(this, _instance)[key] = value;
        },
        enumerable: true
      });
    }
    __privateGet(this, _instance).$set = /** @param {Record<string, any>} next */
    (next) => {
      Object.assign(props, next);
    };
    __privateGet(this, _instance).$destroy = () => {
      unmount(__privateGet(this, _instance));
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    __privateGet(this, _instance).$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event2, callback) {
    __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2] || [];
    const cb = (...args) => callback.call(this, ...args);
    __privateGet(this, _events)[event2].push(cb);
    return () => {
      __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    __privateGet(this, _instance).$destroy();
  }
};
_events = new WeakMap();
_instance = new WeakMap();
function run(fn) {
  user_pre_effect(fn);
}

export {
  hydrating,
  set_hydrating,
  hydrate_nodes,
  hydrate_start,
  set_hydrate_nodes,
  hydrate_anchor,
  strict_equals,
  equals,
  $window,
  $document,
  empty,
  child,
  first_child,
  sibling,
  clear_text_content,
  replay_events,
  create_event,
  event,
  delegate,
  head,
  should_intro,
  set_should_intro,
  set_text,
  slot,
  mount,
  hydrate,
  unmount,
  sanitize_slots,
  append_styles,
  createClassComponent,
  asClassComponent,
  run
};
//# sourceMappingURL=chunk-N3B3MM6Z.js.map
