import { type BuiltinObjectKind, type BuiltinObjects, type Primitive, type anyOrNever, type array, type listable, type show } from "@arktype/util";
import type { of } from "../ast.js";
import type { type } from "../inference.js";
import type { Node, NodeSchema } from "../kinds.js";
import type { StaticArkOption } from "../scope.js";
import type { NodeCompiler } from "../shared/compile.js";
import type { BaseMeta, declareNode } from "../shared/declare.js";
import type { ArkError, ArkErrors } from "../shared/errors.js";
import { type nodeImplementationOf } from "../shared/implement.js";
import { type inferPipe } from "../shared/intersections.js";
import type { TraversalContext, TraverseAllows, TraverseApply } from "../shared/traversal.js";
import type { DefaultableAst } from "../structure/optional.js";
import { BaseRoot, type Root, type schemaKindRightOf } from "./root.js";
export type MorphInputKind = schemaKindRightOf<"morph">;
export type MorphInputNode = Node<MorphInputKind>;
export type MorphInputSchema = NodeSchema<MorphInputKind>;
export type Morph<i = any, o = unknown> = (In: i, ctx: TraversalContext) => o;
export type Out<o = any> = ["=>", o];
export type MorphAst<i = any, o = any> = (In: i) => Out<o>;
export interface MorphInner extends BaseMeta {
    readonly in: MorphInputNode;
    readonly morphs: array<Morph | Root>;
}
export interface MorphSchema extends BaseMeta {
    readonly in: MorphInputSchema;
    readonly morphs: listable<Morph | Root>;
}
export interface MorphDeclaration extends declareNode<{
    kind: "morph";
    schema: MorphSchema;
    normalizedSchema: MorphSchema;
    inner: MorphInner;
    childKind: MorphInputKind;
}> {
}
export declare const morphImplementation: nodeImplementationOf<MorphDeclaration>;
export declare class MorphNode extends BaseRoot<MorphDeclaration> {
    serializedMorphs: string[];
    compiledMorphs: string;
    traverseAllows: TraverseAllows;
    traverseApply: TraverseApply;
    expression: string;
    compile(js: NodeCompiler): void;
    get in(): BaseRoot;
    lastMorph: Morph<any, unknown> | Root<unknown, any> | undefined;
    validatedOut: BaseRoot | undefined;
    get out(): BaseRoot;
    rawKeyOf(): BaseRoot;
}
export type inferPipes<t, pipes extends Morph[]> = pipes extends [infer head extends Morph, ...infer tail extends Morph[]] ? inferPipes<head extends type.cast<infer tPipe> ? inferPipe<t, tPipe> : (In: distillConstrainableIn<t>) => Out<inferMorphOut<head>>, tail> : t;
export type inferMorphOut<morph extends Morph> = Exclude<ReturnType<morph>, ArkError | ArkErrors>;
export type distillIn<t> = includesMorphsOrConstraints<t> extends true ? _distill<t, "in", "base"> : t;
export type distillOut<t> = includesMorphsOrConstraints<t> extends true ? _distill<t, "out", "base"> : t;
export type distillConstrainableIn<t> = includesMorphsOrConstraints<t> extends true ? _distill<t, "in", "constrainable"> : t;
export type distillConstrainableOut<t> = includesMorphsOrConstraints<t> extends true ? _distill<t, "out", "constrainable"> : t;
export type includesMorphsOrConstraints<t> = [
    t,
    _distill<t, "in", "base">,
    t,
    _distill<t, "out", "base">
] extends ([
    _distill<t, "in", "base">,
    t,
    _distill<t, "out", "base">,
    t
]) ? false : true;
export type includesMorphs<t> = [
    _distill<t, "in", "constrainable">,
    _distill<t, "out", "constrainable">
] extends ([
    _distill<t, "out", "constrainable">,
    _distill<t, "in", "constrainable">
]) ? false : true;
type _distill<t, io extends "in" | "out", distilledKind extends "base" | "constrainable"> = t extends TerminallyInferredObjectKind | Primitive ? t : unknown extends t ? unknown : t extends MorphAst<infer i, infer o> ? io extends "in" ? _distill<i, io, distilledKind> : _distill<o, io, distilledKind> : t extends DefaultableAst<infer t> ? _distill<t, io, distilledKind> : t extends of<infer base, any> ? distilledKind extends "base" ? _distill<base, io, distilledKind> : t : t extends array ? distillArray<t, io, distilledKind, []> : t extends Function ? t : {
    [k in keyof t]: t[k];
} extends t ? io extends "in" ? show<{
    [k in keyof t as k extends defaultableKeyOf<t> ? never : k]: _distill<t[k], io, distilledKind>;
} & {
    [k in defaultableKeyOf<t>]?: _distill<t[k], io, distilledKind>;
}> : {
    [k in keyof t]: _distill<t[k], io, distilledKind>;
} : t;
type defaultableKeyOf<t> = {
    [k in keyof t]: [t[k]] extends [anyOrNever] ? never : t[k] extends DefaultableAst ? k : never;
}[keyof t];
type distillArray<t extends array, io extends "in" | "out", constraints extends "base" | "constrainable", prefix extends array> = t extends readonly [infer head, ...infer tail] ? distillArray<tail, io, constraints, [
    ...prefix,
    _distill<head, io, constraints>
]> : [...prefix, ...distillPostfix<t, io, constraints>];
type distillPostfix<t extends array, io extends "in" | "out", constraints extends "base" | "constrainable", postfix extends array = []> = t extends readonly [...infer init, infer last] ? distillPostfix<init, io, constraints, [
    _distill<last, io, constraints>,
    ...postfix
]> : [...{
    [i in keyof t]: _distill<t[i], io, constraints>;
}, ...postfix];
/** Objects we don't want to expand during inference like Date or Promise */
type TerminallyInferredObjectKind = StaticArkOption<"preserve"> | BuiltinObjects[Exclude<BuiltinObjectKind, "Array" | "Function">];
export {};
