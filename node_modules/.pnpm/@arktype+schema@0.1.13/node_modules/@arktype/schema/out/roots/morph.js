import { arrayFrom, registeredReference, throwParseError } from "@arktype/util";
import { Disjoint } from "../shared/disjoint.js";
import { implementNode } from "../shared/implement.js";
import { intersectNodes } from "../shared/intersections.js";
import { hasArkKind } from "../shared/utils.js";
import { BaseRoot } from "./root.js";
import { defineRightwardIntersections } from "./utils.js";
const morphInputKinds = [
    "intersection",
    "unit",
    "domain",
    "proto"
];
export const morphImplementation = implementNode({
    kind: "morph",
    hasAssociatedError: false,
    keys: {
        in: {
            child: true,
            parse: (schema, ctx) => ctx.$.node(morphInputKinds, schema)
        },
        morphs: {
            parse: arrayFrom,
            serialize: morphs => morphs.map(m => hasArkKind(m, "root") ? m.json : registeredReference(m))
        }
    },
    normalize: schema => schema,
    defaults: {
        description: node => `a morph from ${node.in.description} to ${node.out?.description ?? "unknown"}`
    },
    intersections: {
        morph: (l, r, ctx) => {
            if (l.morphs.some((morph, i) => morph !== r.morphs[i]))
                // TODO: check in for union reduction
                return throwParseError("Invalid intersection of morphs");
            const inTersection = intersectNodes(l.in, r.in, ctx);
            if (inTersection instanceof Disjoint)
                return inTersection;
            // in case from is a union, we need to distribute the branches
            // to can be a union as any schema is allowed
            return ctx.$.schema(inTersection.branches.map(inBranch => ctx.$.node("morph", {
                morphs: l.morphs,
                in: inBranch
            })));
        },
        ...defineRightwardIntersections("morph", (l, r, ctx) => {
            const inTersection = intersectNodes(l.in, r, ctx);
            return (inTersection instanceof Disjoint ? inTersection
                : inTersection.kind === "union" ?
                    ctx.$.node("union", inTersection.branches.map(branch => ({
                        ...l.inner,
                        in: branch
                    })))
                    : ctx.$.node("morph", {
                        ...l.inner,
                        in: inTersection
                    }));
        })
    }
});
export class MorphNode extends BaseRoot {
    serializedMorphs = this.morphs.map(registeredReference);
    compiledMorphs = `[${this.serializedMorphs}]`;
    traverseAllows = (data, ctx) => this.in.traverseAllows(data, ctx);
    traverseApply = (data, ctx) => {
        this.in.traverseApply(data, ctx);
        ctx.queueMorphs(this.morphs);
    };
    expression = `(In: ${this.in.expression}) => Out<${this.out?.expression ?? "unknown"}>`;
    compile(js) {
        if (js.traversalKind === "Allows") {
            js.return(js.invoke(this.in));
            return;
        }
        js.line(js.invoke(this.in));
        js.line(`ctx.queueMorphs(${this.compiledMorphs})`);
    }
    get in() {
        return this.inner.in;
    }
    lastMorph = this.inner.morphs.at(-1);
    validatedOut = hasArkKind(this.lastMorph, "root") ?
        Object.assign(this.referencesById, this.lastMorph.out.referencesById) &&
            this.lastMorph.out
        : undefined;
    get out() {
        return this.validatedOut ?? this.$.keywords.unknown.raw;
    }
    rawKeyOf() {
        return this.in.rawKeyOf();
    }
}
