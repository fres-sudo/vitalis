import { includes, omit, throwParseError } from "@arktype/util";
import { throwInvalidOperandError } from "../constraint.js";
import { BaseNode } from "../node.js";
import { Disjoint } from "../shared/disjoint.js";
import { ArkErrors } from "../shared/errors.js";
import { structuralKinds } from "../shared/implement.js";
import { intersectNodesRoot, pipeNodesRoot } from "../shared/intersections.js";
import { arkKind, hasArkKind } from "../shared/utils.js";
export class BaseRoot extends BaseNode {
    branches = this.hasKind("union") ? this.inner.branches : [this];
    [arkKind] = "root";
    get raw() {
        return this;
    }
    _keyof;
    keyof() {
        if (!this._keyof) {
            this._keyof = this.rawKeyOf();
            if (this._keyof.branches.length === 0) {
                throwParseError(`keyof ${this.expression} results in an unsatisfiable type`);
            }
        }
        return this._keyof;
    }
    intersect(r) {
        const rNode = this.$.parseRoot(r);
        return intersectNodesRoot(this, rNode, this.$);
    }
    and(r) {
        const result = this.intersect(r);
        return result instanceof Disjoint ? result.throw() : result;
    }
    or(r) {
        const rNode = this.$.parseRoot(r);
        const branches = [...this.branches, ...rNode.branches];
        return this.$.schema(branches);
    }
    assert(data) {
        const result = this.traverse(data);
        return result instanceof ArkErrors ? result.throw() : result;
    }
    // get<key extends PropertyKey>(
    // 	...path: readonly (key | Root<key>)[]
    // ): this {
    // 	return this
    // }
    extract(r) {
        const rNode = this.$.parseRoot(r);
        return this.$.schema(this.branches.filter(branch => branch.extends(rNode)));
    }
    exclude(r) {
        const rNode = this.$.parseRoot(r);
        return this.$.schema(this.branches.filter(branch => !branch.extends(rNode)));
    }
    array() {
        return this.$.schema({
            proto: Array,
            sequence: this
        }, { prereduced: true });
    }
    overlaps(r) {
        const intersection = this.intersect(r);
        return !(intersection instanceof Disjoint);
    }
    extends(r) {
        const intersection = this.intersect(r);
        return (!(intersection instanceof Disjoint) && this.equals(intersection));
    }
    subsumes(r) {
        return r.extends(this);
    }
    configure(configOrDescription) {
        return this.configureShallowDescendants(configOrDescription);
    }
    describe(description) {
        return this.configure(description);
    }
    from(input) {
        // ideally we wouldn't validate here but for now we need to do determine
        // which morphs to apply
        return this.assert(input);
    }
    pipe(...morphs) {
        return morphs.reduce((acc, morph) => acc.pipeOnce(morph), this);
    }
    pipeOnce(morph) {
        if (hasArkKind(morph, "root")) {
            const result = pipeNodesRoot(this, morph, this.$);
            if (result instanceof Disjoint)
                return result.throw();
            return result;
        }
        if (this.hasKind("union")) {
            const branches = this.branches.map(node => node.pipe(morph));
            return this.$.node("union", { ...this.inner, branches });
        }
        if (this.hasKind("morph")) {
            return this.$.node("morph", {
                ...this.inner,
                morphs: [...this.morphs, morph]
            });
        }
        return this.$.node("morph", {
            in: this,
            morphs: [morph]
        });
    }
    narrow(predicate) {
        return this.constrainOut("predicate", predicate);
    }
    constrain(kind, schema) {
        return this._constrain("in", kind, schema);
    }
    constrainOut(kind, schema) {
        return this._constrain("out", kind, schema);
    }
    _constrain(io, kind, schema) {
        const constraint = this.$.node(kind, schema);
        if (constraint.impliedBasis && !this[io].extends(constraint.impliedBasis)) {
            return throwInvalidOperandError(kind, constraint.impliedBasis, this);
        }
        const partialIntersection = this.$.node("intersection", {
            [kind]: constraint
        });
        const result = io === "in" ?
            intersectNodesRoot(this, partialIntersection, this.$)
            : pipeNodesRoot(this, partialIntersection, this.$);
        if (result instanceof Disjoint)
            result.throw();
        return result;
    }
    onUndeclaredKey(undeclared) {
        return this.transform((kind, inner) => kind === "structure" ?
            undeclared === "ignore" ?
                omit(inner, { undeclared: 1 })
                : { ...inner, undeclared }
            : inner, { shouldTransform: node => !includes(structuralKinds, node.kind) });
    }
    satisfying(predicate) {
        return this.constrain("predicate", predicate);
    }
    divisibleBy(schema) {
        return this.constrain("divisor", schema);
    }
    matching(schema) {
        return this.constrain("regex", schema);
    }
    atLeast(schema) {
        return this.constrain("min", schema);
    }
    atMost(schema) {
        return this.constrain("max", schema);
    }
    moreThan(schema) {
        return this.constrain("min", exclusivizeRangeSchema(schema));
    }
    lessThan(schema) {
        return this.constrain("max", exclusivizeRangeSchema(schema));
    }
    atLeastLength(schema) {
        return this.constrain("minLength", schema);
    }
    atMostLength(schema) {
        return this.constrain("maxLength", schema);
    }
    moreThanLength(schema) {
        return this.constrain("minLength", exclusivizeRangeSchema(schema));
    }
    lessThanLength(schema) {
        return this.constrain("maxLength", exclusivizeRangeSchema(schema));
    }
    exactlyLength(schema) {
        return this.constrain("exactLength", schema);
    }
    atOrAfter(schema) {
        return this.constrain("after", schema);
    }
    atOrBefore(schema) {
        return this.constrain("before", schema);
    }
    laterThan(schema) {
        return this.constrain("after", exclusivizeRangeSchema(schema));
    }
    earlierThan(schema) {
        return this.constrain("before", exclusivizeRangeSchema(schema));
    }
}
export const exclusivizeRangeSchema = (schema) => (typeof schema === "object" && !(schema instanceof Date) ?
    { ...schema, exclusive: true }
    : {
        rule: schema,
        exclusive: true
    });
