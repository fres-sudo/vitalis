import { Callable, type Guardable, type Json, type Key, type conform } from "@arktype/util";
import type { BaseConstraint } from "./constraint.js";
import type { Inner, Node, reducibleKindOf } from "./kinds.js";
import type { BaseRoot, Root } from "./roots/root.js";
import type { UnitNode } from "./roots/unit.js";
import type { RawRootScope } from "./scope.js";
import type { NodeCompiler } from "./shared/compile.js";
import type { BaseMeta, RawNodeDeclaration, attachmentsOf } from "./shared/declare.js";
import { type BasisKind, type NodeKind, type OpenNodeKind, type RefinementKind, type UnknownAttachments } from "./shared/implement.js";
import { type TraverseAllows, type TraverseApply } from "./shared/traversal.js";
import type { arkKind } from "./shared/utils.js";
export type UnknownNode = BaseNode | Root;
export declare abstract class BaseNode<
/** uses -ignore rather than -expect-error because this is not an error in .d.ts
 * @ts-ignore allow instantiation assignment to the base type */
out d extends RawNodeDeclaration = RawNodeDeclaration> extends Callable<(data: d["prerequisite"]) => unknown, attachmentsOf<d>> {
    attachments: UnknownAttachments;
    constructor(attachments: UnknownAttachments);
    abstract traverseAllows: TraverseAllows<d["prerequisite"]>;
    abstract traverseApply: TraverseApply<d["prerequisite"]>;
    abstract expression: string;
    abstract compile(js: NodeCompiler): void;
    readonly qualifiedId: string;
    readonly includesMorph: boolean;
    readonly allowsRequiresContext: boolean;
    readonly referencesById: Record<string, BaseNode>;
    get references(): BaseNode[];
    readonly precedence: number;
    jit: boolean;
    allows: (data: d["prerequisite"]) => boolean;
    traverse(data: d["prerequisite"]): unknown;
    private _in?;
    get in(): this extends {
        [arkKind]: "root";
    } ? BaseRoot : BaseNode;
    private _out?;
    get out(): this extends {
        [arkKind]: "root";
    } ? BaseRoot : BaseNode;
    private _description?;
    get description(): string;
    getIo(kind: "in" | "out"): BaseNode;
    toJSON(): Json;
    toString(): string;
    equals(other: UnknownNode): boolean;
    assertHasKind<kind extends NodeKind>(kind: kind): Node<kind>;
    hasKind<kind extends NodeKind>(kind: kind): this is Node<kind>;
    isBasis(): this is Node<BasisKind>;
    isConstraint(): this is BaseConstraint;
    isRefinement(): this is Node<RefinementKind>;
    isRoot(): this is BaseRoot;
    hasUnit<value>(value: unknown): this is UnitNode & {
        unit: value;
    };
    hasOpenIntersection(): this is Node<OpenNodeKind>;
    get nestableExpression(): string;
    bindScope($: RawRootScope): this;
    firstReference<narrowed>(filter: Guardable<BaseNode, conform<narrowed, BaseNode>>): narrowed | undefined;
    firstReferenceOrThrow<narrowed extends BaseNode>(filter: Guardable<BaseNode, narrowed>): narrowed;
    firstReferenceOfKind<kind extends NodeKind>(kind: kind): Node<kind> | undefined;
    firstReferenceOfKindOrThrow<kind extends NodeKind>(kind: kind): Node<kind>;
    transform<mapper extends DeepNodeTransformation>(mapper: mapper, opts?: DeepNodeTransformOptions): Node<reducibleKindOf<this["kind"]>> | Extract<ReturnType<mapper>, null>;
    protected _transform(mapper: DeepNodeTransformation, ctx: DeepNodeTransformationContext): BaseNode | null;
    configureShallowDescendants(configOrDescription: BaseMeta | string): this;
}
export type DeepNodeTransformOptions = {
    shouldTransform: ShouldTransformFn;
};
export type ShouldTransformFn = (node: BaseNode, ctx: DeepNodeTransformationContext) => boolean;
export type DeepNodeTransformationContext = {
    /** a literal key or a node representing the key of an index signature */
    path: Array<Key | BaseNode>;
    seen: {
        [originalId: string]: (() => BaseNode | undefined) | undefined;
    };
    shouldTransform: ShouldTransformFn;
};
export type DeepNodeTransformation = <kind extends NodeKind>(kind: kind, inner: Inner<kind>, ctx: DeepNodeTransformationContext) => Inner<kind> | null;
