import { entriesOf, flatMorph, fromEntries, isArray, printable, register, throwInternalError, throwParseError } from "@arktype/util";
import { hasArkKind } from "./utils.js";
export class Disjoint {
    sources;
    constructor(sources) {
        this.sources = sources;
    }
    clone() {
        return new Disjoint(this.sources);
    }
    static from(kind, l, r) {
        return new Disjoint({
            "[]": {
                [kind]: {
                    l,
                    r
                }
            }
        });
    }
    static fromEntries(entries) {
        if (!entries.length) {
            return throwInternalError("Unexpected attempt to create a disjoint from no entries");
        }
        return new Disjoint({ "[]": fromEntries(entries) });
    }
    get flat() {
        return entriesOf(this.sources).flatMap(([path, disjointKinds]) => entriesOf(disjointKinds).map(([kind, disjoint]) => ({
            path,
            kind,
            disjoint
        })));
    }
    describeReasons() {
        const reasons = this.flat;
        if (reasons.length === 1) {
            const { path, disjoint } = reasons[0];
            const pathString = JSON.parse(path).join(".");
            return `Intersection${pathString && ` at ${pathString}`} of ${describeReasons(disjoint)} results in an unsatisfiable type`;
        }
        return `The following intersections result in unsatisfiable types:\n• ${reasons
            .map(({ path, disjoint }) => `${path}: ${describeReasons(disjoint)}`)
            .join("\n• ")}`;
    }
    isEmpty() {
        return this.flat.length === 0;
    }
    throw() {
        return throwParseError(this.describeReasons());
    }
    invert() {
        const invertedEntries = entriesOf(this.sources).map(([path, disjoints]) => [
            path,
            flatMorph(disjoints, (kind, disjoint) => [
                kind,
                { l: disjoint.r, r: disjoint.l }
            ])
        ]);
        return new Disjoint(fromEntries(invertedEntries));
    }
    add(input) {
        entriesOf(input.sources).forEach(([path, disjoints]) => Object.assign(this.sources[path] ?? {}, disjoints));
    }
    withPrefixKey(key) {
        const entriesWithPrefix = entriesOf(this.sources).map(([path, disjoints]) => {
            const segments = JSON.parse(path);
            segments.unshift(typeof key === "symbol" ? register(key) : key);
            const pathWithPrefix = JSON.stringify(segments);
            return [pathWithPrefix, disjoints];
        });
        return new Disjoint(fromEntries(entriesWithPrefix));
    }
    toString() {
        return printable(this.sources);
    }
}
const describeReasons = (source) => `${describeReason(source.l)} and ${describeReason(source.r)}`;
const describeReason = (value) => hasArkKind(value, "root") ? value.expression
    : isArray(value) ? value.map(describeReason).join(" | ")
        : String(value);
