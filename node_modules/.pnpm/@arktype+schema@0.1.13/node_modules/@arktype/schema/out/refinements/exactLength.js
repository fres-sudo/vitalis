import { RawPrimitiveConstraint } from "../constraint.js";
import { Disjoint } from "../shared/disjoint.js";
import { implementNode } from "../shared/implement.js";
export const exactLengthImplementation = implementNode({
    kind: "exactLength",
    collapsibleKey: "rule",
    keys: {
        rule: {}
    },
    normalize: schema => typeof schema === "number" ? { rule: schema } : schema,
    hasAssociatedError: true,
    defaults: {
        description: node => `exactly length ${node.rule}`,
        actual: data => `${data.length}`
    },
    intersections: {
        exactLength: (l, r, ctx) => new Disjoint({
            '["length"]': {
                unit: {
                    l: ctx.$.node("unit", { unit: l.rule }),
                    r: ctx.$.node("unit", { unit: r.rule })
                }
            }
        }),
        minLength: (exactLength, minLength) => (minLength.exclusive ?
            exactLength.rule > minLength.rule
            : exactLength.rule >= minLength.rule) ?
            exactLength
            : Disjoint.from("range", exactLength, minLength),
        maxLength: (exactLength, maxLength) => (maxLength.exclusive ?
            exactLength.rule < maxLength.rule
            : exactLength.rule <= maxLength.rule) ?
            exactLength
            : Disjoint.from("range", exactLength, maxLength)
    }
});
export class ExactLengthNode extends RawPrimitiveConstraint {
    traverseAllows = data => data.length === this.rule;
    compiledCondition = `data.length === ${this.rule}`;
    compiledNegation = `data.length !== ${this.rule}`;
    impliedBasis = this.$.keywords.lengthBoundable.raw;
    expression = `{ length: ${this.rule} }`;
}
