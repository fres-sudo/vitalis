import { Callable, flatMorph, includes, isArray, isEmptyObject, shallowClone, throwError } from "@arktype/util";
import { basisKinds, constraintKinds, precedenceOfKind, refinementKinds, rootKinds } from "./shared/implement.js";
import { TraversalContext } from "./shared/traversal.js";
export class BaseNode extends Callable {
    attachments;
    constructor(attachments) {
        super(
        // pipedFromCtx allows us internally to reuse TraversalContext
        // through pipes and keep track of piped paths. It is not exposed
        (data, pipedFromCtx) => {
            if (!this.includesMorph &&
                !this.allowsRequiresContext &&
                this.allows(data))
                return data;
            if (pipedFromCtx) {
                this.traverseApply(data, pipedFromCtx);
                return pipedFromCtx.data;
            }
            const ctx = new TraversalContext(data, this.$.resolvedConfig);
            this.traverseApply(data, ctx);
            return ctx.finalize();
        }, { attach: attachments });
        this.attachments = attachments;
    }
    qualifiedId = `${this.$.id}${this.id}`;
    includesMorph = this.kind === "morph" ||
        (this.hasKind("optional") && this.hasDefault()) ||
        (this.hasKind("structure") && this.undeclared === "delete") ||
        this.children.some(child => child.includesMorph);
    allowsRequiresContext = 
    // if a predicate accepts exactly one arg, we can safely skip passing context
    (this.hasKind("predicate") && this.inner.predicate.length !== 1) ||
        this.kind === "alias" ||
        this.children.some(child => child.allowsRequiresContext);
    referencesById = this.children.reduce((result, child) => Object.assign(result, child.referencesById), { [this.id]: this });
    get references() {
        return Object.values(this.referencesById);
    }
    precedence = precedenceOfKind(this.kind);
    jit = false;
    allows = (data) => {
        if (this.allowsRequiresContext) {
            return this.traverseAllows(data, new TraversalContext(data, this.$.resolvedConfig));
        }
        return this.traverseAllows(data);
    };
    traverse(data) {
        return this(data);
    }
    // unfortunately we can't use the @cached
    // decorator from @arktype/util on these for now
    // as they cause a deopt in V8
    _in;
    get in() {
        this._in ??= this.getIo("in");
        return this._in;
    }
    _out;
    get out() {
        this._out ??= this.getIo("out");
        return this._out;
    }
    _description;
    get description() {
        this._description ??=
            this.inner.description ??
                this.$.resolvedConfig[this.kind].description?.(this);
        return this._description;
    }
    getIo(kind) {
        if (!this.includesMorph)
            return this;
        const ioInner = {};
        for (const [k, v] of this.entries) {
            const keySchemaImplementation = this.impl.keys[k];
            if (keySchemaImplementation.meta)
                continue;
            if (keySchemaImplementation.child) {
                const childValue = v;
                ioInner[k] =
                    isArray(childValue) ?
                        childValue.map(child => child[kind])
                        : childValue[kind];
            }
            else
                ioInner[k] = v;
        }
        return this.$.node(this.kind, ioInner);
    }
    toJSON() {
        return this.json;
    }
    toString() {
        return this.expression;
    }
    equals(other) {
        return this.typeHash === other.typeHash;
    }
    assertHasKind(kind) {
        if (!this.kind === kind)
            throwError(`${this.kind} node was not of asserted kind ${kind}`);
        return this;
    }
    hasKind(kind) {
        return this.kind === kind;
    }
    isBasis() {
        return includes(basisKinds, this.kind);
    }
    isConstraint() {
        return includes(constraintKinds, this.kind);
    }
    isRefinement() {
        return includes(refinementKinds, this.kind);
    }
    isRoot() {
        return includes(rootKinds, this.kind);
    }
    hasUnit(value) {
        return this.hasKind("unit") && this.allows(value);
    }
    hasOpenIntersection() {
        return this.impl.intersectionIsOpen;
    }
    get nestableExpression() {
        return this.expression;
    }
    bindScope($) {
        if (this.$ === $)
            return this;
        return new this.constructor(Object.assign(shallowClone(this.attachments), { $ }));
    }
    firstReference(filter) {
        return this.references.find(n => n !== this && filter(n));
    }
    firstReferenceOrThrow(filter) {
        return (this.firstReference(filter) ??
            throwError(`${this.id} had no references matching predicate ${filter}`));
    }
    firstReferenceOfKind(kind) {
        return this.firstReference((node) => node.kind === kind);
    }
    firstReferenceOfKindOrThrow(kind) {
        return (this.firstReference(node => node.kind === kind) ??
            throwError(`${this.id} had no ${kind} references`));
    }
    transform(mapper, opts) {
        return this._transform(mapper, {
            seen: {},
            path: [],
            shouldTransform: opts?.shouldTransform ?? (() => true)
        });
    }
    _transform(mapper, ctx) {
        if (ctx.seen[this.id])
            // TODO: remove cast by making lazilyResolve more flexible
            // TODO: if each transform has a unique base id, could ensure
            // these don't create duplicates
            return this.$.lazilyResolve(ctx.seen[this.id]);
        if (!ctx.shouldTransform(this, ctx))
            return this;
        let transformedNode;
        ctx.seen[this.id] = () => transformedNode;
        const innerWithTransformedChildren = flatMorph(this.inner, (k, v) => {
            if (!this.impl.keys[k].child)
                return [k, v];
            const children = v;
            if (!isArray(children)) {
                const transformed = children._transform(mapper, ctx);
                return transformed ? [k, transformed] : [];
            }
            const transformed = children.flatMap(n => {
                const transformedChild = n._transform(mapper, ctx);
                return transformedChild ?? [];
            });
            return transformed.length ? [k, transformed] : [];
        });
        delete ctx.seen[this.id];
        const transformedInner = mapper(this.kind, innerWithTransformedChildren, ctx);
        if (transformedInner === null)
            return null;
        // TODO: more robust checks for pruned inner
        if (isEmptyObject(transformedInner))
            return null;
        if ((this.kind === "required" ||
            this.kind === "optional" ||
            this.kind === "index") &&
            !("value" in transformedInner))
            return null;
        if (this.kind === "morph") {
            ;
            transformedInner.in ??= this.$.keywords
                .unknown;
        }
        return (transformedNode = this.$.node(this.kind, transformedInner));
    }
    configureShallowDescendants(configOrDescription) {
        const config = typeof configOrDescription === "string" ?
            { description: configOrDescription }
            : configOrDescription;
        return this.transform((kind, inner) => ({ ...inner, ...config }), {
            shouldTransform: node => node.kind !== "structure"
        });
    }
}
