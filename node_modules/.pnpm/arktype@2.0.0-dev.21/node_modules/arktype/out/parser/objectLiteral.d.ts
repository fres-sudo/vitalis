import { type BaseRoot, type Default, type of, type UndeclaredKeyBehavior, type writeInvalidPropertyKeyMessage } from "@arktype/schema";
import { type anyOrNever, type Dict, type ErrorMessage, type Key, type keyError, type merge, type show } from "@arktype/util";
import type { ParseContext } from "../scope.js";
import type { inferDefinition, validateDefinition } from "./definition.js";
import type { astToString } from "./semantic/utils.js";
import type { validateString } from "./semantic/validate.js";
import { Scanner } from "./string/shift/scanner.js";
export declare const parseObjectLiteral: (def: Dict, ctx: ParseContext) => BaseRoot;
export declare const writeInvalidUndeclaredBehaviorMessage: (actual: unknown) => string;
export declare const nonLeadingSpreadError = "Spread operator may only be used as the first key in an object";
export type inferObjectLiteral<def extends object, $, args> = show<"..." extends keyof def ? merge<inferDefinition<def["..."], $, args>, _inferObjectLiteral<def, $, args>> : _inferObjectLiteral<def, $, args>>;
/**
 * Infers the contents of an object literal, ignoring a spread definition
 */
type _inferObjectLiteral<def extends object, $, args> = {
    -readonly [k in keyof def as nonOptionalKeyFrom<k, $, args>]: def[k] extends (readonly [infer defaultableDef, "=", infer v]) ? def[k] extends anyOrNever ? def[k] : (In?: inferDefinition<defaultableDef, $, args>) => Default<v> : inferDefinition<def[k], $, args>;
} & {
    -readonly [k in keyof def as optionalKeyFrom<k>]?: inferDefinition<def[k], $, args>;
};
export type validateObjectLiteral<def, $, args> = {
    [k in keyof def]: k extends IndexKey<infer indexDef> ? validateString<indexDef, $, args> extends ErrorMessage<infer message> ? keyError<message> : inferDefinition<indexDef, $, args> extends (PropertyKey | of<PropertyKey, {}>) ? validateDefinition<def[k], $, args> : keyError<writeInvalidPropertyKeyMessage<indexDef>> : k extends "..." ? inferDefinition<def[k], $, args> extends object ? validateDefinition<def[k], $, args> : keyError<writeInvalidSpreadTypeMessage<astToString<def[k]>>> : k extends "+" ? UndeclaredKeyBehavior : validatePossibleDefaultValue<def, k, $, args>;
};
type validatePossibleDefaultValue<def, k extends keyof def, $, args> = def[k] extends readonly [infer defaultDef, "=", unknown] ? parseKey<k>["kind"] extends "required" ? readonly [
    validateDefinition<defaultDef, $, args>,
    "=",
    inferDefinition<defaultDef, $, args>
] : ErrorMessage<invalidDefaultKeyKindMessage> : validateDefinition<def[k], $, args>;
type nonOptionalKeyFrom<k, $, args> = parseKey<k> extends PreparsedKey<"required", infer inner> ? inner : parseKey<k> extends PreparsedKey<"index", infer inner> ? inferDefinition<inner, $, args> extends infer t ? (t extends of<infer inner, any> ? Extract<inner, string> : Key) & t : never : never;
type optionalKeyFrom<k> = parseKey<k> extends PreparsedKey<"optional", infer inner> ? inner : never;
type PreparsedKey<kind extends ParsedKeyKind = ParsedKeyKind, inner extends Key = Key> = {
    kind: kind;
    key: inner;
};
declare namespace PreparsedKey {
    type from<t extends PreparsedKey> = t;
}
type ParsedKeyKind = "required" | "optional" | "index" | MetaKey;
export type MetaKey = "..." | "+";
export type IndexKey<def extends string = string> = `[${def}]`;
interface PreparsedEntry extends PreparsedKey {
    value: unknown;
    default: unknown;
}
export declare const parseEntry: ([key, value]: readonly [
    Key,
    unknown
]) => PreparsedEntry;
export declare const invalidDefaultKeyKindMessage = "Only required keys may specify default values, e.g. { ark: ['string', '=', '\u26F5'] }";
export type invalidDefaultKeyKindMessage = typeof invalidDefaultKeyKindMessage;
declare const parseKey: (key: Key) => PreparsedKey;
type parseKey<k> = k extends `${infer inner}?` ? inner extends `${infer baseName}${Scanner.EscapeToken}` ? PreparsedKey.from<{
    kind: "required";
    key: `${baseName}?`;
}> : PreparsedKey.from<{
    kind: "optional";
    key: inner;
}> : k extends MetaKey ? PreparsedKey.from<{
    kind: k;
    key: k;
}> : k extends `${Scanner.EscapeToken}${infer escapedMeta extends MetaKey}` ? PreparsedKey.from<{
    kind: "required";
    key: escapedMeta;
}> : k extends IndexKey<infer def> ? PreparsedKey.from<{
    kind: "index";
    key: def;
}> : PreparsedKey.from<{
    kind: "required";
    key: k extends (`${Scanner.EscapeToken}${infer escapedIndexKey extends IndexKey}`) ? escapedIndexKey : k extends Key ? k : `${k & number}`;
}>;
export declare const writeInvalidSpreadTypeMessage: <def extends string>(def: def) => `Spread operand must resolve to an object literal type (was ${def})`;
type writeInvalidSpreadTypeMessage<def extends string> = `Spread operand must resolve to an object literal type (was ${def})`;
export {};
