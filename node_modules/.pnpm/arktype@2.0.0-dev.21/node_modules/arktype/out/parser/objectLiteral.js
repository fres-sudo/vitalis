import { ArkErrors, normalizeIndex } from "@arktype/schema";
import { append, isArray, printable, stringAndSymbolicEntriesOf, throwParseError, unset } from "@arktype/util";
import { Scanner } from "./string/shift/scanner.js";
export const parseObjectLiteral = (def, ctx) => {
    let spread;
    const structure = {};
    // We only allow a spread operator to be used as the first key in an object
    // because to match JS behavior any keys before the spread are overwritten
    // by the values in the target object, so there'd be no useful purpose in having it
    // anywhere except for the beginning.
    const parsedEntries = stringAndSymbolicEntriesOf(def).map(parseEntry);
    if (parsedEntries[0]?.kind === "...") {
        // remove the spread entry so we can iterate over the remaining entries
        // expecting non-spread entries
        const spreadEntry = parsedEntries.shift();
        const spreadNode = ctx.$.parse(spreadEntry.value, ctx);
        if (!spreadNode.hasKind("intersection") || !spreadNode.structure) {
            return throwParseError(writeInvalidSpreadTypeMessage(typeof spreadEntry.value === "string" ?
                spreadEntry.value
                : printable(spreadEntry.value)));
        }
        spread = spreadNode.structure;
    }
    for (const entry of parsedEntries) {
        if (entry.kind === "...")
            return throwParseError(nonLeadingSpreadError);
        if (entry.kind === "+") {
            if (entry.value !== "reject" &&
                entry.value !== "delete" &&
                entry.value !== "ignore")
                throwParseError(writeInvalidUndeclaredBehaviorMessage(entry.value));
            structure.undeclared = entry.value;
            continue;
        }
        if (entry.kind === "index") {
            // handle key parsing first to match type behavior
            const key = ctx.$.parse(entry.key, ctx);
            const value = ctx.$.parse(entry.value, ctx);
            const normalizedSignature = normalizeIndex(key, value, ctx.$);
            if (normalizedSignature.required) {
                structure.required = append(structure.required, normalizedSignature.required);
            }
            if (normalizedSignature.index)
                structure.index = append(structure.index, normalizedSignature.index);
        }
        else {
            const value = ctx.$.parse(entry.value, ctx);
            const inner = { key: entry.key, value };
            if (entry.default !== unset) {
                const out = value(entry.default);
                if (out instanceof ArkErrors)
                    throwParseError(`Default value at ${printable(entry.key)} ${out}`);
                value.assert(entry.default);
                inner.default = entry.default;
            }
            structure[entry.kind] = append(structure[entry.kind], inner);
        }
    }
    const structureNode = ctx.$.node("structure", structure);
    return ctx.$.schema({
        domain: "object",
        structure: spread?.merge(structureNode) ?? structureNode
    });
};
export const writeInvalidUndeclaredBehaviorMessage = (actual) => `Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${printable(actual)})`;
export const nonLeadingSpreadError = "Spread operator may only be used as the first key in an object";
export const parseEntry = ([key, value]) => {
    const parsedKey = parseKey(key);
    if (isArray(value) && value[1] === "=") {
        if (parsedKey.kind !== "required")
            throwParseError(invalidDefaultKeyKindMessage);
        return {
            kind: "optional",
            key: parsedKey.key,
            value: value[0],
            default: value[2]
        };
    }
    return {
        kind: parsedKey.kind,
        key: parsedKey.key,
        value,
        default: unset
    };
};
// single quote use here is better for TypeScript's inlined error to avoid escapes
export const invalidDefaultKeyKindMessage = `Only required keys may specify default values, e.g. { ark: ['string', '=', 'â›µ'] }`;
const parseKey = (key) => typeof key === "symbol" ? { kind: "required", key }
    : key.at(-1) === "?" ?
        key.at(-2) === Scanner.escapeToken ?
            { kind: "required", key: `${key.slice(0, -2)}?` }
            : {
                kind: "optional",
                key: key.slice(0, -1)
            }
        : key[0] === "[" && key.at(-1) === "]" ?
            { kind: "index", key: key.slice(1, -1) }
            : key[0] === Scanner.escapeToken && key[1] === "[" && key.at(-1) === "]" ?
                { kind: "required", key: key.slice(1) }
                : key === "..." || key === "+" ? { kind: key, key }
                    : {
                        kind: "required",
                        key: key === "\\..." ? "..."
                            : key === "\\+" ? "+"
                                : key
                    };
export const writeInvalidSpreadTypeMessage = (def) => `Spread operand must resolve to an object literal type (was ${def})`;
