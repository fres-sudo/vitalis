import { BaseRoot, writeUnresolvableMessage, type GenericProps, type arkKind, type writeNonSubmoduleDotMessage } from "@arktype/schema";
import { type BigintLiteral, type Completion, type ErrorMessage, type anyOrNever, type join } from "@arktype/util";
import type { Generic } from "../../../../generic.js";
import type { GenericInstantiationAst } from "../../../semantic/infer.js";
import type { DynamicState } from "../../reduce/dynamic.js";
import type { StaticState, state } from "../../reduce/static.js";
import type { BaseCompletions } from "../../string.js";
import type { Scanner } from "../scanner.js";
import { parseGenericArgs, writeInvalidGenericArgsMessage, type ParsedArgs } from "./genericArgs.js";
export declare const parseUnenclosed: (s: DynamicState) => void;
export type parseUnenclosed<s extends StaticState, $, args> = Scanner.shiftUntilNextTerminator<s["unscanned"]> extends (Scanner.shiftResult<infer token, infer unscanned>) ? token extends "keyof" ? state.addPrefix<s, "keyof", unscanned> : tryResolve<s, token, $, args> extends infer result ? result extends ErrorMessage<infer message> ? state.error<message> : result extends keyof $ ? [
    $[result]
] extends [anyOrNever] ? state.setRoot<s, result, unscanned> : $[result] extends GenericProps ? parseGenericInstantiation<token, $[result], state.scanTo<s, unscanned>, $, args> : state.setRoot<s, result, unscanned> : state.setRoot<s, result, unscanned> : never : never;
export declare const parseGenericInstantiation: (name: string, g: Generic, s: DynamicState) => BaseRoot;
export type parseGenericInstantiation<name extends string, g extends GenericProps, s extends StaticState, $, args> = Scanner.skipWhitespace<s["unscanned"]> extends `<${infer unscanned}` ? parseGenericArgs<name, g["params"], unscanned, $, args> extends (infer result) ? result extends ParsedArgs<infer argAsts, infer nextUnscanned> ? state.setRoot<s, GenericInstantiationAst<g, argAsts>, nextUnscanned> : result : never : state.error<writeInvalidGenericArgsMessage<name, g["params"], []>>;
type tryResolve<s extends StaticState, token extends string, $, args> = token extends keyof $ ? token : `#${token}` extends keyof $ ? token : token extends keyof args ? token : token extends `${number}` ? token : token extends BigintLiteral ? token : token extends (`${infer submodule extends keyof $ & string}.${infer reference}`) ? $[submodule] extends {
    [arkKind]: "module";
} ? reference extends keyof $[submodule] ? token : unresolvableError<s, reference, $[submodule], args, [submodule]> : ErrorMessage<writeNonSubmoduleDotMessage<submodule>> : unresolvableError<s, token, $, args, []>;
/** Provide valid completions for the current token, or fallback to an
 * unresolvable error if there are none */
export type unresolvableError<s extends StaticState, token extends string, $, args, submodulePath extends string[]> = validReferenceFromToken<token, $, args, submodulePath> extends never ? ErrorMessage<writeUnresolvableMessage<qualifiedReference<token, submodulePath>>> : Completion<`${s["scanned"]}${qualifiedReference<validReferenceFromToken<token, $, args, submodulePath>, submodulePath>}`>;
type qualifiedReference<reference extends string, submodulePath extends string[]> = join<[...submodulePath, reference], ".">;
type validReferenceFromToken<token extends string, $, args, submodulePath extends string[]> = Extract<submodulePath extends [] ? BaseCompletions<$, args> : keyof $, `${token}${string}`>;
export declare const writeMissingOperandMessage: (s: DynamicState) => string;
export type writeMissingRightOperandMessage<token extends string, unscanned extends string = ""> = `Token '${token}' requires a right operand${unscanned extends "" ? "" : ` before '${unscanned}'`}`;
export declare const writeMissingRightOperandMessage: <token extends string, unscanned extends string>(token: token, unscanned?: unscanned) => `Token '${token}' requires a right operand${unscanned extends "" ? "" : ` before '${unscanned}'`}`;
export declare const writeExpressionExpectedMessage: <unscanned extends string>(unscanned: unscanned) => `Expected an expression${unscanned extends "" ? "" : ` before '${unscanned}'`}`;
export type writeExpressionExpectedMessage<unscanned extends string> = `Expected an expression${unscanned extends "" ? "" : ` before '${unscanned}'`}`;
export {};
