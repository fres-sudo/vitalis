import { isKeyOf } from "@arktype/util";
export class Scanner {
    chars;
    i;
    constructor(def) {
        this.chars = [...def];
        this.i = 0;
    }
    /** Get lookahead and advance scanner by one */
    shift() {
        return (this.chars[this.i++] ?? "");
    }
    get lookahead() {
        return (this.chars[this.i] ?? "");
    }
    get nextLookahead() {
        return this.chars[this.i + 1] ?? "";
    }
    get length() {
        return this.chars.length;
    }
    shiftUntil(condition) {
        let shifted = "";
        while (this.lookahead) {
            if (condition(this, shifted)) {
                if (shifted[shifted.length - 1] === Scanner.escapeToken)
                    shifted = shifted.slice(0, -1);
                else
                    break;
            }
            shifted += this.shift();
        }
        return shifted;
    }
    shiftUntilNextTerminator() {
        this.shiftUntilNonWhitespace();
        return this.shiftUntil(Scanner.lookaheadIsTerminator);
    }
    shiftUntilNonWhitespace() {
        return this.shiftUntil(Scanner.lookaheadIsNotWhitespace);
    }
    jumpToIndex(i) {
        this.i = i < 0 ? this.length + i : i;
    }
    get location() {
        return this.i;
    }
    get unscanned() {
        return this.chars.slice(this.i, this.length).join("");
    }
    get scanned() {
        return this.chars.slice(0, this.i).join("");
    }
    sliceChars(start, end) {
        return this.chars.slice(start, end).join("");
    }
    lookaheadIs(char) {
        return this.lookahead === char;
    }
    lookaheadIsIn(tokens) {
        return this.lookahead in tokens;
    }
}
(function (Scanner) {
    Scanner.lookaheadIsTerminator = (scanner) => scanner.lookahead in Scanner.terminatingChars;
    Scanner.lookaheadIsNotWhitespace = (scanner) => !(scanner.lookahead in Scanner.whiteSpaceTokens);
    Scanner.terminatingChars = {
        "<": true,
        ">": true,
        "=": true,
        "|": true,
        "&": true,
        ")": true,
        "[": true,
        "%": true,
        " ": true,
        ",": true
    };
    Scanner.finalizingLookaheads = {
        ">": true,
        ",": true,
        "": true
    };
    Scanner.escapeToken = "\\";
    Scanner.whiteSpaceTokens = {
        " ": true,
        "\n": true,
        "\t": true
    };
    Scanner.lookaheadIsFinalizing = (lookahead, unscanned) => lookahead === ">" ?
        unscanned[0] === "=" ?
            // >== would only occur in an expression like Array<number>==5
            // otherwise, >= would only occur as part of a bound like number>=5
            unscanned[1] === "="
            // if > is the end of a generic instantiation, the next token will be an operator or the end of the string
            : unscanned.trimStart() === "" ||
                isKeyOf(unscanned.trimStart()[0], Scanner.terminatingChars)
        // if the lookahead is a finalizing token but not >, it's unambiguously a finalizer (currently just ",")
        : lookahead === ",";
})(Scanner || (Scanner = {}));
