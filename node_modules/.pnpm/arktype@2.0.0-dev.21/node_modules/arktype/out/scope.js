import { RawRootScope, hasArkKind } from "@arktype/schema";
import { domainOf, hasDomain, isThunk, throwParseError } from "@arktype/util";
import { Generic } from "./generic.js";
import { createMatchParser } from "./match.js";
import { parseObject, writeBadDefinitionTypeMessage } from "./parser/definition.js";
import { parseGenericParams } from "./parser/generic.js";
import { DynamicState } from "./parser/string/reduce/dynamic.js";
import { fullStringParse } from "./parser/string/string.js";
import { RawTypeParser } from "./type.js";
export const scope = ((def, config = {}) => new RawScope(def, config));
export class RawScope extends RawRootScope {
    parseCache = {};
    constructor(def, config) {
        const aliases = {};
        for (const k in def) {
            const parsedKey = parseScopeKey(k);
            aliases[parsedKey.name] =
                parsedKey.params.length ?
                    // TODO: this
                    new Generic(parsedKey.params, def[k], {})
                    : def[k];
        }
        super(aliases, config);
    }
    type = new RawTypeParser(this);
    match = createMatchParser(this);
    declare = (() => ({
        type: this.type
    })).bind(this);
    define = ((def) => def).bind(this);
    preparseRoot(def) {
        if (isThunk(def) && !hasArkKind(def, "generic"))
            return def();
        return def;
    }
    parseRoot(def) {
        // args: { this: {} as RawRoot },
        return this.parse(def, {
            $: this,
            args: {}
            // type parsing can bypass nodes if it hits the cache,
            // so bind it directly (could be optimized)
        }).bindScope(this);
    }
    parse(def, ctx) {
        if (typeof def === "string") {
            if (ctx.args && Object.keys(ctx.args).every(k => !def.includes(k))) {
                // we can only rely on the cache if there are no contextual
                // resolutions like "this" or generic args
                return this.parseString(def, ctx);
            }
            if (!this.parseCache[def])
                this.parseCache[def] = this.parseString(def, ctx);
            return this.parseCache[def];
        }
        return hasDomain(def, "object") ?
            parseObject(def, ctx)
            : throwParseError(writeBadDefinitionTypeMessage(domainOf(def)));
    }
    parseString(def, ctx) {
        return (this.maybeResolveRoot(def) ??
            ((def.endsWith("[]") &&
                this.maybeResolveRoot(def.slice(0, -2))?.array()) ||
                fullStringParse(new DynamicState(def, ctx))));
    }
}
export const writeShallowCycleErrorMessage = (name, seen) => `Alias '${name}' has a shallow resolution cycle: ${[...seen, name].join(":")}`;
export const parseScopeKey = (k) => {
    const firstParamIndex = k.indexOf("<");
    if (firstParamIndex === -1) {
        return {
            name: k,
            params: []
        };
    }
    if (k.at(-1) !== ">") {
        throwParseError(`'>' must be the last character of a generic declaration in a scope`);
    }
    return {
        name: k.slice(0, firstParamIndex),
        params: parseGenericParams(k.slice(firstParamIndex + 1, -1))
    };
};
