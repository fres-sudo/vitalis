import { ArkErrors, BaseRoot } from "@arktype/schema";
import { Callable } from "@arktype/util";
import { Generic } from "./generic.js";
import { parseGenericParams } from "./parser/generic.js";
const typeParserAttachments = Object.freeze({
    errors: ArkErrors
});
export class RawTypeParser extends Callable {
    constructor($) {
        super((...args) => {
            if (args.length === 1) {
                // treat as a simple definition
                return $.parseRoot(args[0]);
            }
            if (args.length === 2 &&
                typeof args[0] === "string" &&
                args[0][0] === "<" &&
                args[0].at(-1) === ">") {
                // if there are exactly two args, the first of which looks like <${string}>,
                // treat as a generic
                const params = parseGenericParams(args[0].slice(1, -1));
                const def = args[1];
                // TODO: validateUninstantiatedGeneric, remove this cast
                return new Generic(params, def, $);
            }
            // otherwise, treat as a tuple expression. technically, this also allows
            // non-expression tuple definitions to be parsed, but it's not a supported
            // part of the API as specified by the associated types
            return $.parseRoot(args);
        }, { bind: $, attach: typeParserAttachments });
    }
}
export const Type = BaseRoot;
