import { RawRootScope, type ArkConfig, type BaseRoot, type GenericProps, type PreparsedNodeResolution, type PrivateDeclaration, type RawRootResolutions, type RootScope, type UnknownRoot, type ambient, type arkKind, type destructuredExportContext, type destructuredImportContext, type exportedNameOf, type writeDuplicateAliasError } from "@arktype/schema";
import { type anyOrNever, type keyError, type nominal, type show } from "@arktype/util";
import { Generic } from "./generic.js";
import { type MatchParser } from "./match.js";
import type { Module } from "./module.js";
import { type inferDefinition, type validateDefinition } from "./parser/definition.js";
import { parseGenericParams, type GenericDeclaration, type GenericParamsParseError } from "./parser/generic.js";
import { RawTypeParser, type DeclarationParser, type DefinitionParser, type Type, type TypeParser } from "./type.js";
export type ScopeParser = <const def>(def: validateScope<def>, config?: ArkConfig) => Scope<inferBootstrapped<bootstrapAliases<def>>>;
type validateScope<def> = {
    [k in keyof def]: k extends symbol ? unknown : parseScopeKey<k>["params"] extends [] ? def[k] extends Type | PreparsedResolution ? def[k] : k extends PrivateDeclaration<infer name extends keyof def & string> ? keyError<writeDuplicateAliasError<name>> : validateDefinition<def[k], ambient & bootstrapAliases<def>, {}> : parseScopeKey<k>["params"] extends GenericParamsParseError ? parseScopeKey<k>["params"][0] : validateDefinition<def[k], ambient & bootstrapAliases<def>, {
        [param in parseScopeKey<k>["params"][number]]: unknown;
    }>;
};
export type bindThis<def> = {
    this: Def<def>;
};
/** nominal type for an unparsed definition used during scope bootstrapping */
type Def<def = {}> = nominal<def, "unparsed">;
/** sentinel indicating a scope that will be associated with a generic has not yet been parsed */
export type UnparsedScope = "$";
/** These are legal as values of a scope but not as definitions in other contexts */
type PreparsedResolution = PreparsedNodeResolution;
type bootstrapAliases<def> = {
    [k in Exclude<keyof def, GenericDeclaration | symbol>]: def[k] extends PreparsedResolution ? def[k] : def[k] extends (() => infer thunkReturn extends PreparsedResolution) ? thunkReturn : Def<def[k]>;
} & {
    [k in keyof def & GenericDeclaration as extractGenericName<k>]: GenericProps<parseGenericParams<extractGenericParameters<k>>, def[k], UnparsedScope>;
};
type inferBootstrapped<$> = show<{
    [name in keyof $]: $[name] extends Def<infer def> ? inferDefinition<def, $ & ambient, {}> : $[name] extends GenericProps<infer params, infer def> ? Generic<params, def, $> : $[name];
}>;
type extractGenericName<k> = k extends GenericDeclaration<infer name> ? name : never;
type extractGenericParameters<k> = k extends GenericDeclaration<string, infer params> ? params : never;
export type resolve<reference extends keyof $ | keyof args, $, args> = (reference extends keyof args ? args[reference] : $[reference & keyof $]) extends infer resolution ? [
    resolution
] extends [anyOrNever] ? resolution : resolution extends Def<infer def> ? inferDefinition<def, $, args> : resolution : never;
export type moduleKeyOf<$> = {
    [k in keyof $]: $[k] extends {
        [arkKind]: "module";
    } ? k & string : never;
}[keyof $];
export type tryInferSubmoduleReference<$, token> = token extends `${infer submodule extends moduleKeyOf<$>}.${infer subalias}` ? subalias extends keyof $[submodule] ? $[submodule][subalias] : never : never;
export interface ParseContext {
    $: RawScope;
    args?: Record<string, UnknownRoot>;
}
export declare const scope: ScopeParser;
export interface Scope<$ = any> extends RootScope<$> {
    type: TypeParser<$>;
    match: MatchParser<$>;
    declare: DeclarationParser<$>;
    define: DefinitionParser<$>;
    import<names extends exportedNameOf<$>[]>(...names: names): Module<show<destructuredImportContext<$, names>>>;
    export<names extends exportedNameOf<$>[]>(...names: names): Module<show<destructuredExportContext<$, names>>>;
}
export declare class RawScope<$ extends RawRootResolutions = RawRootResolutions> extends RawRootScope<$> {
    private parseCache;
    constructor(def: Record<string, unknown>, config?: ArkConfig);
    type: RawTypeParser;
    match: MatchParser<$>;
    declare: () => {
        type: RawTypeParser;
    };
    define: (def: unknown) => unknown;
    preparseRoot(def: unknown): unknown;
    parseRoot(def: unknown): BaseRoot;
    parse(def: unknown, ctx: ParseContext): BaseRoot;
    parseString(def: string, ctx: ParseContext): BaseRoot;
}
export declare const writeShallowCycleErrorMessage: (name: string, seen: string[]) => string;
export type ParsedScopeKey = {
    name: string;
    params: string[];
};
export declare const parseScopeKey: (k: string) => ParsedScopeKey;
export type parseScopeKey<k> = k extends GenericDeclaration<infer name, infer paramString> ? {
    name: name;
    params: parseGenericParams<paramString>;
} : {
    name: k;
    params: [];
};
export {};
