export const getPath = (root, path) => {
    let result = root;
    for (const segment of path) {
        if (typeof result !== "object" || result === null)
            return undefined;
        result = result[segment];
    }
    return result;
};
export const intersectUniqueLists = (l, r) => {
    const intersection = [...l];
    for (const item of r)
        if (!l.includes(item))
            intersection.push(item);
    return intersection;
};
export const arrayFrom = (data) => (Array.isArray(data) ? data : [data]);
export const spliterate = (list, by) => {
    const result = [[], []];
    for (const item of list) {
        if (by(item))
            result[0].push(item);
        else
            result[1].push(item);
    }
    return result;
};
export const ReadonlyArray = Array;
export const includes = (array, element) => array.includes(element);
export const range = (length, offset = 0) => [...new Array(length)].map((_, i) => i + offset);
/**
 * Adds a value or array to an array, returning the concatenated result
 *
 * @param to The array to which `value` is to be added. If `to` is `undefined`, a new array
 * is created as `[value]` if value was not undefined, otherwise `[]`.
 * @param value The value to add to the array. If `value` is `undefined`, does nothing.
 * @param opts
 * 		prepend: If true, adds the element to the beginning of the array instead of the end
 */
export const append = (to, value, opts) => {
    if (value === undefined)
        return to ?? [];
    if (to === undefined) {
        return (value === undefined ? []
            : Array.isArray(value) ? value
                : [value]);
    }
    if (opts?.prepend)
        Array.isArray(value) ? to.unshift(...value) : to.unshift(value);
    else
        Array.isArray(value) ? to.push(...value) : to.push(value);
    return to;
};
/**
 * Concatenates an element or list with a readonly list
 *
 * @param {to} to - The base list.
 * @param {elementOrList} elementOrList - The element or list to concatenate.
 */
export const conflatenate = (to, elementOrList) => {
    if (elementOrList === undefined || elementOrList === null)
        return to ?? [];
    if (to === undefined || to === null)
        return arrayFrom(elementOrList);
    return to.concat(elementOrList);
};
/**
 * Concatenates a variadic list of elements or lists with a readonly list
 *
 * @param {to} to - The base list.
 * @param {elementsOrLists} elementsOrLists - The elements or lists to concatenate.
 */
export const conflatenateAll = (...elementsOrLists) => elementsOrLists.reduce(conflatenate, []);
/**
 * Appends a value to an array if it is not already included, returning the array
 *
 * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array
 * is created including only `value`.
 * @param value The value to append to the array. If `to` includes `value`, nothing is appended.
 */
export const appendUnique = (to, value) => {
    if (to === undefined)
        return [value];
    if (!to.includes(value))
        to.push(value);
    return to;
};
export const groupBy = (array, discriminant) => array.reduce((result, item) => {
    const key = item[discriminant];
    result[key] ??= [];
    result[key].push(item);
    return result;
}, {});
